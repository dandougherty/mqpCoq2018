\documentclass[12pt]{report}
\usepackage[utf8x]{inputenc}

%Warning: tipa declares many non-standard macros used by utf8x to
%interpret utf8 characters but extra packages might have to be added
%such as "textgreek" for Greek letters not already in tipa
%or "stmaryrd" for mathematical symbols.
%Utf8 codes missing a LaTeX interpretation can be defined by using
%\DeclareUnicodeCharacter{code}{interpretation}.
%Use coqdoc's option -p to add new packages or declarations.
\usepackage{tipa}

\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{coqdoc}
\usepackage{amsmath,amssymb}
\usepackage{url}
\usepackage{natbib} \hypersetup{ hidelinks } \usepackage{graphicx} \graphicspath{ {.} } \newtheorem{definition}{Definition}[section]
\begin{document}
\input{front_matter.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% This file has been automatically generated with the command
%% coqdoc -toc -interpolate -utf8 --latex -R . B_Unification -o all.tex introduction.v terms.v lowenheim_formula.v lowenheim_proof.v list_util.v poly.v poly_unif.v sve.v -p \usepackage{natbib} \hypersetup{ hidelinks } \usepackage{graphicx} \graphicspath{ {.} } \newtheorem{definition}{Definition}[section] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\coqlibrary{B Unification.introduction}{Library }{B\_Unification.introduction}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Introduction}



 In the field of computer science, one problem of significance is that of
    equational unification; namely, the finding of solutions to a given set of
    equations with respect to a set of equational axioms. While there are
    several variants of equational unification, for the purposes of this paper
    we are going to limit our scope to that of Boolean unification, which deals
    with the finding of unifiers for the equations defining Boolean rings.
    There exists a great deal of research in the formal verification of
    unification algorithms \cite[]{baader2001unification}; our research
    focused on two of these algorithms: Lowenheim's formula and succesive
    variable eliminaton. To conduct our research, we utilized the Coq proof
    assistant \url{https://coq.inria.fr/} to create formal specifications of
    both of these algorithms' behaviors in addition to proving their
    correctness. While proofs for both of these algorithms already exist
    \cite[p.~254-258]{baader1998rewriting}, prior to the writing of this
    paper, no formal treatment using a proof asssistant such as Coq had been
    undertaken, so it is hoped that our efforts towards porting these algorithms
    onto software provide a useful suite of tools for anyone interested in
    working with equational logic. 

 Due to the differences in the innate nature of Lowenheim's formula compared
    to that of successive variable elimination, our project was divided into two
    separate developments, each approaching their respective goals from a
    different direction. The primary distinction between these two treatments
    comes down to their representations of equations. The Lowenheim's formula
    development uses a more straightforward, term-based representation of
    equations while the successive variable elimination development opts to
    represent equations in their polynomial forms. Fortunately, due to the fact
    that every term has a unique polynomial representation
    \cite[p.~263]{baader1998rewriting}, these two formats for representing
    equations are mathematically equivalent to one another. 

\section{Formal Verification}



 Formal verification is the term used to describe the act of verifying (or
    disproving) the correctness of software and hardware systems or theories.
    Formal verification consists of a set of techinques that perform static
    analysis on the behavior of a system, or the correctness of a theory. It
    differs from dynamic analysis that uses simulation to evaluate the
    correctness of a system. 

 More simply stated, formal verification is the process of examining whether
    a system or a theory ``does what it is supposed to do.'' If it is a system,
    then scientistis formally verify that it satisfies its design requirements.
    Formal verification is also different from testing. Software testing tries
    to detect ``bugs'', specific errors, and requirements in the system, whereas
    verfification acts as a general safeguard that the system is always
    error-free. As Edsger Dijkstra stated \cite[slide ~7]{UCI18}, testing can be used to show the
    presence of bugs, but never to show their absence. When trying to verify a theory,
    scientists formally verify the correctness of the theory by formulating its
    proof using a formal language, axioms and inference rules. 

 Formal verification is used because it does not have to evaluate every
    possible case or state to determine if a system or theory meets all the
    preset logical conditions and requirements. Moreover, as design and software
    systems sizes have increased (along with their simulation times),
    verification teams have been looking for alternative methods of proving or
    disproving the correctness of a system in order to reduce the required time
    to perform a correctness check or evaluation. 

\subsection{Proof Assistants}



 A proof assistant is a software tool that is used to formulate and prove or
    disprove theorems in computer science or mathematical logic. They are also
    called interactive theorem provers and they may also involve some type of
    proof and text editor that the user can use to form, prove, and define
    theorems, lemmas, functions, etc. They facilitate that process by allowing
    the user to search definitions, terms and even provide some kind of guidance
    during the formulation or proof of a theorem. Some examples of proof assistants
    are Coq - which is the one we are using -, Isabelle, HOL Light and Lean.

\subsection{Verifying Systems}



 Formal verification is used to verify the correctness of software or
    hardware systems \cite{UCFV02} . When used to verify systems, formal verification can be
    thought as a mathematical proof of the correctness of a design with respect
    to a formal specification. The actual system is represented by a formal
    model and then the formal verification happens on the model, based on the
    required specifications of the system. Unlike testing, formal verification
    is exhaustive. However, it is difficult to make for real-world systems, 
    time consuming and only as reliable as the actual model. 

\subsection{Verifying Theories}



 Formal verification is also used in to prove theorems. These theorems could
    be related to a computing system or just to abstract mathematical 
    theorems. Mathematical theorems that have been proven using a proof assistant
    include the Four-Color theorem and the Feit-Thompson theorem. 
    As in proving systems, when proving theorems one also needs a
    formal logic to formulate the theorem and prove it. A formal logic consists
    of a formal languge to express the theorems, a collection of formulas called
    axioms and inference rules to derive new axioms based on existing ones. A
    theorem to be proven could be in a logical form, like DeMorgan's Law or it
    could in another mathematical area; in trigonometry for example, it could be
    useful to prove that $sin(x + y) = sin(x) \ast cos(y) + cos(x) \ast sin(y)$,
    formally, because that proof could be used as building block in a more
    complex system. Sometimes proving the correctness of a real world systems
    boils down to verifying mathemetical proofs like the previous one, so the
    two approaches are often linked together. 

\section{Unification}



 Before defining unification, there is some terminology to understand. 

\subsection{Terms and Substitutions}



 \begin{definition} A \textbf{term} is either a variable or a function
    applied to terms \cite[p.~34]{baader1998rewriting}. \end{definition}
    By this definition, a constant term is just a nullary function.
    \begin{definition} A \textbf{variable} is a symbol capable of taking on the
    value of any term. \end{definition}
    An example of a term is \coqdocvariable{f}(\coqdocvariable{a}, \coqdocvariable{x}), where \coqdocvariable{f} is a function of two arguments,
    \coqdocvariable{a} is a constant, and \coqdocvariable{x} is a variable.
    \begin{definition} A term is \textbf{ground} if no variables occur in it
    \cite[p.~37]{baader1998rewriting}. \end{definition}
    The last example is not a ground term but \coqdocvariable{f}(\coqdocvariable{a}, \coqdocvariable{a}) would be. 

 \begin{definition} A \textbf{substitution} is a mapping from variables to
    terms. \end{definition}
    \begin{definition} The \textbf{domain} of a substitution is the set of
    variables that do not get mapped to themselves. \end{definition}
    \begin{definition} The \textbf{range} is the set of terms that are mapped
    to by the domain \cite[p.~37]{baader1998rewriting}. \end{definition}
    It is common for substitutions to be referred to as mappings from terms to
    terms. A substitution $\sigma$ can be extended to this form by defining
    $\hat{\sigma}(s)$ for two cases of \coqdocvariable{s}. If \coqdocvariable{s} is a variable, then
    $\hat{\sigma}(s) := \sigma(s)$. If \coqdocvariable{s} is a function $f(s_{1}, ..., s_{n})$,
    then $\hat{\sigma}(s) := f(\hat{\sigma}(s_{1}), ..., \hat{\sigma}(s_{n}))$
    \cite[p.~38]{baader1998rewriting}. 

\subsection{Unification and Unifiers}



 Unification is the process of solving a set of equations between two terms.
    \begin{definition} The set of equations to solve is referred to as a
    \textbf{unification problem} \cite[p.~71]{baader1998rewriting}.
    \end{definition}
    The process of solving one of these problems can be classified by the set
    of terms considered and the equality of any two terms. The latter property
    is what distinguishes two broad groups of algorithms, namely syntactic and
    semantic unification.
    \begin{definition} If two terms are only considered equal if they are
    identical, then the unification is \textbf{syntactic}
    \cite[p.~71]{baader1998rewriting}. \end{definition}
    \begin{definition} If two terms are equal with respect to an equational
    theory [E], then the unification is \textbf{semantic}. It is also called
    [E]-unification \cite[p.~224]{baader1998rewriting}. \end{definition}
    For example, the terms $x \ast y$ and $y \ast x$ are not syntactically
    equal, but they are semantically equal modulo commutativity of
    multiplication. 

 The goal of unification is to find the \textit{best} solution to a problem, which
    formally means to produce a most general unifier of the problem. The next
    four definitions should make this clearer.
    \begin{definition} A substitution $\sigma$ \textbf{unifies} an equation
    $s \stackrel{?}{=} t$ if applying $\sigma$ to both sides makes them equal
    $\sigma(s) = \sigma(t)$. \end{definition}
    \begin{definition} If $\sigma$ unifies every equation in the problem $S$,
    we call $\sigma$ a \textbf{solution} or \textbf{unifier} of $S$
    \cite[p.~71]{baader1998rewriting}. \end{definition}
    \begin{definition} A substitution $\sigma$ is \textbf{more general} than
    $\sigma'$ if there exists a third substitution $\delta$ such that
    $\sigma'(u) = \delta(\sigma(u))$ for any term $u$. \end{definition}
    \begin{definition} A substitution is a \textbf{most general unifier} or
    \textbf{mgu} of a problem if it is more general than every other solution
    to the problem \cite[p.~71]{baader1998rewriting}. \end{definition}
    It should be noted that although solvable problem of Boolean unification
    produce a single mgu, semantic unification problems in general can have
    zero, multiple, or infinitely many mgu's
    $\cite[p.~226]{baader1998rewriting}$. 

\subsection{Syntatic Unification}



 This is the simplest version of unification. It is a special case of
    \coqdocvar{E}-unification where $E = \emptyset$. For two terms to be considered
    equal they must be identical. Problems of this kind can be solved by
    repeated transformations until the solution pops out similar to solving a
    linear system by Guassian elimination \cite[p.~73]{baader1998rewriting}.
    One of the most notable applications of syntactic unification is the
    Hindley-Milner type system used in functional programming languages like
    ML \cite[]{damas1982principal}. More complicated type systems such as the
    one used by Coq require more complicated versions of unification (e.g.
    higher-order unification) \cite[]{chlipala2010introduction}. 

\subsection{Semantic Unification}



 This kind of unification involves an equational theory. Given a set of
    identities \coqdocvar{E}, we write that two terms \coqdocvariable{s} and \textit{t} are equal with regards
    to \coqdocvar{E} as $s \approx_{E} t$.  This means that there is a chain of terms
    leading from \coqdocvariable{s} to \textit{t} in which each term is derived from the previous one
    by replacing a subterm \coqdocvariable{u} by a term \coqdocvariable{v} when \coqdocvariable{u} = \coqdocvariable{v} is an instance of an
    axiom of \coqdocvar{E}.  For a careful definition see \cite[]{baader1998rewriting},
    but an example should make the idea clear.


    If we take \coqdocvariable{C} to be the set $\{f(x, y) \approx f(y, x)\}$, we then have
    $f(b, f(a, c)) \approx_{C} f(f(c, a), b)$, via the sequence of steps
    $f(b, f(a, c)) \approx_{C} f(f(a, c), b) \approx_{C} f(f(c, a), b)$. Now we
    say that two terms \coqdocvariable{s} and \textit{t} are \coqdocvar{E}-unifiable if there is a substitution
    $\sigma$ such that $\sigma(s) \approx_{E} \sigma(t)$. For example, the
    problem $\{f(x, f(a, y)) \stackrel{?}{=} f(f(c, a), b)\}$ is \coqdocvariable{C}-unified by
    the substitution $\{x \mapsto b, y \mapsto c\}$ since
    $f(b, f(a, c)) \approx_{C} f(f(c, a), b)$. For some \coqdocvar{E}, the problem of
    \coqdocvar{E}-unification can actually be undecidable
    \cite[p.~71]{baader1998rewriting}. An example would be unification modulo
    ring theory. 

\subsection{Boolean Unification}



 In this paper, we focus on unification modulo Boolean ring theory, also
    referred to as \coqdocvariable{B}-unification. The allowed terms in this theory are the
    constants 0 and 1 and binary functions + and $\ast$. The set of identities
    \coqdocvariable{B} is defined as follows:
    
    \begin{gather*}
      \left\{
      \begin{aligned}
        \begin{split}
          x + y &\approx y + x, \\
          (x + y) + z &\approx x + (y + z), \\
          x + x &\approx 0, \\
          0 + x &\approx x, \\
          x \ast (y + z) &\approx (x \ast y) + (x \ast z), \\
        \end{split}
        \begin{split}
          x \ast y &\approx y \ast x, \\
          (x \ast y) \ast z &\approx x \ast (y \ast z), \\
          x \ast x &\approx x, \\
          0 \ast x &\approx 0, \\
          1 \ast x &\approx x
        \end{split}
      \end{aligned}
      \right\}
    \end{gather*}
     \cite[p.~250]{baader1998rewriting}. This set is equivalent to
    the axioms of ring theory with the addition of $x + x \approx_{B} 0$ and
    $x \ast x \approx_{B} x$. 

 Although a unification problem was already defined as a set of equations
    between two terms, problems of Boolean unification can be viewed as just a
    single equation $t \stackrel{?}{\approx}_{B} 0$. If a substitution $\sigma$
    unifies a problem of the form \begin{gather*} \{s_{1}
    \stackrel{?}{\approx}_{B} t_{1}, ..., s_{n} \stackrel{?}{\approx}_{B} t_{n}
    \}, \end{gather*} then $\sigma$ also unifies an equivalent problem of the
    form \begin{gather*} \{(s_{1} + t_{1} + 1) \ast ... \ast
    (s_{n} + t_{n} + 1) + 1 \stackrel{?}{\approx}_{B} 0\},\end{gather*} as
    proven later in section 2.6. This fact allows both developments to use the
    simpler $t \stackrel{?}{\approx}_{B} 0$ description of a problem. 

\section{Importance}



 Given that the emergence of proof assistance software is still in its
    infancy relative to the traditional methods of theorem proving, it
    would be a disservice for us to not establish the importance of this
    technology and its implications for the future of mathematics. Unlike in
    years past, where the sheer volume of detail could derail the
    developments of sound theorems, proof assistants now guarantee through their
    properties of verification that any development verified by them is free
    from lapses in logic on account of the natural failings of the human mind.
    Additionally, due to the adoption of a well-defined shared language, many of
    the ambiguities naturally present in the exchange of mathematical ideas
    between colleagues are mitigated, leading to a smoother learning curve for
    newcomers trying to understand the nuts and bolts of a complex theorem. The
    end result of these phenomenon is a faster iterative development cycle for
    mathemeticians as they now can spend more time on proving things and
    building off of the work of others since they no longer need to devote as
    much of their efforts towards verifying the correctness of the theorems they
    are operating across. 

 Bearing this in mind, it should come as no surprise that there is a utility
    in going back to older proofs that have never been verified by a proof
    assistant and redeveloping them for the purposes of ensuring their
    correctness. If the theorem is truly sound, it stands to reason that any
    additional rigorous scrutiny would only serve to bolster the credibility of
    its claims, and conversely, if the theorem is not sound, it is a benefit to
    the academic community at large to be made aware of its shortcomings.
    Therefore, for these reasons we set out to formally verify two algorithms
    across Boolean Unification. 

\section{Development}



\subsection{Algorithms}



 There are many different approaches that one could take to go about
    formalizing a proof of Boolean Unification algorithms, each with their own
    challenges. For this development, we have opted to base our work on
    chapter 10, \textit{Equational Unification}, in \textit{Term Rewriting and All That} by
    Franz Baader and Tobias Nipkow \cite[]{baader1998rewriting}. Specifically,
    section 10.4, titled \textit{Boolean Unification}, details Boolean rings, data
    structures to represent them, and two algorithms to perform unification in
    Boolean rings. 

 We chose to implement these two different Boolean Unification algorithms,
    and then proceeded to formally prove their correctness on all inputs. The
    two algorithms in question are Lowenheim's formula and Successive Variable
    Elimination. 

 The first solution, \textbf{Lowenheim's algorithm}, is based on the idea
    that the Lowenheim formula can take any unifier of a Boolean unification
    problem and turn it into a most general unifier. The algorithm then of
    course first requires a unifier to begin; we have opted to use a simple
    brute force solution to find a ground unifier, replacing variables with only
    0 or 1. This ground solution is then passed through the formula, to create a
    most general unifier. Lowenheim's algorithm is implemented in the file
    \coqdocvar{lowenheim.v}, and the proof of correctness is in \coqdocvar{lowenheim\_proof.v}. 

 The second algorithm, \textbf{successive variable elimination}, is built
    on the idea that by factoring variables out of an equation one-by-one, we
    can eventually reach a problem that can be solved by the identity unifier.
    This base problem is then slowly built up by adding the variables that were
    previously eliminated, building up the matching unifier as we do so. Once we
    have added all variables back in, we are left with the original problem as
    well as a most general unifier for it. Successive variable elimination and
    its proof of correctness are both in the file \coqdocvar{sve.v}. 

\subsection{Data Structures}



 The data structure used to represent a Boolean unification problem
    completely changes the shape of both the unification algorithm and the proof
    of correctness, and is therefore a very important decision. For this
    development, we have selected two different representations of Boolean rings
 first as a ``Term'' inductive type, and then as lists of lists representing
    terms in polynomial form. 

\subsubsection{Term Inductive Type}



 The Term inductive type, used in the proof of Lowenheim's algorithm, is very
    simple and rather intuitive -- a term in a Boolean ring is one of 5 things:

\begin{itemize}
\item 	The number 0

\item 	The number 1

\item 	A variable

\item 	Two terms added together

\item 	Two terms multiplied together

\end{itemize}


 In our development, variables are represented as natural numbers. 

 After defining terms like this, it is necessary to define a new equality
    relation, referred to as term equivalence, for comparing terms. With the
    term equivalence relation defined, it is easy to define ten axioms enabling
    the ten identities that hold true over terms in Boolean rings. 

 The inductive representation of terms in a Boolean ring and unification over
    these terms are defined in the file \coqdocvar{terms.v}. 

\subsubsection{Benefits and Challenges of the Inductive Type}



 The most apparent benefit of utilizing an inductive representation of terms
    becomes obvious from the moment one looks at a term in this format:
    inductively represented terms are easily able to be read and understood
    since the format is identical to the typical presentation of equations one
    is used to. This allows for inductively represented terms to be very
    intuitive and easy to reason about. This benefit does not come without its
    costs however. For starters, by representing terms in this manner, we can no
    longer make use of Coq's built-in equivalence operator since it would be
    corrupted by the axioms of Boolean rings and lead to bogus proofs. This
    forced us to develop our own equivalence relation that strictly abides by
    the Boolean ring axioms. While this certainly prevented Coq from accepting
    erroneous proofs, it did significantly increase the tediousness and
    complexity of proving theorems on account of the fact that Coq could not
    perform induction across our custom equivalence relation. At best, this
    resulted in proofs that were substantially longer than they would have been
    otherwise with a more powerful definition (such as Coq's built in
    equivalence relation), and at worst resulted in certain lemmas being
    unprovable, forcing them to be axiomatized. 

\subsubsection{Polynomial List-of-List Representation}



 The second representation, used in the proof of successive variable
    elimination, uses lists of lists of variables to represent terms in
    polynomial form. A \textbf{monomial} is a list of distinct variables
    multiplied together. A \textbf{polynomial}, then, is a list of distinct
    monomials added together. Variables are represented the same way, as natural
    numbers. The terms 0 and 1 are represented as the empty polynomial and the
    polynomial containing only the empty monomial, respectively. 

 The interesting part of the polynomial representation is how the ten
    identities are implemented. Rather than writing axioms enabling these
    transformations, we chose to implement the addition and multiplication
    operations in such a way to ensure these rules hold true, as described in
    \textit{Term Rewriting}\%\symbol{92}cite\ensuremath{\Box}\{baader1998rewriting\}. 

 \textbf{Addition} is performed by cancelling out all repeated occurrences
    of monomials in the result of appending the two lists together (i.e.,
    \coqdocvariable{x} + \coqdocvariable{x} = 0). This is equivalent to the symmetric difference in set theory,
    keeping only the terms that are in either one list or the other (but not
    both). \textbf{Multiplication} is slightly more complicated. The product
    of two polynomials is the result of multiplying all combinations of
    monomials in the two polynomials and removing all repeated monomials. The
    product of two monomials is the result of keeping only one copy of each
    repeated variable after appending the two together. 

 To assist with maintaining the strict polynomial form, a ``repair'' function
    was defined. This function, given any list of lists of variables, will sort
    and remove duplicates to ensure the result is a proper polynomial. As a
    result of this design, we are able to compare monomials and polynomials
    using the standard Coq equivalence relation for lists, rather than defining
    our own. In this way, we have effectively embedded the ten axioms in our
    operations, and do not need to manually declare them. 

 The polynomial representation is defined in the file \coqdocvar{poly.v}. Unification
    over these polynomials is defined in \coqdocvar{poly\_unif.v}. 

\subsubsection{Benefits and Challenges of the List Representation}



 As mentioned above, one of the main benefits of the list representation is
    that is enables us to use the standard Coq equivalence operator in comparing
    terms. This makes a wide variety of things easier, from removing the need
    to prove compatibility of functions with equivalence for rewriting, to
    allowing us to use all of the standard library lemmas relating to lists.
    It does, however, come at a cost. 

 The biggest issue with this design is the amount of work that goes into
    maintaining this form at every term. Our addition function is defined very
    simply; we just append the two polynomials, and call our ``repair'' function
    on the result. While this sounds simple, it becomes incredibly difficult to
    prove facts about addition (and our other operations) because of the repair
    function. 

 This function does three things: sort the list, cancel out duplicates, and
    convert all sublists to properly formatted monomials. The main difficulties
    come from the first two parts. Sorting is incredibly difficult to deal with,
    as it makes induction over these lists infinitely harder. When proving some
    fact with induction, the goal of the proof is often something of the form
    \begin{gather*} f(a::l) = f(a)::f(l).\end{gather*} However, if the
    function in question sorts the list it's given, there is no guarantee that
    \coqdocvariable{a} is going to be the head of the resulting list, thus making the result
    unprovable. As a result, we had to prove many lemmas about Permutations,
    and almost exclusively compare lists as a permutation of one another when
    working with polynomial operations. 

 Another challenge comes from the cancelling of duplicates. When working with
    more in-depth proofs of polynomial arithmetic, we often try to prove that
    some element \coqdocvariable{x} either will or won't be in a polynomial after some \coqdocvariable{f} is
    applied, based on whether or not it is in the polynomial before. This leads
    us to a point where we need to reason about if \coqdocvariable{x} should be eliminated from
    either list, which requires us to know how many times \coqdocvariable{x} appears in each
    list. However, even if we know whether or not \coqdocvariable{x} should be removed from
    the original list, it is hard to reason about if it should be removed from
    the list after \coqdocvariable{f} is applied, as \coqdocvariable{f} is not one-to-one and there may be
    some \coqdocvariable{y} such that \coqdocvariable{f} \coqdocvariable{x} = \coqdocvariable{f} \coqdocvariable{y}. This once again complicates proofs a lot,
    and required us to prove many facts about our \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} function
    performing this de-duplication. 

 After working through these hiccups, though, some aspects of the project
    became incredibly simple. As mentioned above, the math operations were both
    very easy to define, and the act of variable elimination and adding itself
    is very straightforward when you can simply filter a polynomial with the
    Coq list functions. Given the chance, it probably would have been
    beneficial to look into defining our own equivalence relation that compares
    without order, removing the need for sorting. The issue of deduplication
    would have still come up in one form or another, though, so we probably
    could not have easily avoided the problems caused by that. \begin{coqdoccode}
\end{coqdoccode}
\coqlibrary{B Unification.terms}{Library }{B\_Unification.terms}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclibrary{Bool}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.omega.Omega}{\coqdoclibrary{Omega}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclibrary{EqNat}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclibrary{List}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Setoids.Setoid}{\coqdoclibrary{Setoid}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Introduction}



 In order for any proofs to be constructed in Coq, we need to formally define
    the logic and data across which said proofs will operate. Since the heart of
    our analysis is concerned with the unification of Boolean equations, it
    stands to reason that we should articulate precisely how algebra functions
    with respect to Boolean rings. To attain this, we shall formalize what an
    equation looks like, how it can be composed inductively, and also how
    substitutions behave when applied to equations. 

\section{Terms}



\subsection{Definitions}



 We shall now begin describing the rules of Boolean arithmetic as well as the
    nature of Boolean equations. For simplicity's sake, from now on we shall be
    referring to equations as terms. 

  Define a variable to be a natural number \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.var}{var}{\coqdocdefinition{var}} := \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A \textit{term}, as has already been previously described, is now inductively
    declared to hold either a constant value, a single variable, a sum of terms,
    or a product of terms. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{B Unification.terms.term}{term}{\coqdocinductive{term}}: \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{B Unification.terms.T0}{T0}{\coqdocconstructor{T0}}  : \coqref{B Unification.terms.term}{\coqdocinductive{term}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{B Unification.terms.T1}{T1}{\coqdocconstructor{T1}}  : \coqref{B Unification.terms.term}{\coqdocinductive{term}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{B Unification.terms.VAR}{VAR}{\coqdocconstructor{VAR}}  : \coqref{B Unification.terms.var}{\coqdocdefinition{var}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.term}{\coqdocinductive{term}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{B Unification.terms.SUM}{SUM}{\coqdocconstructor{SUM}} : \coqref{B Unification.terms.term}{\coqdocinductive{term}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.term}{\coqdocinductive{term}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.term}{\coqdocinductive{term}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{B Unification.terms.PRODUCT}{PRODUCT}{\coqdocconstructor{PRODUCT}} : \coqref{B Unification.terms.term}{\coqdocinductive{term}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.term}{\coqdocinductive{term}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.term}{\coqdocinductive{term}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For convenience's sake, we define some shorthanded notation for readability.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Implicit} \coqdockw{Types} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}.\coqdoceol
\coqdocnoindent
\coqdockw{Implicit} \coqdockw{Types} \coqdocvar{n} \coqdocvar{m} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{B Unification.terms.:::x '+' x}{"}{"}x + y" := (\coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 50, \coqdoctac{left} \coqdockw{associativity}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{B Unification.terms.:::x '*' x}{"}{"}x * y" := (\coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 40, \coqdoctac{left} \coqdockw{associativity}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Axioms}



 Now that we have informed Coq on the nature of what a term is, it is now
    time to propose a set of axioms that will articulate exactly how algebra
    behaves across Boolean rings. This is a requirement since the very act of
    unifying an equation is intimately related to solving it algebraically. Each
    of the axioms proposed below describe the rules of Boolean algebra precisely
    and in an unambiguous manner. None of these should come as a surprise to the
    reader; however, if one is not familiar with this form of logic, the rules
    regarding the summation and multiplication of identical terms might pose as
    a source of confusion.


    For reasons of keeping Coq's internal logic consistent, we roll our own
    custom equivalence relation as opposed to simply using ``=''. This will
    provide a surefire way to avoid any odd errors from later cropping up in our
    proofs. Of course, by doing this we introduce some implications that we will
    need to address later. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{B Unification.terms.eqv}{eqv}{\coqdocaxiom{eqv}} : \coqref{B Unification.terms.term}{\coqdocinductive{term}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.term}{\coqdocinductive{term}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
 Here we introduce some special notation for term equivalence \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Infix} \coqdef{B Unification.terms.:::x '==' x}{"}{"} == " := \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}} (\coqdoctac{at} \coqdockw{level} 70).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Below is the set of fundamental axioms concerning the equivalence ``==''
    relation. They form the boolean ring (or system) on which Lowenheim's
    formula and proof are developed.


    Most of these axioms will appear familiar to anyone; however, certain ones
    such as the summation of two identical terms are true only across Boolean
    rings and as such might appear strange at first glance. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.sum comm}{sum\_comm}{\coqdocaxiom{sum\_comm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{y} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{y} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.sum assoc}{sum\_assoc}{\coqdocaxiom{sum\_assoc}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{y}\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{z} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{(}}\coqdocvariable{y} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{z}\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.sum id}{sum\_id}{\coqdocaxiom{sum\_id}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{x}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Across boolean rings, the summation of two terms will always be 0 because
    there are only two elements in the ring: 0 and 1. For this reason, the
    mapping of 1 + 1 has nowhere else to go besides 0. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.sum x x}{sum\_x\_x}{\coqdocaxiom{sum\_x\_x}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.mul comm}{mul\_comm}{\coqdocaxiom{mul\_comm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{y} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{y} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.mul assoc}{mul\_assoc}{\coqdocaxiom{mul\_assoc}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{y}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{z} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{y} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{z}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Across boolean rings, the multiplication of two identical terms will always
    be the same as just having one instance of said term. This is because
    $0 \ast 0 = 0$ and $1 \ast 1 = 1$ as one would expect normally. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.mul x x}{mul\_x\_x}{\coqdocaxiom{mul\_x\_x}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.mul T0 x}{mul\_T0\_x}{\coqdocaxiom{mul\_T0\_x}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.mul id}{mul\_id}{\coqdocaxiom{mul\_id}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.distr}{distr}{\coqdocaxiom{distr}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{y} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{z}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{y}\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{z}\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Any axioms beyond this point of the development are not considered part of
    the ``fundamental axiom system'', but they still need to exist for the
    development and proofs to hold. 

 Across all equations, adding an expression to both sides does not break the
    equivalence of the relation. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.term sum symmetric}{term\_sum\_symmetric}{\coqdocaxiom{term\_sum\_symmetric}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{y} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{z} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{y} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{z}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.refl comm}{refl\_comm}{\coqdocaxiom{refl\_comm}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{t1} \coqdocvar{t2}, \coqdocvariable{t1} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{t2} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t1}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.T1 not equiv T0}{T1\_not\_equiv\_T0}{\coqdocaxiom{T1\_not\_equiv\_T0}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\~{}(}}\coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{sum\_comm} \coqdocvar{sum\_assoc} \coqdocvar{sum\_x\_x} \coqdocvar{sum\_id} \coqdocvar{distr}\coqdoceol
\coqdocindent{6.50em}
\coqdocvar{mul\_comm} \coqdocvar{mul\_assoc} \coqdocvar{mul\_x\_x} \coqdocvar{mul\_T0\_x} \coqdocvar{mul\_id}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now that the core axioms have been taken care of, we need to handle the
    implications posed by our custom equivalence relation. Below we inform Coq
    of the behavior of our equivalence relation with respect to reflexivity,
    symmetry, and transitivity in order to allow for rewrites during the
    construction of proofs operating across our new equivalence relation. \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.eqv ref}{eqv\_ref}{\coqdocaxiom{eqv\_ref}} : \coqexternalref{Reflexive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Classes.RelationClasses}{\coqdocclass{Reflexive}} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}}.\coqdoceol
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.eqv sym}{eqv\_sym}{\coqdocaxiom{eqv\_sym}} : \coqexternalref{Symmetric}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Classes.RelationClasses}{\coqdocclass{Symmetric}} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}}.\coqdoceol
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.eqv trans}{eqv\_trans}{\coqdocaxiom{eqv\_trans}} : \coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Classes.RelationClasses}{\coqdocclass{Transitive}} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Add} \coqdocvar{Parametric} \coqdocvar{Relation} : \coqref{B Unification.terms.term}{\coqdocinductive{term}} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity} \coqdocvar{proved} \coqdoctac{by} @\coqref{B Unification.terms.eqv ref}{\coqdocaxiom{eqv\_ref}}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{symmetry} \coqdocvar{proved} \coqdoctac{by} @\coqref{B Unification.terms.eqv sym}{\coqdocaxiom{eqv\_sym}}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{transitivity} \coqdocvar{proved} \coqdoctac{by} @\coqref{B Unification.terms.eqv trans}{\coqdocaxiom{eqv\_trans}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{as} \coqdocvar{eq\_set\_rel}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.SUM compat}{SUM\_compat}{\coqdocaxiom{SUM\_compat}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{x'}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{x'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{y} \coqdocvar{y'}, \coqdocvariable{y} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{y'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{y}\coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{(}}\coqdocvariable{x'} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{y'}\coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.PRODUCT compat}{PRODUCT\_compat}{\coqdocaxiom{PRODUCT\_compat}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{x'}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{x'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{y} \coqdocvar{y'}, \coqdocvariable{y} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{y'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{y}\coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{(}}\coqdocvariable{x'} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{y'}\coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Add} \coqdocvar{Parametric} \coqdocvar{Morphism} : \coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{signature} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{==>}} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{==>}} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}} \coqdockw{as} \coqdocvar{SUM\_mor}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{exact} \coqref{B Unification.terms.SUM compat}{\coqdocaxiom{SUM\_compat}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Add} \coqdocvar{Parametric} \coqdocvar{Morphism} : \coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{signature} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{==>}} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{==>}} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}} \coqdockw{as} \coqdocvar{PRODUCT\_mor}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{exact} \coqref{B Unification.terms.PRODUCT compat}{\coqdocaxiom{PRODUCT\_compat}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{eqv\_ref} \coqdocvar{eqv\_sym} \coqdocvar{eqv\_trans} \coqdocvar{SUM\_compat} \coqdocvar{PRODUCT\_compat}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Lemmas}



 Since Coq now understands the basics of Boolean algebra, it serves as a good
    exercise for us to generate some further rules using Coq's proving systems.
    By doing this, not only do we gain some additional tools that will become
    handy later down the road, but we also test whether our axioms are behaving
    as we would like them to. 

 This is a lemma for a sub-case of term multiplication. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.mul x x plus T1}{mul\_x\_x\_plus\_T1}{\coqdoclemma{mul\_x\_x\_plus\_T1}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.terms.distr}{\coqdocaxiom{distr}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul id}{\coqdocaxiom{mul\_id}}. \coqdoctac{apply} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma to convert term equivalence to equivalence between their
    addition and ground term \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}, and vice-versa. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.x equal y x plus y}{x\_equal\_y\_x\_plus\_y}{\coqdoclemma{x\_equal\_y\_x\_plus\_y}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{y} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{y} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.terms.term sum symmetric}{\coqdocaxiom{term\_sum\_symmetric}} \coqdockw{with} (\coqdocvar{y} := \coqdocvar{y}) (\coqdocvar{z} := \coqdocvar{y}). \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{mul\_x\_x\_plus\_T1} \coqdocvar{x\_equal\_y\_x\_plus\_y}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
These lemmas just serve to make certain rewrites regarding the core axioms
    less tedious to write. While one could certainly argue that they should be
    formulated as axioms and not lemmas due to their triviality, being pedantic
    is a good exercise. 

 This is a lemma for identity addition between term and ground term \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.sum id sym}{sum\_id\_sym}{\coqdoclemma{sum\_id\_sym}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{apply} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is a lemma for identity multiplication between term and ground term
    \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.mul id sym}{mul\_id\_sym}{\coqdoclemma{mul\_id\_sym}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{apply} \coqref{B Unification.terms.mul id}{\coqdocaxiom{mul\_id}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma for multiplication between term and ground term \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.mul T0 x sym}{mul\_T0\_x\_sym}{\coqdoclemma{mul\_T0\_x\_sym}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{apply} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.sum assoc opp}{sum\_assoc\_opp}{\coqdoclemma{sum\_assoc\_opp}} :\coqdoceol
\coqdocindent{0.50em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{(}}\coqdocvariable{y} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{z}\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{y}\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{z}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum assoc}{\coqdocaxiom{sum\_assoc}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.mul assoc opp}{mul\_assoc\_opp}{\coqdoclemma{mul\_assoc\_opp}} :\coqdoceol
\coqdocindent{0.50em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{y} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{z}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{y}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{z}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul assoc}{\coqdocaxiom{mul\_assoc}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.distr opp}{distr\_opp}{\coqdoclemma{distr\_opp}} :\coqdoceol
\coqdocindent{0.50em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, \coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{y}  \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}}  \coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{z} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}} \coqdocvariable{y} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{z}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.terms.distr}{\coqdocaxiom{distr}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Variable Sets}



 Now that the underlying behavior concerning Boolean algebra has been
    properly articulated to Coq, it is now time to begin formalizing the logic
    surrounding our meta reasoning of Boolean equations and systems. While there
    are certainly several approaches to begin this process, we thought it best
    to ease into things through formalizing the notion of a set of variables
    present in an equation. 

\subsection{Definitions}



 We now define a \textit{variable set} to be precisely a list of variables;
    additionally, we include several functions for including and excluding
    variables from these variable sets. Furthermore, since uniqueness is not a
    property guaranteed by Coq lists and it has the potential to be desirable,
    we define a function that consumes a variable set and removes duplicate
    entries from it. For convenience, we also provide several examples to
    demonstrate the functionalities of these new definitions. 

 Here is a definition of the new type to represent a list (set) of variables
    (natural numbers). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.var set}{var\_set}{\coqdocdefinition{var\_set}} := \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}.\coqdoceol
\coqdocnoindent
\coqdockw{Implicit} \coqdockw{Type} \coqdocvar{vars}: \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is a simple function to check to see if a variable is in a variable
    set. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.var set includes var}{var\_set\_includes\_var}{\coqdocdefinition{var\_set\_includes\_var}} (\coqdocvar{v} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{vars} : \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{vars} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{n} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdockw{if} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvariable{v} \coqdocvar{n}) \coqdockw{then} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{16.00em}
\coqdockw{else} \coqref{B Unification.terms.var set includes var}{\coqdocdefinition{var\_set\_includes\_var}} \coqdocvariable{v} \coqdocvar{n'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is a function to remove all instances of var \coqdocvariable{v} from a list of vars.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.var set remove var}{var\_set\_remove\_var}{\coqdocdefinition{var\_set\_remove\_var}} (\coqdocvar{v} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{vars} : \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}}) : \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{vars} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{n} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdockw{if} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvariable{v} \coqdocvar{n}) \coqdockw{then} (\coqref{B Unification.terms.var set remove var}{\coqdocdefinition{var\_set\_remove\_var}} \coqdocvariable{v} \coqdocvar{n'})\coqdoceol
\coqdocindent{16.00em}
\coqdockw{else} \coqdocvar{n} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.terms.var set remove var}{\coqdocdefinition{var\_set\_remove\_var}} \coqdocvariable{v} \coqdocvar{n'}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Next is a function to return a unique \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}} without duplicates. Found
    vars should be empty for correctness guarantee. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.var set create unique}{var\_set\_create\_unique}{\coqdocdefinition{var\_set\_create\_unique}} (\coqdocvar{vars} : \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}}): \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{vars} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{n} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdoceol
\coqdocindent{2.00em}
\coqdockw{if} (\coqref{B Unification.terms.var set includes var}{\coqdocdefinition{var\_set\_includes\_var}} \coqdocvar{n} \coqdocvar{n'}) \coqdockw{then} \coqref{B Unification.terms.var set create unique}{\coqdocdefinition{var\_set\_create\_unique}} \coqdocvar{n'}\coqdoceol
\coqdocindent{17.50em}
\coqdockw{else} \coqdocvar{n} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{B Unification.terms.var set create unique}{\coqdocdefinition{var\_set\_create\_unique}} \coqdocvar{n'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a function to check if a given var\_set is unique. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.var set is unique}{var\_set\_is\_unique}{\coqdocdefinition{var\_set\_is\_unique}} (\coqdocvar{vars} : \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}}): \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{vars} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{n} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{n'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{if} (\coqref{B Unification.terms.var set includes var}{\coqdocdefinition{var\_set\_includes\_var}} \coqdocvar{n} \coqdocvar{n'}) \coqdockw{then} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{17.50em}
\coqdockw{else} \coqref{B Unification.terms.var set is unique}{\coqdocdefinition{var\_set\_is\_unique}} \coqdocvar{n'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a function to get the variables of a term as a var\_set. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.term vars}{term\_vars}{\coqdocdefinition{term\_vars}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \ensuremath{\Rightarrow} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvar{x}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvar{y}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvar{x}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvar{y}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a function to generate a list of unique variables that make up a
    given term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.term unique vars}{term\_unique\_vars}{\coqdocdefinition{term\_unique\_vars}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.var set create unique}{\coqdocdefinition{var\_set\_create\_unique}} (\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvariable{t}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Helper Lemmas for variable sets and lists}



 Now that we have established the functionality for variable sets, let us
    prove some properties about them. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.vs includes true}{vs\_includes\_true}{\coqdoclemma{vs\_includes\_true}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{lvar} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.var set includes var}{\coqdocdefinition{var\_set\_includes\_var}} \coqdocvariable{x} \coqdocvariable{lvar} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{lvar}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{lvar}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}; \coqdoctac{intros}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdocvar{remember} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{x} \coqdocvar{a}) \coqdockw{as} \coqdocvar{H2}. \coqdoctac{destruct} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{left}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{HeqH2}. \coqdoctac{pose} \coqdocvar{proof} \coqexternalref{beq nat true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_true}} \coqdockw{as} \coqdocvar{H7}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{specialize} (\coqdocvar{H7} \coqdocvar{x} \coqdocvar{a} \coqdocvar{HeqH2}). \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H7}. \coqdoctac{apply} \coqdocvar{H7}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{specialize} (\coqdocvar{IHlvar} \coqdocvar{H}). \coqdoctac{simpl}. \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{IHlvar}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.vs includes false}{vs\_includes\_false}{\coqdoclemma{vs\_includes\_false}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{lvar} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.var set includes var}{\coqdocdefinition{var\_set\_includes\_var}} \coqdocvariable{x} \coqdocvariable{lvar} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{lvar}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{lvar}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}; \coqdoctac{intros}. \coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}}. \coqdoctac{intros}. \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdocvar{remember} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{x} \coqdocvar{a}) \coqdockw{as} \coqdocvar{H2}. \coqdoctac{destruct} \coqdocvar{H2}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{IHlvar} \coqdocvar{H}). \coqdoctac{firstorder}. \coqdoctac{intuition}. \coqdoctac{apply} \coqdocvar{IHlvar}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{HeqH2}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{pose} \coqdocvar{proof} \coqexternalref{beq nat false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_false}} \coqdockw{as} \coqdocvar{H7}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{specialize} (\coqdocvar{H7} \coqdocvar{x} \coqdocvar{a} \coqdocvar{H2}). \coqdoctac{rewrite} \coqdocvar{H0} \coqdoctac{in} \coqdocvar{H7}. \coqdoctac{destruct} \coqdocvar{H7}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.in dup and non dup}{in\_dup\_and\_non\_dup}{\coqdoclemma{in\_dup\_and\_non\_dup}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{x}: \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{lvar} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{lvar} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.terms.var set create unique}{\coqdocdefinition{var\_set\_create\_unique}} \coqdocvariable{lvar}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{lvar}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{intros}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{intros}. \coqdoctac{simpl}. \coqdocvar{remember} (\coqref{B Unification.terms.var set includes var}{\coqdocdefinition{var\_set\_includes\_var}} \coqdocvar{a} \coqdocvar{lvar}) \coqdockw{as} \coqdocvar{C}. \coqdoctac{destruct} \coqdocvar{C}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{HeqC}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.vs includes true}{\coqdoclemma{vs\_includes\_true}} \coqdockw{as} \coqdocvar{H7}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{specialize} (\coqdocvar{H7} \coqdocvar{a} \coqdocvar{lvar} \coqdocvar{HeqC}). \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H7}. \coqdoctac{specialize} (\coqdocvar{IHlvar} \coqdocvar{H7}). \coqdoctac{apply} \coqdocvar{IHlvar}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{specialize} (\coqdocvar{IHlvar} \coqdocvar{H}). \coqdoctac{apply} \coqdocvar{IHlvar}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{HeqC}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.vs includes false}{\coqdoclemma{vs\_includes\_false}} \coqdockw{as} \coqdocvar{H7}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{specialize} (\coqdocvar{H7} \coqdocvar{a} \coqdocvar{lvar} \coqdocvar{HeqC}). \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{simpl}. \coqdoctac{left}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{specialize} (\coqdocvar{IHlvar} \coqdocvar{H}). \coqdoctac{simpl}. \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{IHlvar}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{lvar}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{intros}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{intros}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdocvar{remember} (\coqref{B Unification.terms.var set includes var}{\coqdocdefinition{var\_set\_includes\_var}} \coqdocvar{a} \coqdocvar{lvar}) \coqdockw{as} \coqdocvar{C}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqdocvar{C}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{HeqC}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.vs includes true}{\coqdoclemma{vs\_includes\_true}} \coqdockw{as} \coqdocvar{H7}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{specialize} (\coqdocvar{H7} \coqdocvar{a} \coqdocvar{lvar} \coqdocvar{HeqC}). \coqdoctac{specialize} (\coqdocvar{IHlvar} \coqdocvar{H}). \coqdoctac{simpl}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{right}. \coqdoctac{apply} \coqdocvar{IHlvar}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{HeqC}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.vs includes false}{\coqdoclemma{vs\_includes\_false}} \coqdockw{as} \coqdocvar{H7}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{specialize} (\coqdocvar{H7} \coqdocvar{a} \coqdocvar{lvar} \coqdocvar{HeqC}). \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{simpl}. \coqdoctac{left}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{specialize} (\coqdocvar{IHlvar} \coqdocvar{H}). \coqdoctac{simpl}. \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{IHlvar}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Examples}



 Below are some examples of the behaviors of variable sets. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{B Unification.terms.var set create unique ex1}{var\_set\_create\_unique\_ex1}{\coqdocdefinition{var\_set\_create\_unique\_ex1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.var set create unique}{\coqdocdefinition{var\_set\_create\_unique}} \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}0\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}5\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}2\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}1\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}1\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}2\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}2\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}9\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}5\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}3\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}0\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}1\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}2\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}9\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}5\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}3\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{B Unification.terms.var set is unique ex1}{var\_set\_is\_unique\_ex1}{\coqdocdefinition{var\_set\_is\_unique\_ex1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.var set is unique}{\coqdocdefinition{var\_set\_is\_unique}} \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}0\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}2\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}2\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}2\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here are examples to demonstrate the correctness of the function \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}}
    on specific cases. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{B Unification.terms.term vars ex1}{term\_vars\_ex1}{\coqdocdefinition{term\_vars\_ex1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 0 \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 0 \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 1) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}0\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}0\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}}1\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{B Unification.terms.term vars ex2}{term\_vars\_ex2}{\coqdocdefinition{term\_vars\_ex2}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} 0 (\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 0 \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 0 \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 1)).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{left}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Ground Terms}



 Seeing as we just outlined the definition of a variable set, it seems fair
    to now formalize the definition of a ground term, or in other words, a term
    that has no variables and whose variable set is the empty set. 

\subsection{Definitions}



 A \textit{ground term} is a recursively defined proposition that is only true if
    and only if no variable appears in it; otherwise it will be a false
    proposition and no longer a ground term. 

 In this subsection we declare definitions related to ground terms, inluding
    functions and lemmas. 

 This is a function to check if a given term is a ground term (i.e. has no
    vars). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.ground term}{ground\_term}{\coqdocdefinition{ground\_term}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} \coqdocvar{x} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} \coqdocvar{y}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} \coqdocvar{x} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} \coqdocvar{y}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{True}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{True}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Lemmas}



 Our first real lemma (shown below), articulates an important property of
    ground terms: all ground terms are equvialent to either 0 or 1. This curious
    property is a direct result of the fact that these terms possess no
    variables and additioanlly because of the axioms of Boolean algebra. 

 This is a lemma (trivial, intuitively true) that proves that if the function
    \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} returns true then it is either \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} or \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.ground term equiv T0 T1}{ground\_term\_equiv\_T0\_T1}{\coqdoclemma{ground\_term\_equiv\_T0\_T1}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} \coqdocvariable{x} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{x} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{left}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{right}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{IHx1}; \coqdoctac{destruct} \coqdocvar{IHx2}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{left}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{apply} \coqdocvar{H3}. \coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{rewrite} \coqdocvar{H3}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{right}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{rewrite} \coqdocvar{H3}. \coqdoctac{right}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}. \coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{rewrite} \coqdocvar{H3}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{left}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{IHx1}; \coqdoctac{destruct} \coqdocvar{IHx2}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{left}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}. \coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{left}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdoctac{rewrite} \coqdocvar{H3}. \coqdoctac{left}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{rewrite} \coqdocvar{H3}. \coqdoctac{right}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul id}{\coqdocaxiom{mul\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This lemma, while intuitively obvious by definition, nonetheless provides a
    formal bridge between the world of ground terms and the world of variable
    sets. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.ground term has empty var set}{ground\_term\_has\_empty\_var\_set}{\coqdoclemma{ground\_term\_has\_empty\_var\_set}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} \coqdocvariable{x} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{firstorder}. \coqdoctac{unfold} \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}}. \coqdoctac{unfold} \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{rewrite} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{firstorder}. \coqdoctac{unfold} \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}}. \coqdoctac{unfold} \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{rewrite} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Examples}



 Here are some examples to show that our ground term definition is working
    appropriately. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{B Unification.terms.ex gt1}{ex\_gt1}{\coqdocdefinition{ex\_gt1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} (\coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{B Unification.terms.ex gt2}{ex\_gt2}{\coqdocdefinition{ex\_gt2}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 0 \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{intros}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Substitutions}



 It is at this point in our Coq development that we begin to officially
    define the principal action around which the entirety of our efforts are
    centered: the act of substituting variables with other terms. While
    substitutions alone are not of great interest, their emergent properties as
    in the case of whether or not a given substitution unifies an equation are
    of substantial importance to our later research. 

\subsection{Definitions}



 In this subsection we make the fundamental definitions of substitutions,
    basic functions for them, accompanying lemmas and some propsitions. 

 Here we define a \textit{substitution} to be a list of ordered pairs where each
    pair represents a variable being mapped to a term. For sake of clarity these
    ordered pairs shall be referred to as \textit{replacements} from now on and as a
    result, substitutions should really be considered to be lists of
    replacements. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.replacement}{replacement}{\coqdocdefinition{replacement}} := \coqexternalref{prod}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{prod}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}} \coqref{B Unification.terms.term}{\coqdocinductive{term}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We define a new type \coqdocvar{susbt} to represent a substitution as a list of
    replacements. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.subst}{subst}{\coqdocdefinition{subst}} := \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.replacement}{\coqdocdefinition{replacement}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Implicit} \coqdockw{Type} \coqdocvar{s} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Our first function, \coqref{B Unification.terms.find replacement}{\coqdocdefinition{find\_replacement}}, is an auxilliary to \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}}.
    This function will search through a substitution for a specific variable,
    and if found, returns the variable's associated term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.find replacement}{find\_replacement}{\coqdocdefinition{find\_replacement}} (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{s} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqref{B Unification.terms.term}{\coqdocinductive{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{s} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{r} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{r'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{if} \coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} (\coqexternalref{fst}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{fst}} \coqdocvar{r}) \coqdocvariable{x} \coqdockw{then} \coqexternalref{snd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{snd}} \coqdocvar{r}\coqdoceol
\coqdocindent{13.50em}
\coqdockw{else} \coqref{B Unification.terms.find replacement}{\coqdocdefinition{find\_replacement}} \coqdocvariable{x} \coqdocvar{r'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} function will take a term and a substitution and will
    produce a new term reflecting the changes made to the original one. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.apply subst}{apply\_subst}{\coqdocdefinition{apply\_subst}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{s} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqref{B Unification.terms.term}{\coqdocinductive{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{B Unification.terms.find replacement}{\coqdocdefinition{find\_replacement}} \coqdocvar{x} \coqdocvariable{s}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{x} \coqdocvariable{s}) (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{y} \coqdocvariable{s})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{x} \coqdocvariable{s}) (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{y} \coqdocvariable{s})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For reasons of completeness, it is useful to be able to generate \textit{identity
    substitutions}; namely, substitutions that map the variables of a term to
    themselves. 

 This is a function when given a list of variables builds a list of
    identity substitutions - one for each variable. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.build id subst}{build\_id\_subst}{\coqdocdefinition{build\_id\_subst}} (\coqdocvar{lvar} : \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}}) : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{lvar} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{v} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{v'} \ensuremath{\Rightarrow} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{v} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{v}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{))}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{B Unification.terms.build id subst}{\coqdocdefinition{build\_id\_subst}} \coqdocvar{v'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Since we now have the ability to generate identity substitutions, we should
    now formalize a general proposition for testing whether or not a given
    substitution is an identity substitution of a given term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.subst equiv}{subst\_equiv}{\coqdocdefinition{subst\_equiv}} (\coqdocvar{s1} \coqdocvar{s2}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{s1} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{s2}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.subst is id subst}{subst\_is\_id\_subst}{\coqdocdefinition{subst\_is\_id\_subst}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{s} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{s} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Given we now have definitions for substitutions, we should now introduce the
    idea of a substitution composing another one. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.subst compose}{subst\_compose}{\coqdocdefinition{subst\_compose}} (\coqdocvar{s} \coqdocvar{s'} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{s'} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqdocvariable{s}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{t}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{s'{}'} \ensuremath{\Rightarrow} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t} \coqdocvariable{s}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} \coqdocvariable{s} \coqdocvar{s'{}'}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here we define the domain of a substituion, namely the list of variables for
    which the substitution has a mapping (replacement). Essentially this acts as
    a list of all the first parts of the replacement. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.subst domain}{subst\_domain}{\coqdocdefinition{subst\_domain}} (\coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{r} \ensuremath{\Rightarrow} (\coqexternalref{fst}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{fst}} \coqdocvariable{r})) \coqdocvariable{sig}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We define the concept of a sub list. If an element is a member of a list,
    it is then a member of the other list as well. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.sub dmn list}{sub\_dmn\_list}{\coqdocdefinition{sub\_dmn\_list}} (\coqdocvar{l1} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{l2} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{0.50em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}), \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l2}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Helper Lemmas for the \texorpdfstring{\protect\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}}}{apply\_subst} function}



 Having now outlined the functionality of a subsitution, let us now begin to
    analyze some implications of its form and composition by proving some
    lemmas. 

 Given that we have a definition for identity substitutions, we should prove
    that identity substitutions do not modify a term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.id subst}{id\_subst}{\coqdoclemma{id\_subst}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{l} : \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} (\coqref{B Unification.terms.build id subst}{\coqdocdefinition{build\_id\_subst}} \coqdocvariable{l}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{induction} \coqdocvar{l}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{a} \coqdocvar{v}) \coqdocvar{eqn}: \coqdocvar{e}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{beq nat true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_true}} \coqdoctac{in} \coqdocvar{e}. \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IHl}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHt1}. \coqdoctac{rewrite} \coqdocvar{IHt2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHt1}. \coqdoctac{rewrite} \coqdocvar{IHt2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
These are helper lemmes for the \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} properties. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.sum comm compat}{sum\_comm\_compat}{\coqdoclemma{sum\_comm\_compat}} \coqdocvar{t1} \coqdocvar{t2}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t2}) \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{t2} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t1}) \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{sum\_comm\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.sum assoc compat}{sum\_assoc\_compat}{\coqdoclemma{sum\_assoc\_compat}} \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{t3}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{(}}\coqdocvariable{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t2}\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t3}) \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{(}}\coqdocvariable{t2} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t3}\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{)}}) \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{sum\_assoc\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.sum id compat}{sum\_id\_compat}{\coqdoclemma{sum\_id\_compat}} \coqdocvar{t}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t}) \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{sum\_id\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.sum x x compat}{sum\_x\_x\_compat}{\coqdoclemma{sum\_x\_x\_compat}} \coqdocvar{t}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{t} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t}) \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{sum\_x\_x\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.mul comm compat}{mul\_comm\_compat}{\coqdoclemma{mul\_comm\_compat}} \coqdocvar{t1} \coqdocvar{t2}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{t1} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{t2}) \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{t2} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{t1}) \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{mul\_comm\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.mul assoc compat}{mul\_assoc\_compat}{\coqdoclemma{mul\_assoc\_compat}} \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{t3}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{t1} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{t2}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{t3}) \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{t1} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{t2} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{t3}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}}) \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{mul\_assoc\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.mul x x compat}{mul\_x\_x\_compat}{\coqdoclemma{mul\_x\_x\_compat}} \coqdocvar{t}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{t} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{t}) \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{mul\_x\_x\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.mul T0 x compat}{mul\_T0\_x\_compat}{\coqdoclemma{mul\_T0\_x\_compat}} \coqdocvar{t}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{t}) \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{mul\_T0\_x\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.mul id compat}{mul\_id\_compat}{\coqdoclemma{mul\_id\_compat}} \coqdocvar{t}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{t}) \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{mul\_id\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.distr compat}{distr\_compat}{\coqdoclemma{distr\_compat}} \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{t3}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{t1} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{t2} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t3}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}}) \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{(}}\coqdocvariable{t1} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{t2}\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{(}}\coqdocvariable{t1} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{t3}\coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{)}}) \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{distr\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.refl comm compat}{refl\_comm\_compat}{\coqdoclemma{refl\_comm\_compat}} \coqdocvar{t1} \coqdocvar{t2}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t1} \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t2} \coqdocvariable{sigma} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t2} \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t1} \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{refl\_comm\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.trans compat}{trans\_compat}{\coqdoclemma{trans\_compat}} \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{t3} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t1} \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t2} \coqdocvariable{sigma} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t2} \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t3} \coqdocvariable{sigma} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t1} \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t3} \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{eauto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{trans\_compat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.trans compat2}{trans\_compat2}{\coqdoclemma{trans\_compat2}} \coqdocvar{c1} \coqdocvar{c2} \coqdocvar{c3} : \coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{c1} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{c2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{c2} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{c3} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{c1} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{c3}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{eauto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is an axiom that states that if two terms are equivalent then applying
    any substitution on them will also produce equivalent terms. The reason we
    axiomatized this and we did not prove it as a lemma is because the set of
    our fundamental axioms is not an inductive relation, so it would be
    impossible to prove the lemma below with our fundamental axioms in the
    currrent format. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{B Unification.terms.apply subst compat}{apply\_subst\_compat}{\coqdocaxiom{apply\_subst\_compat}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} \coqdocvar{t'} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}), \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{sigma} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t'} \coqdocvariable{sigma}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Add} \coqdocvar{Parametric} \coqdocvar{Morphism} : \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{signature} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{==>}} \coqexternalref{eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{eq}} \coqexternalref{ProperNotations.::signature scope:x '==>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Classes.Morphisms}{\coqdocnotation{==>}} \coqref{B Unification.terms.eqv}{\coqdocaxiom{eqv}} \coqdockw{as} \coqdocvar{apply\_subst\_mor}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} \coqref{B Unification.terms.apply subst compat}{\coqdocaxiom{apply\_subst\_compat}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a simple lemma that states that an empty substitution cannot modify
    a term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.subst empty no change}{subst\_empty\_no\_change}{\coqdoclemma{subst\_empty\_no\_change}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}), \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{(}}\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHt1}. \coqdoctac{rewrite} \coqdocvar{IHt2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHt1}. \coqdoctac{rewrite} \coqdocvar{IHt2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
An intuitive thing to prove for ground terms is that they cannot be modified
    by applying substitutions to them. This will later prove to be very relevant
    when we begin to talk about unification. 

 This is a helpful lemma for showing substitutions do not affect ground
    terms. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.ground term cannot subst}{ground\_term\_cannot\_subst}{\coqdoclemma{ground\_term\_cannot\_subst}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} \coqdocvariable{x} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{x} \coqdocvariable{s} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{s}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.terms.ground term equiv T0 T1}{\coqdoclemma{ground\_term\_equiv\_T0\_T1}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.terms.ground term equiv T0 T1}{\coqdoclemma{ground\_term\_equiv\_T0\_T1}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A fundamental property of substitutions is their distributivity across the
    summation and multiplication of terms. Again the importance of these proofs
    will not become apparent until we talk about unification. 

 This is a useful lemma for showing the distributivity of substitutions
    across term summation. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.subst sum distribution}{subst\_sum\_distribution}{\coqdoclemma{subst\_sum\_distribution}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{x} \coqdocvar{y},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{x} \coqdocvariable{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{y} \coqdocvariable{s} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{y}) \coqdocvariable{s}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro}. \coqdoctac{induction} \coqdocvar{s}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{intros}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma to prove the distributivity of the \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} function
    across term multiplication. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.subst mul distribution}{subst\_mul\_distribution}{\coqdoclemma{subst\_mul\_distribution}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{x} \coqdocvar{y},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{x} \coqdocvariable{s} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{y} \coqdocvariable{s} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{y}) \coqdocvariable{s}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro}. \coqdoctac{induction} \coqdocvar{s}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is a lemma to prove the opposite of summation distributivity of the
    \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} function across term summation. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.subst sum distr opp}{subst\_sum\_distr\_opp}{\coqdoclemma{subst\_sum\_distr\_opp}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{x} \coqdocvar{y},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{y}) \coqdocvariable{s} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{x} \coqdocvariable{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{y} \coqdocvariable{s}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.terms.refl comm}{\coqdocaxiom{refl\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.terms.subst sum distribution}{\coqdoclemma{subst\_sum\_distribution}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma to prove the opposite of multiplication distributivity of
    the \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} function across term summation. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.subst mul distr opp}{subst\_mul\_distr\_opp}{\coqdoclemma{subst\_mul\_distr\_opp}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{x} \coqdocvar{y},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvariable{x} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{y}) \coqdocvariable{s} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{x} \coqdocvariable{s} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{y} \coqdocvariable{s}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.terms.refl comm}{\coqdocaxiom{refl\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.terms.subst mul distribution}{\coqdoclemma{subst\_mul\_distribution}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is an intutitive lemmas to apply a single replacement substitution on a
    VAR term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.var subst}{var\_subst}{\coqdoclemma{var\_subst}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{v} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{ts} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{v}) \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{v} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{ts}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{ts}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{v} \coqdocvar{v}) \coqdocvar{eqn}: \coqdocvar{e}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{beq nat true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_true}} \coqdoctac{in} \coqdocvar{e}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{beq nat false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_false}} \coqdoctac{in} \coqdocvar{e}. \coqdoctac{firstorder}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Examples}



 Here are some examples showcasing the nature of applying substitutions to
    terms. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{B Unification.terms.subst ex1}{subst\_ex1}{\coqdocdefinition{subst\_ex1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}) \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{B Unification.terms.subst ex2}{subst\_ex2}{\coqdocdefinition{subst\_ex2}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 0 \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 1) \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}0\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{apply} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Auxillary Definitions for Substitutions and Terms}



 In this section we define more helper functions and lemmas related to
    substitutions and ground terms. Specifically we are defining a ground term,
    a ground substitution, a ``01'' term, a ``01'' substitution, and a substitution
    composition. A \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} is a term with no variables in it. 
    The terms that are used more in the future proofs are the ``01''
    term and ``01'' substitution. A ``01'' term is a term that is either exaclty
    equal to \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} or \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}. A ``01'' substitution is a substitution in which each
    variable (or the first part of each replacement) is mapped to a ``01'' term. A
    ``01'' term is not necessarily a ground term (but it might be) and a ``01''
    substitution is not necessarily a ground substitution (but it might be). In
    the proof file, we are mostly using the ``01'' term and substitution
    terminology. 


 We define a proposition for a \coqref{B Unification.terms.ground subst}{\coqdocdefinition{ground\_subst}}. A substitution is ground when
    in all of its replacements, the second part is a \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.ground subst}{ground\_subst}{\coqdocdefinition{ground\_subst}} (\coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{sig} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{True}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{True}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{r} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{r'} \ensuremath{\Rightarrow} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} (\coqexternalref{snd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{snd}} \coqdocvar{r}) \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{B Unification.terms.ground subst}{\coqdocdefinition{ground\_subst}} \coqdocvar{r'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a function to determine whether a term is a ground term, by
    returning a boolean. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.is ground term}{is\_ground\_term}{\coqdocdefinition{is\_ground\_term}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} \coqdocvar{a} \coqdocvar{b} \ensuremath{\Rightarrow} \coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.terms.is ground term}{\coqdocdefinition{is\_ground\_term}} \coqdocvar{a}\coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\&\&}} \coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.terms.is ground term}{\coqdocdefinition{is\_ground\_term}} \coqdocvar{b}\coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} \coqdocvar{a} \coqdocvar{b} \ensuremath{\Rightarrow} \coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.terms.is ground term}{\coqdocdefinition{is\_ground\_term}} \coqdocvar{a}\coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\&\&}} \coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.terms.is ground term}{\coqdocdefinition{is\_ground\_term}} \coqdocvar{b}\coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a function to determine whether a subsitution is a ground
    substitution, by returning a boolean. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.is ground subst}{is\_ground\_subst}{\coqdocdefinition{is\_ground\_subst}} (\coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{existsb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{existsb}} \coqref{B Unification.terms.is ground term}{\coqdocdefinition{is\_ground\_term}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqexternalref{snd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{snd}} \coqdocvariable{sig}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a function to determine whether a term is a \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} or \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} term by
    returning a boolean. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.is 01 term}{is\_01\_term}{\coqdocdefinition{is\_01\_term}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a function to determine whether a substitution is a ``01''
    substitution by returning a boolean, meaning that each second part of every
    replacement is either a \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} or a \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.is 01 subst}{is\_01\_subst}{\coqdocdefinition{is\_01\_subst}} (\coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{existsb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{existsb}} \coqref{B Unification.terms.is 01 term}{\coqdocdefinition{is\_01\_term}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqexternalref{snd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{snd}} \coqdocvariable{sig}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a function to determine whether a term is a \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} or \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} term by
    returning a proposition. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms. 01 term}{\_01\_term}{\coqdocdefinition{\_01\_term}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqexternalref{True}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{True}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \ensuremath{\Rightarrow} \coqexternalref{True}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{True}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a function to determine whether a substitution is a ``01''
    substitution by returning a proposition, meaning that each second part of
    every replacement is either a \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} or a \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms. 01 subst}{\_01\_subst}{\coqdocdefinition{\_01\_subst}} (\coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{sig} \coqdockw{with} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{True}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{True}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{r} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{r'} \ensuremath{\Rightarrow} \coqref{B Unification.terms. 01 term}{\coqdocdefinition{\_01\_term}} (\coqexternalref{snd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{snd}} \coqdocvar{r}) \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{B Unification.terms. 01 subst}{\coqdocdefinition{\_01\_subst}} \coqdocvar{r'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Unification}



 Now that we have established the concept of term substitutions in Coq, it is
    time for us to formally define the concept of Boolean unification.
    \textit{Unification}, in its most literal sense, refers to the act of applying a
    substitution to terms in order to make them equivalent to each other. In
    other words, to say that two terms are \textit{unifiable} is to really say that
    there exists a substitution such that the two terms are equal. Interestingly
    enough, we can abstract this concept further to simply saying that a single
    term is unifiable if there exists a substitution such that the term will be
    equivalent to 0. By doing this abstraction, we can prove that equation
    solving and unification are essentially the same fundamental problem. 

 Below is the initial definition for unification, namely that two terms can
    be unified to be equivalent to one another. By starting here we will show
    each step towards abstracting unification to refer to a single term. 

  Proposition that a given substitution unifies (namely, makes equivalent),
    two given terms \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.unifies}{unifies}{\coqdocdefinition{unifies}} (\coqdocvar{a} \coqdocvar{b} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{s} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{a} \coqdocvariable{s} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{b} \coqdocvariable{s}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is a simple example demonstrating the concept of testing whether two
    terms are unified by a substitution. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{B Unification.terms.ex unif1}{ex\_unif1}{\coqdocdefinition{ex\_unif1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifies}{\coqdocdefinition{unifies}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 0) (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 1) \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}0\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{;}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}1\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.unifies}{\coqdocdefinition{unifies}}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now we are going to show that moving both terms to one side of the
    equivalence relation through addition does not change the concept of
    unification. 

 This is a proposition that a given substitution makes equivalent the sum of
    two terms when the substitution is applied to each of them, and ground term
    \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.unifies T0}{unifies\_T0}{\coqdocdefinition{unifies\_T0}} (\coqdocvar{a} \coqdocvar{b} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{s} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{a} \coqdocvariable{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{b} \coqdocvariable{s} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma that proves that finding a unifier for \coqdocvariable{x} = \coqdocvariable{y} is the same
    as finding a unifier for \coqdocvariable{x} + \coqdocvariable{y} = 0. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.unifies T0 equiv}{unifies\_T0\_equiv}{\coqdoclemma{unifies\_T0\_equiv}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifies}{\coqdocdefinition{unifies}} \coqdocvariable{x} \coqdocvariable{y} \coqdocvariable{s} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{B Unification.terms.unifies T0}{\coqdocdefinition{unifies\_T0}} \coqdocvariable{x} \coqdocvariable{y} \coqdocvariable{s}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.terms.unifies T0}{\coqdocdefinition{unifies\_T0}}. \coqdoctac{unfold} \coqref{B Unification.terms.unifies}{\coqdocdefinition{unifies}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.terms.unifies T0}{\coqdocdefinition{unifies\_T0}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.terms.unifies}{\coqdocdefinition{unifies}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.term sum symmetric}{\coqdocaxiom{term\_sum\_symmetric}} \coqdockw{with} (\coqdocvar{x} := \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{x} \coqdocvar{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{y} \coqdocvar{s}) \coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{z} := \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{y} \coqdocvar{s}) \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}} \coqdockw{with} (\coqdocvar{y} := \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{y} \coqdocvar{s}) \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.terms.sum assoc}{\coqdocaxiom{sum\_assoc}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now we can define what it means for a substitution to be a unifier for a
    given term. 

 Here is a proposition that a given substitution unifies a given term, namely
    it makes it equivalent with \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.unifier}{unifier}{\coqdocdefinition{unifier}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{s} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{s} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{B Unification.terms.unifier ex1}{unifier\_ex1}{\coqdocdefinition{unifier\_ex1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} 0) \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}0\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
To ensure our efforts were not in vain, let us now prove that this last
    abstraction of the unification problem is still equivalent to the original.
    

 This is a lemma that proves that the unifier proposition can distributes
    over addition of terms. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.unifier distribution}{unifier\_distribution}{\coqdoclemma{unifier\_distribution}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifies T0}{\coqdocdefinition{unifies\_T0}} \coqdocvariable{x} \coqdocvariable{y} \coqdocvariable{s} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} (\coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{y}) \coqdocvariable{s}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.terms.unifies T0}{\coqdocdefinition{unifies\_T0}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{symmetry}. \coqdoctac{apply} \coqref{B Unification.terms.subst sum distribution}{\coqdoclemma{subst\_sum\_distribution}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.terms.unifies T0}{\coqdocdefinition{unifies\_T0}}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.terms.subst sum distribution}{\coqdoclemma{subst\_sum\_distribution}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Lastly let us define a term to be unifiable if there exists a substitution
    that unifies it. 

 This is a proposition that states when a term is unifiable. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.unifiable}{unifiable}{\coqdocdefinition{unifiable}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{s}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{B Unification.terms.unifiable ex1}{unifiable\_ex1}{\coqdocdefinition{unifiable\_ex1}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} (\coqdocvariable{x} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{\ensuremath{\exists}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}. \coqdoctac{unfold} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{\ensuremath{\exists}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Most General Unifier}



 In this subsection we define propositions, lemmas and examples related to
    the most general unifier. 

 While the property of a term being unifiable is certainly important, it
    should come as no surprise that not all unifiers are created equal; in fact,
    certain unifiers possess the desirable property of being \textit{more general} than
    others. For this reason, let us now formally define the concept of a \textit{most
    general unifier} (mgu): a unifier such that with respect to a given term,
    all other unifiers are instances of it, or in other words, less general than
    it. 

 The first step towards establishing the concept of a mgu requires us to
    formalize the notion of a unifier being more general than another. To
    accomplish this goal, let us formulate the definition of a substitution
    composing another one; or in other words, to say that a substitution is more
    general than another one. 

 This is a proposition of sequential substition application. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.substitution factor through}{substitution\_factor\_through}{\coqdocdefinition{substitution\_factor\_through}} (\coqdocvar{s} \coqdocvar{s'} \coqdockw{delta} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}), \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) \coqdocvariable{s}) \coqdocvariable{delta} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}}\coqdoceol
\coqdocindent{10.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) \coqdocvariable{s'} .\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is the definition of a more general substition. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.more general substitution}{more\_general\_substitution}{\coqdocdefinition{more\_general\_substitution}} (\coqdocvar{s} \coqdocvar{s'}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdockw{delta}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.terms.substitution factor through}{\coqdocdefinition{substitution\_factor\_through}} \coqdocvariable{s} \coqdocvariable{s'} \coqdocvariable{delta} .\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now that we have articulated the concept of composing substitutions, let us
    now formulate the definition for a most general unifier. 

 This is the definition of a Most General Unifier (mgu): A Most General
    Unifier (MGU) takes in a term and a substitution and tells whether or not
    said substitution is an mgu for the given term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.most general unifier}{most\_general\_unifier}{\coqdocdefinition{most\_general\_unifier}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{s} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{s} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{s'} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{s'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.more general substitution}{\coqdocdefinition{more\_general\_substitution}} \coqdocvariable{s} \coqdocvariable{s'}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
While this definition of a most general unifier is certainly valid, we can
    also characterize a unifier by other similar properties. For this reason,
    let us now define an alternative definition called a \textit{reproductive unifier},
    and then prove it to be equivalent to our definition of a most general
    unifier. This will make our proofs easier to formulate down the road as the
    task of proving a unifier to be reproductive is substantially easier than
    proving it to be most general directly. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.reproductive unifier}{reproductive\_unifier}{\coqdocdefinition{reproductive\_unifier}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{sig} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{tau} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{tau} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) \coqdocvariable{sig} ) \coqdocvariable{tau} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) \coqdocvariable{tau}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma to show that a reproductive unifier is a most general
    unifier. Since the ultimate goal is to prove that a specific algorithm
    produces an mgu then if we could prove it is a reproductive unifier then we
    could use this lemma to arrive at the desired conclusion. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.reproductive is mgu}{reproductive\_is\_mgu}{\coqdoclemma{reproductive\_is\_mgu}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{u} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.reproductive unifier}{\coqdocdefinition{reproductive\_unifier}} \coqdocvariable{t} \coqdocvariable{u} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}} \coqdocvariable{t} \coqdocvariable{u}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}}. \coqdoctac{unfold} \coqref{B Unification.terms.reproductive unifier}{\coqdocdefinition{reproductive\_unifier}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.more general substitution}{\coqdocdefinition{more\_general\_substitution}} . \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{s'}). \coqdoctac{\ensuremath{\exists}} \coqdocvar{s'}. \coqdoctac{unfold} \coqref{B Unification.terms.substitution factor through}{\coqdocdefinition{substitution\_factor\_through}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros}. \coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{x}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{H1}). \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma to show that if two terms are equivalent then for any
    subsitution that is an mgu of one of the terms, then it is an mgu of the
    other term as well. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.most general unifier compat}{most\_general\_unifier\_compat}{\coqdoclemma{most\_general\_unifier\_compat}} : \coqdockw{\ensuremath{\forall}}  (\coqdocvar{t} \coqdocvar{t'} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{sigma}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}} \coqdocvariable{t} \coqdocvariable{sigma} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}} \coqdocvariable{t'} \coqdocvariable{sigma}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} *. \coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{destruct} \coqdocvar{H0}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{s'}). \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{H1}). \coqdoctac{apply} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}}. \coqdoctac{intros}. \coqdoctac{destruct} \coqdocvar{H0} . \coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{intros}. \coqdoctac{specialize} (\coqdocvar{H1} \coqdocvar{s'}). \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H2}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{specialize} (\coqdocvar{H1} \coqdocvar{H2}). \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Auxilliary Computational Operations and Simplifications}



 These functions below will come in handy later during the Lowenheim formula
    proof. They mainly lay the groundwork for providing the computational nuts
    and bolts for Lowenheim's algorithm for finding most general unifiers and
    initial ground unifiers. \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
This is a function to check if two terms are exaclty identical. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.identical}{identical}{\coqdocdefinition{identical}} (\coqdocvar{a} \coqdocvar{b}: \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{a} , \coqdocvariable{b} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}, \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}, \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} , \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} , \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{x} , \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdockw{if} \coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{x} \coqdocvar{y} \coqdockw{then} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqdockw{else} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{x}, \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} \coqdocvar{x} \coqdocvar{y}, \coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} \coqdocvar{x1} \coqdocvar{y1} \ensuremath{\Rightarrow} \coqref{B Unification.terms.identical}{\coqdocdefinition{identical}} \coqdocvar{x} \coqdocvar{x1} \coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\&\&}} \coqref{B Unification.terms.identical}{\coqdocdefinition{identical}} \coqdocvar{y} \coqdocvar{y1}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} \coqdocvar{x} \coqdocvar{y}, \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} \coqdocvar{x} \coqdocvar{y}, \coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} \coqdocvar{x1} \coqdocvar{y1} \ensuremath{\Rightarrow} \coqref{B Unification.terms.identical}{\coqdocdefinition{identical}} \coqdocvar{x} \coqdocvar{x1} \coqexternalref{::bool scope:x 'x26x26' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\&\&}} \coqref{B Unification.terms.identical}{\coqdocdefinition{identical}} \coqdocvar{y} \coqdocvar{y1}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} \coqdocvar{x} \coqdocvar{y}, \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is basic addition for terms. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.plus one step}{plus\_one\_step}{\coqdocdefinition{plus\_one\_step}} (\coqdocvar{a} \coqdocvar{b} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqref{B Unification.terms.term}{\coqdocinductive{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{a}, \coqdocvariable{b} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}, \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}, \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}, \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} , \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{\_} , \coqdocvar{\_} \ensuremath{\Rightarrow} \coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} \coqdocvariable{a} \coqdocvariable{b}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is basic multiplication for terms. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.terms.mult one step}{mult\_one\_step}{\coqdocdefinition{mult\_one\_step}} (\coqdocvar{a} \coqdocvar{b} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqref{B Unification.terms.term}{\coqdocinductive{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{a}, \coqdocvariable{b} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}, \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}, \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}, \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} , \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{\_} , \coqdocvar{\_} \ensuremath{\Rightarrow} \coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} \coqdocvariable{a} \coqdocvariable{b}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a function to simplify a term in very apparent and basic ways. They
    are only simplified if they are ground terms. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.terms.simplify}{simplify}{\coqdocdefinition{simplify}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqref{B Unification.terms.term}{\coqdocinductive{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} \ensuremath{\Rightarrow} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{x} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.PRODUCT}{\coqdocconstructor{PRODUCT}} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqref{B Unification.terms.mult one step}{\coqdocdefinition{mult\_one\_step}} (\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvar{x}) (\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvar{y})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{B Unification.terms.SUM}{\coqdocconstructor{SUM}} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqref{B Unification.terms.plus one step}{\coqdocdefinition{plus\_one\_step}} (\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvar{x}) (\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvar{y})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Some lemmas follow to prove intuitive facts for the basic multiplication and
    addition of terms, leading up to proving the \coqref{B Unification.terms.simplify eqv}{\coqdoclemma{simplify\_eqv}} lemma. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.pos left sum compat}{pos\_left\_sum\_compat}{\coqdoclemma{pos\_left\_sum\_compat}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} \coqdocvar{t1} \coqdocvar{t2} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.plus one step}{\coqdocdefinition{plus\_one\_step}} \coqdocvariable{t1} \coqdocvariable{t2} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.plus one step}{\coqdocdefinition{plus\_one\_step}} \coqdocvariable{t} \coqdocvariable{t2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{t1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.terms.T1 not equiv T0}{\coqdocaxiom{T1\_not\_equiv\_T0}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{0.50em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.pos right sum compat}{pos\_right\_sum\_compat}{\coqdoclemma{pos\_right\_sum\_compat}} : \coqdockw{\ensuremath{\forall}}  (\coqdocvar{t} \coqdocvar{t1} \coqdocvar{t2} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.plus one step}{\coqdocdefinition{plus\_one\_step}} \coqdocvariable{t1} \coqdocvariable{t2} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.plus one step}{\coqdocdefinition{plus\_one\_step}} \coqdocvariable{t1} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{t1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.pos left mul compat}{pos\_left\_mul\_compat}{\coqdoclemma{pos\_left\_mul\_compat}} : \coqdockw{\ensuremath{\forall}}  (\coqdocvar{t} \coqdocvar{t1} \coqdocvar{t2} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.mult one step}{\coqdocdefinition{mult\_one\_step}} \coqdocvariable{t1} \coqdocvariable{t2} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.mult one step}{\coqdocdefinition{mult\_one\_step}} \coqdocvariable{t} \coqdocvariable{t2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{t1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.terms.T1 not equiv T0}{\coqdocaxiom{T1\_not\_equiv\_T0}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.pos right mul compat}{pos\_right\_mul\_compat}{\coqdoclemma{pos\_right\_mul\_compat}} : \coqdockw{\ensuremath{\forall}}  (\coqdocvar{t} \coqdocvar{t1} \coqdocvar{t2} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.mult one step}{\coqdocdefinition{mult\_one\_step}} \coqdocvariable{t1} \coqdocvariable{t2} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.mult one step}{\coqdocdefinition{mult\_one\_step}} \coqdocvariable{t1} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{t1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Being able to simplify a term can be a useful tool. Being able to use the
    simplified version of the term as the equivalent version of the original
    term can also be useful since many of our functions simplify the term first.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.terms.simplify eqv}{simplify\_eqv}{\coqdoclemma{simplify\_eqv}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.pos left sum compat}{\coqdoclemma{pos\_left\_sum\_compat}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H} \coqdocvar{t1} (\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvar{t1}) (\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvar{t2})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{IHt1}. \coqdoctac{specialize} (\coqdocvar{H} \coqdocvar{IHt1}). \coqdoctac{rewrite} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.pos right sum compat}{\coqdoclemma{pos\_right\_sum\_compat}}. \coqdoctac{specialize} (\coqdocvar{H0} (\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvar{t2}) \coqdocvar{t1} \coqdocvar{t2}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{IHt2}). \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{rewrite} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{induction} \coqdocvar{t1}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id sym}{\coqdoclemma{sum\_id\_sym}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.pos left mul compat}{\coqdoclemma{pos\_left\_mul\_compat}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H} \coqdocvar{t1} (\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvar{t1}) (\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvar{t2})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{IHt1}. \coqdoctac{specialize} (\coqdocvar{H} \coqdocvar{IHt1}). \coqdoctac{rewrite} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.pos right mul compat}{\coqdoclemma{pos\_right\_mul\_compat}}. \coqdoctac{specialize} (\coqdocvar{H0} (\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvar{t2}) \coqdocvar{t1} \coqdocvar{t2}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{IHt2}). \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{rewrite} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{induction} \coqdocvar{t1}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x sym}{\coqdoclemma{mul\_T0\_x\_sym}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{B Unification.lowenheim formula}{Library }{B\_Unification.lowenheim\_formula}

\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{B Unification.terms}{\coqdoclibrary{terms}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclibrary{List}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Introduction}



 In this section we formulate Lowenheim's algorithm using the data
    structures and functions defined in the \coqdoclibrary{terms} library. The final occuring
    main function, \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}}, takes as input a term and produces a
    substitution that unifies the given term. The resulting substitution is said
    to be a most general unifier and not a mere substitution, but that statement
    is proven in the \coqdoclibrary{lowenheim\_proof} file. In this section we focus on the
    formulation of the algorithm itself, without any proofs about the properties
    of the formula or the algorithm. 

\section{Lowenheim's Builder}



 In this subsection we are implementing the main component of Lowenheim's
    algorithm, which is the ``builder'' of Lowenheim's substitution for a given
    term. This implementation strictly follows as close as possible the formal,
    mathematical format of Lowenheim's algorithm. 

 Here is a skeleton function for building a substition on the format
    $\sigma(x) := (s + 1) \ast \sigma_{1}(x) + s \ast \sigma_{2}(x)$, each
    variable of a given list of variables, a given term \coqdocvariable{s} and subtitutions
    $\sigma_{1}$ and $\sigma_{2}$. This skeleton function is a more general
    format of Lowenheim's builder. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.lowenheim formula.build on list of vars}{build\_on\_list\_of\_vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} (\coqdocvar{list\_var} : \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}}) (\coqdocvar{s} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{sig1} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}})\coqdoceol
\coqdocindent{15.50em}
(\coqdocvar{sig2} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{list\_var} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{v'} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{v} \ensuremath{\Rightarrow} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{v'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{v'}) \coqdocvariable{sig1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}}\coqdoceol
\coqdocindent{10.00em}
\coqdocvariable{s} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{v'}) \coqdocvariable{sig2}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{7.50em}
\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} \coqdocvar{v} \coqdocvariable{s} \coqdocvariable{sig1} \coqdocvariable{sig2}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is the function to build a Lowenheim subsitution for a term \textit{t},
    given the term \textit{t} and a unifier of \textit{t}, using the previously defined
    skeleton function. The list of variables is the variables within \textit{t} and the
    substitions are the identical subtitution and the unifer of the term. This
    fuction will often be referred in the rest of the document as our
    ``Lowenheim builder'' or the ``Lowenheim substitution builder'', etc. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.lowenheim formula.build lowenheim subst}{build\_lowenheim\_subst}{\coqdocdefinition{build\_lowenheim\_subst}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{tau} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t}) \coqdocvariable{t}\coqdoceol
\coqdocindent{12.00em}
(\coqref{B Unification.terms.build id subst}{\coqdocdefinition{build\_id\_subst}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t})) \coqdocvariable{tau}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Lowenheim's Algorithm}



 In this subsection we enhance Lowenheim's builder to the level of a
    complete algorithm that is able to find ground substitutions before feeding
    them to the main formula to generate a most general unifier 

\subsection{Auxillary Functions and Definitions}



 This is a function to update a term, after it applies to it a given
    substitution and simplifies it. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.lowenheim formula.update term}{update\_term}{\coqdocdefinition{update\_term}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{s'} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqref{B Unification.terms.term}{\coqdocinductive{term}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{s'}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is a function to determine if a term is the ground term \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.lowenheim formula.term is T0}{term\_is\_T0}{\coqdocdefinition{term\_is\_T0}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.identical}{\coqdocdefinition{identical}} \coqdocvariable{t} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In this development we have the need to be able to represent both the
    presence and the absence of a substitution. In case for example our
    \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function cannot find a unifier for an input term, we need to
    be able to return a \coqdoctac{subst} \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} type, like a substitution option that states
    no substition was found. We are using the built-in \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} and \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}
    inductive options (that are used as \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} $\sigma$ and \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}) to represent
    some substitution and no substition repsectively. The type of the two above
    is the inductive \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \{\coqdocvariable{A}:\coqdockw{type}\} that can be attached to any type; in our
    case it is \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdoctac{subst}. 

 Our Lownheim builder works when we provide an already existing unifier of
    the input term \textit{t}. For our implementation to be complete we need to be able
    to generate that initial unifier ourselves. That is why we first need to
    define a function to find all possible ``01'' substitutions (substitutions
    where each variable gets mapped to \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} or \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.lowenheim formula.all 01 substs}{all\_01\_substs}{\coqdocdefinition{all\_01\_substs}} (\coqdocvar{vars} : \coqref{B Unification.terms.var set}{\coqdocdefinition{var\_set}}) : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{vars} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqdoceol
  \ensuremath{|} \coqdocvar{v} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{v'} \ensuremath{\Rightarrow} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{s} \ensuremath{\Rightarrow} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{v}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{s}) (\coqref{B Unification.lowenheim formula.all 01 substs}{\coqdocdefinition{all\_01\_substs}} \coqdocvar{v'})\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}}\coqdoceol
\coqdocindent{7.50em}
\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{s} \ensuremath{\Rightarrow} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{v}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{s}) (\coqref{B Unification.lowenheim formula.all 01 substs}{\coqdocdefinition{all\_01\_substs}} \coqdocvar{v'})\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Next is a function to find an initial ``ground unifier'' for our Lowenheim
    builder function. It finds a substitution with ground terms that makes the
    given input term equivalent to \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.lowenheim formula.find unifier}{find\_unifier}{\coqdocdefinition{find\_unifier}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{find}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{find}} (\coqdockw{fun} \coqdocvar{s} \ensuremath{\Rightarrow} \coqdockw{match} \coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} \coqdocvariable{t} \coqdocvariable{s} \coqdockw{with}\coqdoceol
\coqdocindent{8.50em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{8.50em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{8.50em}
\coqdockw{end}) (\coqref{B Unification.lowenheim formula.all 01 substs}{\coqdocdefinition{all\_01\_substs}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Lowenheim's Main Function}



 Here is the main Lowenheim's formula; given a term, produce an MGU (a most
    general substitution that when applied on the input term, it makes it
    equivalent to \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}), if there is one. Otherwise, return \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}. This
    function is often referred in the rest of the document as ``Lowenheim Main''
    function or ``Main Lowenheim'' function, etc. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.lowenheim formula.Lowenheim Main}{Lowenheim\_Main}{\coqdocdefinition{Lowenheim\_Main}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{s} \ensuremath{\Rightarrow} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqref{B Unification.lowenheim formula.build lowenheim subst}{\coqdocdefinition{build\_lowenheim\_subst}} \coqdocvariable{t} \coqdocvar{s})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Lowenheim's Functions Testing}



 In this subsection we explore ways to test the correctness of our Lownheim's
    functions on specific inputs. 

 Here is a function to test the correctness of the output of the
    \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} helper function defined above. True means expected output was
    produced, false otherwise. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.lowenheim formula.Test find unifier}{Test\_find\_unifier}{\coqdocdefinition{Test\_find\_unifier}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{s} \ensuremath{\Rightarrow} \coqref{B Unification.lowenheim formula.term is T0}{\coqdocdefinition{term\_is\_T0}} (\coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} \coqdocvariable{t} \coqdocvar{s})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\end{coqdoccode}
\coqlibrary{B Unification.lowenheim proof}{Library }{B\_Unification.lowenheim\_proof}

\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{B Unification.lowenheim formula}{\coqdoclibrary{lowenheim\_formula}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclibrary{List}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclibrary{EqNat}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclibrary{List}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{Coq.Init.Tactics}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Logic.Classical\_Prop}{\coqdoclibrary{Classical\_Prop}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Introduction}



 In this chapter we provide a proof that our \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} function
    defined in \coqdoclibrary{lowenheim\_formula} provides a unifier that is most general. Our
    final top level proof (found at the end of this file) proves two statements:
    1) If a term is unifiable, then our own defined \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} function
    produces a most general unifier (mgu). 2) If a term is not unifiable, then
    our own defined \coqdocvar{Lownheim\_Main} function produces a \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} substitution. We
    prove the above statements with a series of proofs and sub-groups of proofs
    that help us get to the final top-level statements mentioned above. 

\section{Auxillary Declarations and Their Lemmas Useful For the Final Proofs}



 In this section we provide definitions and proofs of helper functions,
    propositions, and lemmas that will be later used in other proofs. 

 This is the definition of an \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}}. An \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} is a proposition,
    or a relationship between two terms. When a term \textit{t} is an \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} of a
    term \coqdocvariable{t'} then each of the unique variables found within \textit{t} are also found
    within the unique variables of \coqdocvariable{t'}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.lowenheim proof.under term}{under\_term}{\coqdocdefinition{under\_term}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{t'} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}} ),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t'}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a simple lemma for \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}}s that states that a term is an
    \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} of itself. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.under term id}{under\_term\_id}{\coqdoclemma{under\_term\_id}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} \coqdocvariable{t} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{firstorder}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma to prove the summation distribution property of the function
    \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}}: the \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} of a sum of two terms is equal to the
    concantentation of the \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} of each individual term of the original
    sum. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.term vars distr}{term\_vars\_distr}{\coqdoclemma{term\_vars\_distr}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t1} \coqdocvar{t2} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} (\coqdocvariable{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t2}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvariable{t1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvariable{t2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{t2}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma to prove an intuitive statement: if a variable is within the
    \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} (list of variables) of a term, then it is also within the
    \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} of the sum of that term and any other term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.tv h1}{tv\_h1}{\coqdoclemma{tv\_h1}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t1} \coqdocvar{t2} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvariable{t1}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} (\coqdocvariable{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t2})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{t2}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqexternalref{app nil r}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_nil\_r}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqexternalref{app nil r}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_nil\_r}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{pose} \coqdocvar{proof} \coqexternalref{in or app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_or\_app}} \coqdockw{as} \coqdocvar{H1}. \coqdoctac{specialize} (\coqdocvar{H1} \coqref{B Unification.terms.var}{\coqdocdefinition{var}} (\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvar{t1}) \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{v}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvar{x}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{firstorder}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqref{B Unification.lowenheim proof.term vars distr}{\coqdoclemma{term\_vars\_distr}}. \coqdoctac{apply} \coqexternalref{in or app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_or\_app}}. \coqdoctac{left}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqref{B Unification.lowenheim proof.term vars distr}{\coqdoclemma{term\_vars\_distr}}. \coqdoctac{apply} \coqexternalref{in or app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_or\_app}}. \coqdoctac{left}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma similar to the previous one, to prove an intuitive
    statement: if a variable is within the \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} (list of variables) of a
    term, then it is also within the \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} of the sum of that term and any
    other term, but being added from the left side. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.tv h2}{tv\_h2}{\coqdoclemma{tv\_h2}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t1} \coqdocvar{t2} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvariable{t2}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} (\coqdocvariable{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t2})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{t1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{pose} \coqdocvar{proof} \coqexternalref{in or app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_or\_app}} \coqdockw{as} \coqdocvar{H1}. \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqref{B Unification.lowenheim proof.term vars distr}{\coqdoclemma{term\_vars\_distr}}. \coqdoctac{apply} \coqexternalref{in or app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_or\_app}}. \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqref{B Unification.lowenheim proof.term vars distr}{\coqdoclemma{term\_vars\_distr}}. \coqdoctac{apply} \coqexternalref{in or app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_or\_app}}. \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a helper lemma for the \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} relationship : if the sum of two
    terms is a subterm of another term \coqdocvariable{t'}, then the left component of the sum
    is also a subterm of the other term \coqdocvariable{t'}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.helper 2a}{helper\_2a}{\coqdoclemma{helper\_2a}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t1} \coqdocvar{t2} \coqdocvar{t'} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} (\coqdocvariable{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t2}) \coqdocvariable{t'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} \coqdocvariable{t1} \coqdocvariable{t'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} \coqdoctac{in} *. \coqdoctac{intros}. \coqdoctac{specialize} (\coqdocvar{H} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.in dup and non dup}{\coqdoclemma{in\_dup\_and\_non\_dup}} \coqdockw{as} \coqdocvar{H10}. \coqdoctac{unfold} \coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdoctac{in} *. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.tv h1}{\coqdoclemma{tv\_h1}} \coqdockw{as} \coqdocvar{H7}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H7} \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{x}). \coqdoctac{specialize} (\coqdocvar{H10} \coqdocvar{x} (\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvar{t2}))).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H10}. \coqdoctac{apply} \coqdocvar{H1}. \coqdoctac{apply} \coqdocvar{H7}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.in dup and non dup}{\coqdoclemma{in\_dup\_and\_non\_dup}} \coqdockw{as} \coqdocvar{H10}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H10} \coqdocvar{x} (\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvar{t1})). \coqdoctac{destruct} \coqdocvar{H10}. \coqdoctac{apply} \coqdocvar{H4}. \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a helper lemma for the \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} relationship : if the sum of two
    terms is a subterm of another term \coqdocvariable{t'}, then the right component of the sum
    is also a subterm of the other term \coqdocvariable{t'}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.helper 2b}{helper\_2b}{\coqdoclemma{helper\_2b}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t1} \coqdocvar{t2} \coqdocvar{t'} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} (\coqdocvariable{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t2}) \coqdocvariable{t'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} \coqdocvariable{t2} \coqdocvariable{t'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} \coqdoctac{in} *. \coqdoctac{intros}. \coqdoctac{specialize} (\coqdocvar{H} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.in dup and non dup}{\coqdoclemma{in\_dup\_and\_non\_dup}} \coqdockw{as} \coqdocvar{H10}. \coqdoctac{unfold} \coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdoctac{in} *. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.tv h2}{\coqdoclemma{tv\_h2}} \coqdockw{as} \coqdocvar{H7}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H7} \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{x}). \coqdoctac{specialize} (\coqdocvar{H10} \coqdocvar{x} (\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvar{t2}))).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H10}. \coqdoctac{apply} \coqdocvar{H1}. \coqdoctac{apply} \coqdocvar{H7}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.in dup and non dup}{\coqdoclemma{in\_dup\_and\_non\_dup}} \coqdockw{as} \coqdocvar{H10}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H10} \coqdocvar{x} (\coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}} \coqdocvar{t2})). \coqdoctac{destruct} \coqdocvar{H10}. \coqdoctac{apply} \coqdocvar{H4}. \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a helper lemma for lists and their elements: if a variable is a
    member of a list, then it is equal to the first element of that list or it
    is a member of the rest of the elements of that list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.elt in list}{elt\_in\_list}{\coqdoclemma{elt\_in\_list}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{x}: \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{a} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{l} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{a} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqexternalref{in inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_inv}} \coqdockw{as} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H1} \coqref{B Unification.terms.var}{\coqdocdefinition{var}} \coqdocvar{a} \coqdocvar{x} \coqdocvar{l} \coqdocvar{H}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{left}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a similar lemma to the previous one, for lists and their elements:
    if a variable is not a member of a list, then it is not equal to the first
    element of that list and it is not a member of the rest of the elements of
    that list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.elt not in list}{elt\_not\_in\_list}{\coqdoclemma{elt\_not\_in\_list}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{x}: \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{a} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{l} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{a} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqexternalref{not in cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{not\_in\_cons}}. \coqdoctac{specialize} (\coqdocvar{H0} \coqref{B Unification.terms.var}{\coqdocdefinition{var}} \coqdocvar{x} \coqdocvar{a} \coqdocvar{l}). \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{H}). \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma for an intuitive statement for the variables of a term: a
    variable \coqdocvariable{x} belongs to the list of unique variables (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}})
    found within the variable-term that is constructed by variable itself
    \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.in list of var term of var}{in\_list\_of\_var\_term\_of\_var}{\coqdoclemma{in\_list\_of\_var\_term\_of\_var}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{left}. \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is an intuitive lemma to prove that every element either belongs in any
    list or does not. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.var in out list}{var\_in\_out\_list}{\coqdoclemma{var\_in\_out\_list}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{lvar} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{lvar} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{lvar}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqexternalref{classic}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Logic.Classical\_Prop}{\coqdocaxiom{classic}} \coqdockw{as} \coqdocvar{H1}. \coqdoctac{specialize} (\coqdocvar{H1} (\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvar{x} \coqdocvar{lvar})). \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Proof That Lownheim's Algorithm (builder) Unifies a Given Term}



 In this section, we prove that our own defined Lowenheim builder from
    \coqdoclibrary{lowenheim\_formula} (\coqref{B Unification.lowenheim formula.build lowenheim subst}{\coqdocdefinition{build\_lowenheim\_subst}}), produces a unifier; that is,
    given unifiable term and one unifier of the term, it also produces another
    unifier of this term (and as explained in the \coqdoclibrary{terms} library, a unifier is
    a substitution that when applied to term it produces a term equivalent to
    the ground term \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}. 

 This is a helper lemma for the skeleton function defined in
    \coqdoclibrary{lowenheim\_formula}: If we apply a substitution on a term-variable \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x},
    and that substitution is created by the skeleton function
    \coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} applied on a single input variable \coqdocvariable{x}, then the
    resulting term is equivalent to: the resuting term from applying a
    substitution on a term-variable \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}, and that substitution being created
    by the skeleton function \coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} applied on an input list of
    variables that contains variable \coqdocvariable{x}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.helper1 easy}{helper1\_easy}{\coqdoclemma{helper1\_easy}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{x}: \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{lvar} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}})\coqdoceol
\coqdocindent{13.50em}
(\coqdocvar{sig1} \coqdocvar{sig2} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) (\coqdocvar{s} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{lvar} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) (\coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} \coqdocvariable{lvar} \coqdocvariable{s} \coqdocvariable{sig1} \coqdocvariable{sig2}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) (\coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvariable{s} \coqdocvariable{sig1} \coqdocvariable{sig2}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{lvar}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.lowenheim proof.elt in list}{\coqdoclemma{elt\_in\_list}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{a} \coqdocvar{x}) \coqdockw{as} []\coqdocvar{eqn}:?.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{beq nat true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_true}} \coqdoctac{in} \coqdocvar{Heqb}. \coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{x} \coqdocvar{x}) \coqdockw{as} []\coqdocvar{eqn}:?.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{apply} \coqexternalref{beq nat false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_false}} \coqdoctac{in} \coqdocvar{Heqb}.\coqdoceol
\coqdocindent{5.50em}
++ \coqdoctac{destruct} \coqdocvar{Heqb}.\coqdoceol
\coqdocindent{5.50em}
++ \coqdoctac{rewrite} \coqdocvar{Heqb}. \coqdoctac{apply} \coqdocvar{Heqb0}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHlvar}. \coqdoctac{apply} \coqdocvar{IHlvar}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Heqb}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{beq nat false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_false}} \coqdoctac{in} \coqdocvar{Heqb}. \coqdoctac{destruct} \coqdocvar{Heqb}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{a} \coqdocvar{x}) \coqdockw{as} []\coqdocvar{eqn}:?.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{beq nat true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_true}} \coqdoctac{in} \coqdocvar{Heqb}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Heqb}. \coqdoctac{rewrite} \coqdocvar{Heqb} \coqdoctac{in} \coqdocvar{IHlvar}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqdocvar{Heqb}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHlvar}. \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{a} \coqdocvar{a}) \coqdockw{as} []\coqdocvar{eqn}:?.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{apply} \coqdocvar{IHlvar}. \coqdoctac{rewrite} \coqdocvar{Heqb} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{beq nat false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_false}} \coqdoctac{in} \coqdocvar{Heqb}. \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{a} \coqdocvar{x}) \coqdockw{as} []\coqdocvar{eqn}:?.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{apply} \coqexternalref{beq nat true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_true}} \coqdoctac{in} \coqdocvar{Heqb0}. \coqdoctac{rewrite} \coqdocvar{Heqb0} \coqdoctac{in} \coqdocvar{Heqb}. \coqdoctac{destruct} \coqdocvar{Heqb}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{intuition}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHlvar}. \coqdoctac{apply} \coqdocvar{IHlvar}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is another helper lemma for the skeleton function
    \coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} and it can be rephrased this way: applying two
    different substitutions on the same term-variable give the same result. One
    subsitution containing only one replacement, and for its own variable. The
    other subsitution contains the previous replacement but also more
    replacements for other variables (that are obviously not in the variables of
    our term-variable). So, the replacements for the extra variables do not
    affect the application of the subsitution - hence the resulting term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.helper 1}{helper\_1}{\coqdoclemma{helper\_1}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t'} \coqdocvar{s} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{v} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{sig1} \coqdocvar{sig2} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{v}) \coqdocvariable{t'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{v})\coqdoceol
\coqdocindent{7.00em}
(\coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t'}) \coqdocvariable{s} \coqdocvariable{sig1} \coqdocvariable{sig2}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{v})\coqdoceol
\coqdocindent{7.00em}
(\coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{v})) \coqdocvariable{s} \coqdocvariable{sig1} \coqdocvariable{sig2}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{specialize} (\coqdocvar{H} \coqdocvar{v}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.in list of var term of var}{\coqdoclemma{in\_list\_of\_var\_term\_of\_var}} \coqdockw{as} \coqdocvar{H3}. \coqdoctac{specialize} (\coqdocvar{H3} \coqdocvar{v}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H} \coqdocvar{H3}). \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.helper1 easy}{\coqdoclemma{helper1\_easy}} \coqdockw{as} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{v} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvar{t'}) \coqdocvar{sig1} \coqdocvar{sig2} \coqdocvar{s}). \coqdoctac{apply} \coqdocvar{H2}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Lemma 10.4.5 from 'Term Rewriting and All That' book on page 254-255. This a
    very significant lemma used later for the proof that our Lownheim builder
    function (not the Main function, but the builder function), gives a unifier
    (not necessarily an mgu, which would be a next step of the proof). It states
    that if a term \textit{t} is an \coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} of another term \coqdocvariable{t'}, then applying a
    substitution--a substitution created by giving the list of variables of term
    \coqdocvariable{t'} on the skeleton function \coqdocvar{build\_list\_of\_vars}--, on the term \textit{t}, a
    term that has the same format:
    $(s + 1) \ast \sigma_{1}(t) + s \ast \sigma_{2}(t)$ as each replacement of
    each variable on any substitution created by skeleton function:
    $(s + 1) \ast \sigma_{1}(x) + s \ast \sigma_{2}(x)$. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.subs distr vars ver2}{subs\_distr\_vars\_ver2}{\coqdoclemma{subs\_distr\_vars\_ver2}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} \coqdocvar{t'} \coqdocvar{s} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{sig1} \coqdocvar{sig2} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim proof.under term}{\coqdocdefinition{under\_term}} \coqdocvariable{t} \coqdocvariable{t'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} (\coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t'}) \coqdocvariable{s} \coqdocvariable{sig1} \coqdocvariable{sig2}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{sig1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{s} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{sig2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{t'}. \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{t'}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.ground term cannot subst}{\coqdoclemma{ground\_term\_cannot\_subst}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}). \coqdoctac{rewrite} \coqref{B Unification.terms.distr}{\coqdocaxiom{distr}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{s}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{t'}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.ground term cannot subst}{\coqdoclemma{ground\_term\_cannot\_subst}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}). \coqdoctac{rewrite} \coqref{B Unification.terms.mul id}{\coqdocaxiom{mul\_id}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{s}). \coqdoctac{rewrite} \coqref{B Unification.terms.mul id}{\coqdocaxiom{mul\_id}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{s}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.sum assoc}{\coqdocaxiom{sum\_assoc}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}). \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.lowenheim proof.helper 1}{\coqdoclemma{helper\_1}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}}. \coqdoctac{unfold} \coqref{B Unification.terms.term vars}{\coqdocdefinition{term\_vars}}. \coqdoctac{unfold} \coqref{B Unification.terms.var set create unique}{\coqdocdefinition{var\_set\_create\_unique}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.var set includes var}{\coqdocdefinition{var\_set\_includes\_var}}. \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.var subst}{\coqdoclemma{var\_subst}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{specialize} (\coqdocvar{IHt1} \coqdocvar{t'}). \coqdoctac{specialize} (\coqdocvar{IHt2} \coqdocvar{t'}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.subst sum distr opp}{\coqdoclemma{subst\_sum\_distr\_opp}}. \coqdoctac{rewrite} \coqdocvar{IHt1}. \coqdoctac{rewrite} \coqdocvar{IHt2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.terms.distr}{\coqdocaxiom{distr}}. \coqdoctac{rewrite} \coqref{B Unification.terms.distr}{\coqdocaxiom{distr}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.sum assoc}{\coqdocaxiom{sum\_assoc}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvar{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t2} \coqdocvar{sig1})\coqdoceol
\coqdocindent{4.00em}
(\coqdocvar{y} := \coqdocvar{s} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t1} \coqdocvar{sig2} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvar{s} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t2} \coqdocvar{sig2}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.sum assoc}{\coqdocaxiom{sum\_assoc}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{s} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t2} \coqdocvar{sig2})\coqdoceol
\coqdocindent{4.00em}
(\coqdocvar{y} := \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvar{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t2} \coqdocvar{sig1}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.sum assoc}{\coqdocaxiom{sum\_assoc}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{pose} \coqref{B Unification.lowenheim proof.helper 2b}{\coqdoclemma{helper\_2b}} \coqdockw{as} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{t'}). \coqdoctac{apply} \coqdocvar{H2}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{pose} \coqref{B Unification.lowenheim proof.helper 2a}{\coqdoclemma{helper\_2a}} \coqdockw{as} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{t'}). \coqdoctac{apply} \coqdocvar{H2}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{specialize} (\coqdocvar{IHt1} \coqdocvar{t'}). \coqdoctac{specialize} (\coqdocvar{IHt2} \coqdocvar{t'}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.subst mul distr opp}{\coqdoclemma{subst\_mul\_distr\_opp}}. \coqdoctac{rewrite} \coqdocvar{IHt1}. \coqdoctac{rewrite} \coqdocvar{IHt2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.terms.distr}{\coqdocaxiom{distr}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}} \coqdockw{with} (\coqdocvar{y} := \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvar{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t2} \coqdocvar{sig1}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.distr}{\coqdocaxiom{distr}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}} \coqdockw{with} (\coqdocvar{y} := \coqdocvar{s} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t2} \coqdocvar{sig2}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.distr}{\coqdocaxiom{distr}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.mul assoc}{\coqdocaxiom{mul\_assoc}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t2} \coqdocvar{sig1}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.mul assoc}{\coqdocaxiom{mul\_assoc}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul assoc opp}{\coqdoclemma{mul\_assoc\_opp}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}) (\coqdocvar{y} := \coqdocvar{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}). \coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul assoc opp}{\coqdoclemma{mul\_assoc\_opp}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}) (\coqdocvar{y} := \coqdocvar{s}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}) (\coqdocvar{y} := \coqdocvar{s}). \coqdoctac{rewrite} \coqref{B Unification.terms.distr}{\coqdocaxiom{distr}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul id sym}{\coqdoclemma{mul\_id\_sym}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.mul assoc}{\coqdocaxiom{mul\_assoc}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t2} \coqdocvar{sig2}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.mul assoc}{\coqdocaxiom{mul\_assoc}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul assoc opp}{\coqdoclemma{mul\_assoc\_opp}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{s}) (\coqdocvar{y} := \coqdocvar{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}). \coqdoctac{rewrite} \coqref{B Unification.terms.distr}{\coqdocaxiom{distr}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul id sym}{\coqdoclemma{mul\_id\_sym}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.sum assoc}{\coqdocaxiom{sum\_assoc}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum assoc opp}{\coqdoclemma{sum\_assoc\_opp}} \coqdockw{with} (\coqdocvar{x} := \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}) (\coqdocvar{y} := \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.mul assoc}{\coqdocaxiom{mul\_assoc}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t2} \coqdocvar{sig2})\coqdoceol
\coqdocindent{4.00em}
(\coqdocvar{y} := \coqdocvar{s} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t1} \coqdocvar{sig2}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.terms.mul assoc}{\coqdocaxiom{mul\_assoc}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul assoc opp}{\coqdoclemma{mul\_assoc\_opp}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{s}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{pose} \coqref{B Unification.lowenheim proof.helper 2b}{\coqdoclemma{helper\_2b}} \coqdockw{as} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{t'}). \coqdoctac{apply} \coqdocvar{H2}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{pose} \coqref{B Unification.lowenheim proof.helper 2a}{\coqdoclemma{helper\_2a}} \coqdockw{as} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{t'}). \coqdoctac{apply} \coqdocvar{H2}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is an intermediate lemma occuring by the previous lemma 10.4.5.
    Utilizing lemma 10.4.5 and also using two substitutions for the skeleton
    function \coqdocvar{build\_on\_list\_vars} gives a substituion the unifies the term; the
    two substitutions being a known unifier of the term and the identity
    substitution. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.specific sigmas unify}{specific\_sigmas\_unify}{\coqdoclemma{specific\_sigmas\_unify}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{tau} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{tau} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} (\coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}}\coqdoceol
\coqdocindent{9.00em}
(\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t}) \coqdocvariable{t} (\coqref{B Unification.terms.build id subst}{\coqdocdefinition{build\_id\_subst}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t}))\coqdoceol
\coqdocindent{9.00em}
\coqdocvariable{tau}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.lowenheim proof.subs distr vars ver2}{\coqdoclemma{subs\_distr\_vars\_ver2}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqref{B Unification.terms.id subst}{\coqdoclemma{id\_subst}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul comm}{\coqdocaxiom{mul\_comm}} \coqdockw{with} (\coqdocvar{x} := \coqdocvar{t} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}). \coqdoctac{rewrite} \coqref{B Unification.terms.distr}{\coqdocaxiom{distr}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul x x}{\coqdocaxiom{mul\_x\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul id sym}{\coqdoclemma{mul\_id\_sym}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum x x}{\coqdocaxiom{sum\_x\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x sym}{\coqdoclemma{mul\_T0\_x\_sym}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.lowenheim proof.under term id}{\coqdoclemma{under\_term\_id}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is the resulting lemma from this subsection: Our Lowenheim's
    subsitution builder produces a unifier for an input term; namely, a
    substitution that unifies the term, given that term is unifiable and we know
    an already existing unifier $\tau$. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.lownheim unifies}{lownheim\_unifies}{\coqdoclemma{lownheim\_unifies}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{tau} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{tau} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} (\coqref{B Unification.lowenheim formula.build lowenheim subst}{\coqdocdefinition{build\_lowenheim\_subst}} \coqdocvariable{t} \coqdocvariable{tau}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.build lowenheim subst}{\coqdocdefinition{build\_lowenheim\_subst}}. \coqdoctac{apply} \coqref{B Unification.lowenheim proof.specific sigmas unify}{\coqdoclemma{specific\_sigmas\_unify}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Proof That Lownheim's Algorithm (Builder) Produces a Most General Unifier}


      

 In the previous section we proved that our Lowenheim builder produces a
    unifier, if we already know an existing unifier of the term. In this section
    we prove that this unifier is also a most general unifier. 

\subsection{Proof That Lownheim's Algorithm (Builder) Produces a Reproductive Unifier}


       

 In this subsection we will prove that our Lowenheim builder gives a unifier
    that is reproductive; this will help us in the proof that the resulting
    unifier is an mgu, since a reproductive unifier is a ``stronger'' property
    than an mgu. 

 This is a lemma for an intuitive statement for the skeleton function
    \coqdocvar{build\_on\_list\_vars}: if a variable \coqdocvariable{x} is in a list \coqdocvariable{l}, and we apply a
    substitution created by the \coqdocvar{build\_on\_list\_vars} function given input list
    \coqdocvariable{l}, on the term-variable \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}, then we get the replacement for that
    particular variable that was contained in the original substitution. So
    basically if \coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} is applied on a list of variables \coqdocvariable{l}
    ($x_{1}, x{2}, x_{3}, ..., x_{n}$), then the resulting substitution is in
    the format
    $x_{i} \mapsto (s + 1) \ast \sigma_{1}(x_{i}) + s \ast \sigma_{2}(x_{i})$
    for each $x_{i}$. If we apply that substitution on the term-variable $x_{1},
    we will get the initial format of the replacement:
    $(s + 1) \symbol{92}ast \symbol{92}sigma\{1\}(x\{1\}) + s \symbol{92}ast \symbol{92}sigma\{2\}(x\{1\})$. It can be
    thought as "reverse application" of the skeleton function. $\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.lowenheim rephrase1 easy}{lowenheim\_rephrase1\_easy}{\coqdoclemma{lowenheim\_rephrase1\_easy}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}})\coqdoceol
\coqdocindent{20.00em}
(\coqdocvar{sig1} \coqdocvar{sig2} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) (\coqdocvar{s} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) (\coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} \coqdocvariable{l} \coqdocvariable{s}  \coqdocvariable{sig1} \coqdocvariable{sig2}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{s} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) \coqdocvariable{sig1}  \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{s} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) \coqdocvariable{sig2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{l}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{unfold} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.lowenheim proof.elt in list}{\coqdoclemma{elt\_in\_list}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{a} \coqdocvar{x}) \coqdockw{as} []\coqdocvar{eqn}:?.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{pose} \coqdocvar{proof} \coqexternalref{beq nat false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_false}} \coqdockw{as} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{a} \coqdocvar{x}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{Heqb}). \coqdoctac{intuition}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{H}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{inversion} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{a} \coqdocvar{x}) \coqdockw{as} []\coqdocvar{eqn}:?.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Heqb}. \coqdoctac{pose} \coqdocvar{proof} \coqexternalref{beq nat eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocdefinition{beq\_nat\_eq}} \coqdockw{as} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{a} \coqdocvar{x}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{Heqb}). \coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a helper lemma for an intuitive statement: if a variable \coqdocvariable{x} is
    found in a list of variables \coqdocvariable{l}, then applying the subsitution created by
    the \coqref{B Unification.terms.build id subst}{\coqdocdefinition{build\_id\_subst}} function given input list \coqdocvariable{l}, on the term-variable
    \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}, we will get the same \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x} back. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.helper 3a}{helper\_3a}{\coqdoclemma{helper\_3a}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{x}: \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{l}: \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) (\coqref{B Unification.terms.build id subst}{\coqdocdefinition{build\_id\_subst}} \coqdocvariable{l}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{l}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.terms.build id subst}{\coqdocdefinition{build\_id\_subst}}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.lowenheim proof.elt in list}{\coqdoclemma{elt\_in\_list}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{a} \coqdocvar{x}) \coqdockw{as} []\coqdocvar{eqn}:?.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{pose} \coqdocvar{proof} \coqexternalref{beq nat false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_false}} \coqdockw{as} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{a} \coqdocvar{x}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{Heqb}). \coqdoctac{intuition}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{H}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{inversion} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{a} \coqdocvar{x}) \coqdockw{as} []\coqdocvar{eqn}:?.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Heqb}. \coqdoctac{pose} \coqdocvar{proof} \coqexternalref{beq nat eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocdefinition{beq\_nat\_eq}} \coqdockw{as} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{a} \coqdocvar{x}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{Heqb}). \coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma for an intuitive statement for the Lowenheim builder,
    very similar to lemma \coqref{B Unification.lowenheim proof.lowenheim rephrase1 easy}{\coqdoclemma{lowenheim\_rephrase1\_easy}}: applying Lowenheim's
    subtitution given an input term \textit{t}, on any term-variable of the term \textit{t},
    gives us the initial format of the replacement for that variable
    (Lowenheim's reverse application). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.lowenheim rephrase1}{lowenheim\_rephrase1}{\coqdoclemma{lowenheim\_rephrase1}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{tau} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{tau} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) (\coqref{B Unification.lowenheim formula.build lowenheim subst}{\coqdocdefinition{build\_lowenheim\_subst}} \coqdocvariable{t} \coqdocvariable{tau}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqdocvariable{t} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{(}}\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}\coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{)}} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvariable{t} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) \coqdocvariable{tau}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.lowenheim formula.build lowenheim subst}{\coqdocdefinition{build\_lowenheim\_subst}}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.lowenheim rephrase1 easy}{\coqdoclemma{lowenheim\_rephrase1\_easy}} \coqdockw{as} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H1} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvar{t}) \coqdocvar{x}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.terms.build id subst}{\coqdocdefinition{build\_id\_subst}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvar{t})) \coqdocvar{tau} \coqdocvar{t}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.lowenheim proof.helper 3a}{\coqdoclemma{helper\_3a}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{H1}. \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma for an intuitive statement for the skeleton function
    \coqdocvar{build\_on\_list\_vars} that resemebles a lot of \coqref{B Unification.lowenheim proof.lowenheim rephrase1 easy}{\coqdoclemma{lowenheim\_rephrase1\_easy}}: if
    a variable \coqdocvariable{x} is not in a list \coqdocvariable{l}, and we apply a substitution created by
    the \coqdocvar{build\_on\_list\_vars} function given input list \coqdocvariable{l}, on the term-variable
    \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}, then we get the term-variable \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x} back; that is expected since
    the replacements in the substitution should not contain any entry with
    variable \coqdocvariable{x}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.lowenheim rephrase2 easy}{lowenheim\_rephrase2\_easy}{\coqdoclemma{lowenheim\_rephrase2\_easy}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}})\coqdoceol
\coqdocindent{20.00em}
(\coqdocvar{sig1} \coqdocvar{sig2} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) (\coqdocvar{s} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) (\coqref{B Unification.lowenheim formula.build on list of vars}{\coqdocdefinition{build\_on\_list\_of\_vars}} \coqdocvariable{l} \coqdocvariable{s} \coqdocvariable{sig1} \coqdocvariable{sig2}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{l}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.elt not in list}{\coqdoclemma{elt\_not\_in\_list}} \coqdockw{as} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{x} \coqdocvar{a} \coqdocvar{l}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{H}). \coqdoctac{destruct} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvar{a} \coqdocvar{x}) \coqdockw{as} []\coqdocvar{eqn}:?.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Heqb}. \coqdoctac{apply} \coqexternalref{beq nat eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocdefinition{beq\_nat\_eq}} \coqdoctac{in} \coqdocvar{Heqb}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Heqb}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{Heqb}). \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma for an intuitive statement for the Lowenheim builder,
    very similar to lemma \coqref{B Unification.lowenheim proof.lowenheim rephrase2 easy}{\coqdoclemma{lowenheim\_rephrase2\_easy}} and \coqref{B Unification.lowenheim proof.lowenheim rephrase1}{\coqdoclemma{lowenheim\_rephrase1}}:
    applying Lowenheim's subtitution given an input term \textit{t}, on any
    term-variable not of the ones of term \textit{t}, gives us back the same
    term-variable. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.lowenheim rephrase2}{lowenheim\_rephrase2}{\coqdoclemma{lowenheim\_rephrase2}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{tau} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) (\coqdocvar{x} : \coqref{B Unification.terms.var}{\coqdocdefinition{var}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{tau} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t})\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}) (\coqref{B Unification.lowenheim formula.build lowenheim subst}{\coqdocdefinition{build\_lowenheim\_subst}} \coqdocvariable{t} \coqdocvariable{tau}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.build lowenheim subst}{\coqdocdefinition{build\_lowenheim\_subst}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.lowenheim rephrase2 easy}{\coqdoclemma{lowenheim\_rephrase2\_easy}} \coqdockw{as} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H2} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvar{t}) \coqdocvar{x}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.terms.build id subst}{\coqdocdefinition{build\_id\_subst}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvar{t})) \coqdocvar{tau} \coqdocvar{t}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{H0}). \coqdoctac{apply} \coqdocvar{H2}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is the resulting lemma of the secton: our Lowenheim builder
    \coqdocvar{build\_lownheim\_subst} gives a reproductive unifier. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.lowenheim reproductive}{lowenheim\_reproductive}{\coqdoclemma{lowenheim\_reproductive}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{tau} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{tau} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.reproductive unifier}{\coqdocdefinition{reproductive\_unifier}} \coqdocvariable{t} (\coqref{B Unification.lowenheim formula.build lowenheim subst}{\coqdocdefinition{build\_lowenheim\_subst}} \coqdocvariable{t} \coqdocvariable{tau}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.terms.reproductive unifier}{\coqdocdefinition{reproductive\_unifier}}. \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.var in out list}{\coqdoclemma{var\_in\_out\_list}}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.lowenheim proof.lownheim unifies}{\coqdoclemma{lownheim\_unifies}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{x} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvar{t})). \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.lowenheim proof.lowenheim rephrase1}{\coqdoclemma{lowenheim\_rephrase1}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \coqref{B Unification.terms.subst sum distr opp}{\coqdoclemma{subst\_sum\_distr\_opp}}. \coqdoctac{rewrite} \coqref{B Unification.terms.subst mul distr opp}{\coqdoclemma{subst\_mul\_distr\_opp}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.subst mul distr opp}{\coqdoclemma{subst\_mul\_distr\_opp}}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H1}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.mul T0 x}{\coqdocaxiom{mul\_T0\_x}}. \coqdoctac{rewrite} \coqref{B Unification.terms.subst sum distr opp}{\coqdoclemma{subst\_sum\_distr\_opp}}. \coqdoctac{rewrite} \coqdocvar{H1}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqref{B Unification.terms.ground term cannot subst}{\coqdoclemma{ground\_term\_cannot\_subst}}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}. \coqdoctac{rewrite} \coqref{B Unification.terms.mul id}{\coqdocaxiom{mul\_id}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum comm}{\coqdocaxiom{sum\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.terms.sum id}{\coqdocaxiom{sum\_id}}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{unfold} \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.lowenheim proof.lowenheim rephrase2}{\coqdoclemma{lowenheim\_rephrase2}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Proof That Lowenheim's Algorithm (Builder) Produces a Most General}


       Unifier 

 In this subsection we will prove that our Lowenheim builder gives a
    unifier that is most general; this will help us a lot in the top-level proof
    that the \coqdocvar{Main\_Lownheim} function gives an mgu. 

 Here is the subsection's resulting lemma. Given a unifiable term \textit{t}, a
    unifier of \textit{t}, then our Lowenheim builder (\coqdocvar{build\_lownheim\_subst})
    gives a most general unifier (mgu). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.lowenheim most general unifier}{lowenheim\_most\_general\_unifier}{\coqdoclemma{lowenheim\_most\_general\_unifier}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{tau} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{tau} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}} \coqdocvariable{t} (\coqref{B Unification.lowenheim formula.build lowenheim subst}{\coqdocdefinition{build\_lowenheim\_subst}} \coqdocvariable{t} \coqdocvariable{tau}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{apply} \coqref{B Unification.terms.reproductive is mgu}{\coqdoclemma{reproductive\_is\_mgu}}. \coqdoctac{apply} \coqref{B Unification.lowenheim proof.lowenheim reproductive}{\coqdoclemma{lowenheim\_reproductive}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Proof of Correctness of \texorpdfstring{\protect\coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}}}{Lowenheim\_Main}}



 In the previous section, we proved that our ``lowenheim builder'' produces an
    mgu of an input term \textit{t} , given an existing unifier of \textit{t} . Even though
    what was proven in the previous section was the bulk of the core proof which
    was also presented in the book in a higher level, it did not incorporate
    many crucial elements.  In this section we provide a proof of correctness of
    our \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} function, basically incorporating more elements in the
    final proof, like proving correctness in the case that the term \textit{t} is not
    unifiable (which is not covered in the previous section), include in the
    proofs our \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function that finds an initial ``01'' substitution
    to feed the ``lownheim builder'',and more. As it follows from the above, the
    proof of correctness of the \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} function, uses the proof of the
    previous section (that the ``lowenheim builder'' produces) as a building
    block. 

 In this section we prove that our own defined Lowenheim function satisfies
    its two main requirements: 1) If a term is unifiable, then \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}}
    function produces a most general unifier (mgu). 2) If a term is not
    unifiable, then \coqdocvar{Lownheim\_Main} function produces a \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} substitution. The
    final top-level proof is at the end of this section. To get there, we prove
    a series of intermediate lemmas that are needed for the final proof. 

\subsection{General Proof Utilities}



 In this section we provide helper ``utility'' lemmas and functions that are
    used in the proofs of intermediate lemmas that are in turn used in the final
    proof. \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
This is a function that converts an \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdoctac{subst} to a \coqdoctac{subst}. It is
    designed to be used mainly for \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdoctac{subst}s that are \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} $\sigma$. If
    the input \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdoctac{subst} is not \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} and is \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} then it returns the
    \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} substitution, but that case should not normally be considered. This
    function is useful because many functions and lemmas are defined for the
    substitution type not the option substitution type. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.lowenheim proof.convert to subst}{convert\_to\_subst}{\coqdocdefinition{convert\_to\_subst}} (\coqdocvar{so} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{so} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{s} \ensuremath{\Rightarrow} \coqdocvar{s}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is an intuitive helper lemma that proves that if an empty substitution
    is applied on any term \textit{t}, then the resulting term is the same input term
    \textit{t}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.empty subst on term}{empty\_subst\_on\_term}{\coqdoclemma{empty\_subst\_on\_term}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHt1}. \coqdoctac{rewrite} \coqdocvar{IHt2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHt1}. \coqdoctac{rewrite} \coqdocvar{IHt2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This another intutive helper lemma that states that if the empty
    substitution is applied on any term \textit{t}, and the resulting term is
    equivalent to the ground term \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}, then the input term \textit{t} must be
    equivalent to the ground term \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.app subst T0}{app\_subst\_T0}{\coqdoclemma{app\_subst\_T0}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{0.50em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.lowenheim proof.empty subst on term}{\coqdoclemma{empty\_subst\_on\_term}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is another intutitve lemma that uses classical logic for its proof. It
    states that any term \textit{t}, can be equivalent to the ground term \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} or it
    cannot be equivalent to it. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.T0 or not T0}{T0\_or\_not\_T0}{\coqdoclemma{T0\_or\_not\_T0}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{0.50em}
\coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{pose} \coqdocvar{proof} \coqexternalref{classic}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Logic.Classical\_Prop}{\coqdocaxiom{classic}}. \coqdoctac{specialize} (\coqdocvar{H} (\coqdocvar{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}})). \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is another intuitive helper lemma that states: if applying a
    substitution $\sigma$ on a term \textit{t} gives a term equivalent to \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} then
    there exists a substitution that applying it to term \textit{t} gives a term
    equivalent to \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} (which is obvious since we already know $\sigma$ exists
    for that task). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.exists subst}{exists\_subst}{\coqdoclemma{exists\_subst}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{sig} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{s} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{sig}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.t id eqv}{t\_id\_eqv}{\coqdoclemma{t\_id\_eqv}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This a helper lemma that states: if two \coqdocvar{options} \coqdoctac{subst}s (specifically
    \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}}) are equal then the substitutions contained within the \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdoctac{subst}
    are also equal. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.eq some eq subst}{eq\_some\_eq\_subst}{\coqdoclemma{eq\_some\_eq\_subst}} (\coqdocvar{s1} \coqdocvar{s2}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{s1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{s2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{s2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{congruence}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This a helper lemma that states: if the \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function (the one
    that tries to find a ground unifier for term \textit{t}) does not find a unifier
    (returns \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}) for an input term \textit{t} then it not \coqexternalref{True}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{True}} (true not in
    ``boolean format'' but as a proposition) that the \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function
    produces a \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdoctac{subst}. This lemma and the following ones that are similar,
    are very useful for the intermediate proofs because we are able to convert a
    proposition about the return type of the \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function to an
    equivalent one, e.g. from \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \coqdoctac{subst} to \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdoctac{subst} and vice versa. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.None is not Some}{None\_is\_not\_Some}{\coqdoclemma{None\_is\_not\_Some}} (\coqdocvar{t}: \coqref{B Unification.terms.term}{\coqdocinductive{term}}):\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{sig}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}), \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{congruence}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This a helper lemma similar to the previous one that states: if the
    \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function (the one that tries to find a ground unifier for
    term \textit{t}) finds a unifier (returns \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} $\sigma$) for an input term \textit{t}
    then it is not \coqexternalref{True}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{True}} (true not in ``boolean format'' but as a proposition)
    that the \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function produces a \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \coqdoctac{subst}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.Some is not None}{Some\_is\_not\_None}{\coqdoclemma{Some\_is\_not\_None}} (\coqdocvar{sig}: \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) (\coqdocvar{t}: \coqref{B Unification.terms.term}{\coqdocinductive{term}}):\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{congruence}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This a helper lemma similar to the previous ones that states: if the
    \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function (the one that tries to find a ground unifier for
    term \textit{t}) does not find a unifier that returns \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} for an input term \textit{t}
    then it is \coqexternalref{True}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocinductive{True}} (true not in ``boolean format'' but as a proposition) that
    the \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function produces a \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdoctac{subst}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.not None is Some}{not\_None\_is\_Some}{\coqdoclemma{not\_None\_is\_Some}} (\coqdocvar{t}: \coqref{B Unification.terms.term}{\coqdocinductive{term}}) :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvar{t}) \coqdockw{as} [\coqdocvar{ti} \ensuremath{|} ].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{\ensuremath{\exists}} \coqdocvar{ti}. \coqdoctac{firstorder}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{congruence}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is an intutitive helper lemma that uses classical logic to prove the
    validity of an alternate version of the contrapositive proposition: if \coqdocvariable{p}
    then \coqdocvariable{q} implies if not \coqdocvariable{q} then not \coqdocvariable{p}, but with each entity (proposition
    \coqdocvariable{q} and \coqdocvariable{p}) negated. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.contrapositive opposite}{contrapositive\_opposite}{\coqdoclemma{contrapositive\_opposite}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{apply} \coqexternalref{NNPP}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Logic.Classical\_Prop}{\coqdoclemma{NNPP}}. \coqdoctac{firstorder}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is an intutitive helper lemma that uses classical logic to prove the
    validity of the contrapositive proposition: if \coqdocvariable{p} then \coqdocvariable{q} implies not \coqdocvariable{q}
    then not \coqdocvariable{p}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.contrapositive}{contrapositive}{\coqdoclemma{contrapositive}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} \coqdocvar{q} : \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{p}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{firstorder}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The following five lemmas are also helper lemmas. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.None not Some}{None\_not\_Some}{\coqdoclemma{None\_not\_Some}} \{\coqdocvar{T} \coqdocvar{U}: \coqdockw{Type}\} (\coqdocvar{f} : \coqdocvariable{U} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdocvariable{T}) (\coqdocvar{x}: \coqdocvariable{U}):\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{f} \coqdocvariable{x}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} (\coqdocvar{t}: \coqdocvariable{T}), \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{f} \coqdocvariable{x}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{t}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H1} \coqdocvar{H2} \coqdocvar{H3}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{congruence}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.Some not None}{Some\_not\_None}{\coqdoclemma{Some\_not\_None}} \{\coqdocvar{T} \coqdocvar{U}: \coqdockw{Type}\} (\coqdocvar{f} : \coqdocvariable{U} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdocvariable{T}) (\coqdocvar{x}: \coqdocvariable{U}) (\coqdocvar{t}: \coqdocvariable{T}):\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{f} \coqdocvariable{x}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{t} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H1} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{congruence}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.not None Some}{not\_None\_Some}{\coqdoclemma{not\_None\_Some}} \{\coqdocvar{T} \coqdocvar{U}: \coqdockw{Type}\} (\coqdocvar{f} : \coqdocvariable{U} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdocvariable{T}) (\coqdocvar{x}: \coqdocvariable{U}) :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{t} : \coqdocvariable{T}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{f} \coqdocvar{x}) \coqdockw{as} [\coqdocvar{t} \ensuremath{|} ].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{\ensuremath{\exists}} \coqdocvar{t}; \coqdocvar{easy}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{congruence}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.not Some None}{not\_Some\_None}{\coqdoclemma{not\_Some\_None}} \{\coqdocvar{T} \coqdocvar{U}: \coqdockw{Type}\} (\coqdocvar{f} : \coqdocvariable{U} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdocvariable{T}) (\coqdocvar{x}: \coqdocvariable{U}) :\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{t} : \coqdocvariable{T}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{t}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.lowenheim proof.contrapositive opposite}{\coqdoclemma{contrapositive\_opposite}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.lowenheim proof.not None Some}{\coqdoclemma{not\_None\_Some}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{tauto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.existsb find}{existsb\_find}{\coqdoclemma{existsb\_find}} \{\coqdocvar{T}: \coqdockw{Type}\} (\coqdocvar{f}: \coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}}) (\coqdocvar{l} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{T}) :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{existsb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{existsb}} \coqdocvariable{f} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvar{a}: \coqdocvariable{T}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{),}} \coqexternalref{find}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{find}} \coqdocvariable{f} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{a}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{NNPP}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Logic.Classical\_Prop}{\coqdoclemma{NNPP}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.lowenheim proof.not Some None}{\coqdoclemma{not\_Some\_None}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{A1}:= \coqexternalref{find none}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{find\_none}} \coqdocvar{f} \coqdocvar{l}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{A2}:= \coqdocvar{A1} \coqdocvar{H1}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{A3}:= \coqexternalref{existsb exists}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{existsb\_exists}} \coqdocvar{f} \coqdocvar{l}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{A3} \coqdockw{as} [\coqdocvar{A31} \coqdocvar{A32}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{A4}:= \coqdocvar{A31} \coqdocvar{H}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{A4} \coqdockw{as} [\coqdocvar{t} \coqdocvar{A41}]. \coqdoctac{destruct} \coqdocvar{A41} \coqdockw{as} [\coqdocvar{A411} \coqdocvar{A412}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{A21}:= \coqdocvar{A2} \coqdocvar{t} \coqdocvar{A411}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{A412} \coqdoctac{in} \coqdocvar{A21}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{congruence}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Utilities and Admitted Lemmas Used in the Proof of \texorpdfstring{\protect\coqref{B Unification.lowenheim proof.unif some subst}{\coqdoclemma{unif\_some\_subst}}}{unif\_some\_subst}}



 In this subsection we have collected and put together all the functions and
    lemmas that are used to prove the \coqref{B Unification.lowenheim proof.unif some subst}{\coqdoclemma{unif\_some\_subst}} lemma that is used in
    the following intermediate lemmas section, and specifically in the
    ``unifiable t'' case. The higher-level lemma we aim to prove using this
    section is a seemingly simple, but in reality very complex lemma; the
    \coqref{B Unification.lowenheim proof.unif some subst}{\coqdoclemma{unif\_some\_subst}} lemma states that if there is any unifier \coqdocvariable{sig1} for a
    term \textit{t} then there exists a unifier \coqdocvariable{sig2} which is returned by our
    \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function. 

 Due to lack of time, out team did not manage to prove these last five
    lower-level lemmas used in the proof of \coqref{B Unification.lowenheim proof.unif some subst}{\coqdoclemma{unif\_some\_subst}}, and since they
    are all used only in the proof of that lemma lemmas, we decided to put them
    together here in this subsection. 

\subsubsection{Utilities Used in This Subsection}



 In this sub-chapter we are declaring two utility lemmas used in next
    sub-chapter by the lower-level lemmas of this proof. 

 This is a lemma that states that sequentially applying two substitutions on
    a term produces the same term as applying the composed subtitutions on the
    term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.subst compose eqv}{subst\_compose\_eqv}{\coqdoclemma{subst\_compose\_eqv}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{sig1} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) (\coqdocvar{sig2} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} (\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} \coqdocvariable{sig1} \coqdocvariable{sig2}) \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} \coqdocvariable{sig2}) \coqdocvariable{sig1}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{induction} \coqdocvar{sig2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{induction} \coqdocvar{sig1}.\coqdoceol
\coqdocnoindent
\coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is an intuitive lemma that states when a term is equivalent to \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} and
    it is also a ground term then simplifying it gives a term exactly equal to
    \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}. This intitutively follows from the fact that since \textit{t} is a ground
    term then all its terms are either \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} or \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}} and since it is equivalent
    to \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}, simplifying it will also give a single final ground term \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.simplify eq T0}{simplify\_eq\_T0}{\coqdoclemma{simplify\_eq\_T0}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{t} \coqref{B Unification.terms.:::x '==' x}{\coqdocnotation{==}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{B Unification.terms.is ground term}{\coqdocdefinition{is\_ground\_term}} \coqdocvariable{t}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.terms.T1 not equiv T0}{\coqdocaxiom{T1\_not\_equiv\_T0}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{andb prop}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdoclemma{andb\_prop}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Lower Level Lemmas Leading Up to the Proof of \texorpdfstring{\protect\coqref{B Unification.lowenheim proof.unif some subst}{\coqdoclemma{unif\_some\_subst}}}{unif\_some\_subst}}



 In this sub-chapter we are providing the most important lower-level lemmas
    leading up to the proof of the \coqref{B Unification.lowenheim proof.unif some subst}{\coqdoclemma{unif\_some\_subst}} lemma. 

 To accomplish the goal of providing the infrastructure to prove the
    \coqref{B Unification.lowenheim proof.unif some subst}{\coqdoclemma{unif\_some\_subst}} lemma, we are defining a number of functions and lemmas
    that are used in the proof of the \coqref{B Unification.lowenheim proof.unif some subst}{\coqdoclemma{unif\_some\_subst}}. We are focusing on
    connecting the concept of a ``01'' subtitution with any given substitution. We
    are attempting to create a ``01'' substitution given any input substitution,
    and then prove facts about the new ``01'' substitution. 

 The basic outline of the proof is as follows : From any unifier \coqdocvariable{sig1} of
    term \textit{t} we can create a ``01'' unifier \coqdocvariable{sig2}, as the one defined in the
    \coqdocvar{terms.v} libary. Since our \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function looks for all ``01''
    substitutions to find a unifier, and we already know there exists at least
    one unifier \coqdocvariable{sig2} that will be returned from the \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function.
    

 As it follows, the lower part of this proof is (1) creating a ``01'' unifier
    \coqdocvariable{sig2} from a given given unifier of \textit{t} \coqdocvariable{sig1} (2) proving that the new
    ``unifier'' is actually a unifier and proving that it is actually a ``01''
    substitution. 

 All the following functions are defined in order to create a final function
    that is able to produce a ``01'' unifier \coqdocvariable{sig2} given a unifier \coqdocvariable{sig1}. The
    way sig2 is created is by composing two subsitutions, \coqdocvariable{sig1}  and \coqdocvar{sig1b} so
    that \coqdocvar{sig1b} and \coqdocvariable{sig1} are composed to give us sig2. The idea behind the
    \coqdocvar{sig1b} substitution creation function is that it takes all the replacements
    of the given unifier \coqdocvariable{sig1} and it does the following to each replacement of
    the \coqdocvariable{sig1} substitution (let us represent each replacement as (\coqdocvariable{v},\coqref{B Unification.poly.MonoOrder.t}{\coqdocdefinition{t}}):
    if the second part of the replacement is a \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}} , then we create a
    new replacement that is (\coqdocvariable{v}, \coqdocvariable{t'}), where \coqdocvariable{t'} is the simplified initial
    second part \textit{t}. If the second part of the relacement is not a
    \coqref{B Unification.terms.ground term}{\coqdocdefinition{ground\_term}}, then we create a list of new replacements where each new
    replacement is one variable found in the initial \coqdocvariable{v} mapped to the ground
    term \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}. So for example suppose our \coqdocvariable{sig1} included the replacement
    (\coqdocvariable{v}, \coqdocvariable{x} + \coqdocvariable{y} + \coqref{B Unification.terms.T1}{\coqdocconstructor{T1}}); we then create the new replacements (\coqdocvariable{x}, \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}) and
    (\coqdocvariable{y}, \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}). 

 The total final list of all the new replacements is the substitution
    \coqdocvar{sig1b}. As we want to cover for all edge cases, we have created a slightly
    enhanced version of this \coqdocvar{sig1b} creation function. Instead of working on
    the initial \coqdocvariable{sig1} unnifier, we are enhancing \coqdocvariable{sig1} by adding a list of
    identity replacement for all variables of term \textit{t} that are not in \coqdocvariable{sig1}.
    For example for the term $x \ast y$ and the unifier (\coqdocvariable{x},\coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}), we first
    enhance \coqdocvariable{sig1} by making it (\coqdocvariable{x},\coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}), (\coqdocvariable{y},\coqdocvariable{y}) and then we create \coqdocvar{sig1b} based
    on the enhanced \coqdocvariable{sig1}.


    After composing \coqdocvar{sig1b} with \coqdocvariable{sig1} we get \coqdocvariable{sig2} which intuitively is a
    ``01'' unifier. But it is harder to prove than claim it of course, that is why
    we have put all the admitted lemmas of this proofs here. 

 This is a function to build a \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqdoctac{subst}, a subtitution that maps each
    variable to \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}, given an input list of variables. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.lowenheim proof.build T0 subst}{build\_T0\_subst}{\coqdocdefinition{build\_T0\_subst}} (\coqdocvar{lvar} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{v} \ensuremath{\Rightarrow} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{v}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}) \coqdocvariable{lvar}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Next is a function to build a \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqdoctac{subst}, given an input term \textit{t}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.lowenheim proof.build T0 subst from t}{build\_T0\_subst\_from\_t}{\coqdocdefinition{build\_T0\_subst\_from\_t}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim proof.build T0 subst}{\coqdocdefinition{build\_T0\_subst}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
With the following four helper functions, we are trying to create a final
    function that does the following: 1) Given any substituion, it produces a
    ``01'' substitution building off the given substitution. 2) It does that by
    composing two substitutions \coqdocvariable{s1} and \coqdocvar{s1b} into a new one, \coqdocvariable{s2}. 3) It
    creates \coqdocvar{s1b} from \coqdocvariable{s1}. \coqdocvar{s1b} is a ``01'' unifier and so is \coqdocvariable{s2}. 

 Here is the function to create the \coqdocvar{s1b} ``01'' substitution, by mapping all
    the second parts of each replacement of the substitution using the following
    rules: 1) All the variables of non-ground terms are mapped to \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} and all
    ground terms are mapped to their simplified ``01'' version. Therefore the
    substitution occuring from this function is a ``01'' subtitutition,
    intuitively. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.lowenheim proof.make unif subst}{make\_unif\_subst}{\coqdocdefinition{make\_unif\_subst}} (\coqdocvar{tau} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{0.50em}
\coqdockw{match} \coqdocvariable{tau} \coqdockw{with}\coqdoceol
\coqdocindent{0.50em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{0.50em}
\ensuremath{|} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdoctac{first} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{second}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{rest'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{if} \coqref{B Unification.terms.is ground term}{\coqdocdefinition{is\_ground\_term}} \coqdocvar{second}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{then} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdoctac{first}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} \coqdocvar{second}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}} \coqdocvar{rest'}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{else} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.lowenheim proof.build T0 subst from t}{\coqdocdefinition{build\_T0\_subst\_from\_t}} \coqdocvar{second}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}} \coqdocvar{rest'}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocnoindent
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This function creates a list of identity replacements, for all the variables
    of the \coqdocvariable{lvar} list input that are not in \coqdocvariable{lvar\_s} list input. The \coqdocvariable{lvar\_s}
    list input is supposedly the list with the variables of a subtitution and we
    are trying eventually to augment the substitution with and identity
    subtitution. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.lowenheim proof.augment with id}{augment\_with\_id}{\coqdocdefinition{augment\_with\_id}} (\coqdocvar{lvar\_s} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{lvar} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{lvar} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{v} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{v'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{if} \coqref{B Unification.terms.var set includes var}{\coqdocdefinition{var\_set\_includes\_var}} \coqdocvar{v} \coqdocvariable{lvar\_s}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{then} \coqref{B Unification.lowenheim proof.augment with id}{\coqdocdefinition{augment\_with\_id}} \coqdocvariable{lvar\_s} \coqdocvar{v'}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{else} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{v}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{v}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.lowenheim proof.augment with id}{\coqdocdefinition{augment\_with\_id}} \coqdocvariable{lvar\_s} \coqdocvar{v'}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This function adds the identity substitution (or list of identity
    replacements in this case) to the input subsitution. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.lowenheim proof.add id subst}{add\_id\_subst}{\coqdocdefinition{add\_id\_subst}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{tau} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim proof.augment with id}{\coqdocdefinition{augment\_with\_id}} (\coqref{B Unification.terms.subst domain}{\coqdocdefinition{subst\_domain}} \coqdocvariable{tau}) (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t}) \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{tau}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is the resulting function that given any subsitution for a term,
    produces a ``01'' subsitution. Even though this function is not directly
    called by name, its implementation is directly used. So whenever in the
    future comments there is a reference to a \coqref{B Unification.lowenheim proof.convert to 01 subst}{\coqdocdefinition{convert\_to\_01\_subst}}, what is
    meant is essentially the composition of the \coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}} substitution
    and the input subsitution \coqdocvariable{tau} - or the resulting substitution \coqdocvariable{s2}, by
    composing \coqdocvariable{s1} and \coqdocvar{s1b}. 

 In this function, \coqdocvar{sig1b} is the (make\_unif\_subst (add\_id\_subst t tau)),
    \coqdocvariable{sig1} is the (add\_id\_subst t tau), \coqdocvariable{tau} is the original input unifier and
    \coqdocvariable{sig2} is the result of this function which basically composes \coqdocvar{sig1b} with
    \coqdocvariable{sig1}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.lowenheim proof.convert to 01 subst}{convert\_to\_01\_subst}{\coqdocdefinition{convert\_to\_01\_subst}} (\coqdocvar{tau} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}) (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} (\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}} (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvariable{t} \coqdocvariable{tau})) (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvariable{t} \coqdocvariable{tau}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The following lemmas are about facts for the ``01'' subtitutions and our
    \coqref{B Unification.lowenheim proof.convert to 01 subst}{\coqdocdefinition{convert\_to\_01\_subst}} function which gives \coqdocvariable{sig2}. These lemmas are the ones
    that prove the facts that the new \coqdocvariable{sig2} supposedly has: that it is a
    unifier, and also a ``01'' unifier. As stated at the very beggining of this
    section, these lemmmas are very important for the intermediate lemmas
    section where in the \coqref{B Unification.poly unif.unifiable}{\coqdocdefinition{unifiable}} \coqref{B Unification.poly.MonoOrder.t}{\coqdocdefinition{t}} case we are trying to prove that when
    there exists any substitution for a term \textit{t}, then there exists a ``01''
    substitution; the \coqref{B Unification.lowenheim proof.unif some subst}{\coqdoclemma{unif\_some\_subst}} lemma. 

 This is an intuitive lemma that states that adding an identity subsitution
    to an existing unifier of a term gives also a unifier. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.add id unf}{add\_id\_unf}{\coqdoclemma{add\_id\_unf}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{sig1} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{sig1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvariable{t} \coqdocvariable{sig1}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{sig1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} *. \coqdoctac{simpl} \coqdoctac{in} *. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} *. \coqdoctac{simpl} \coqdoctac{in} *. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} *. \coqdoctac{simpl} \coqdoctac{in} *. \coqdoctac{destruct} \coqexternalref{Nat.eqb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{PeanoNat.Nat.eqb}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} *. \coqdoctac{simpl} \coqdoctac{in} *. \coqdoctac{unfold} \coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}}. \coqdoctac{simpl}.\coqdoceol
\coqdocnoindent
\coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This lemma states two facts, given a term \textit{t} and a unifier \coqdocvariable{sig1} of \textit{t}:
    1) The \coqref{B Unification.lowenheim proof.convert to 01 subst}{\coqdocdefinition{convert\_to\_01\_subst}} substitution is also a unifier. 2) Applying the
    \coqref{B Unification.lowenheim proof.convert to 01 subst}{\coqdocdefinition{convert\_to\_01\_subst}} substitution on the term results in a term that is
    ground. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.unif grnd unif}{unif\_grnd\_unif}{\coqdoclemma{unif\_grnd\_unif}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{sig1} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{sig1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} (\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} (\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}} (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvariable{t} \coqdocvariable{sig1}))\coqdoceol
\coqdocindent{14.00em}
(\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvariable{t} \coqdocvariable{sig1}))\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{B Unification.terms.is ground term}{\coqdocdefinition{is\_ground\_term}}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvariable{t} (\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} (\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}} (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvariable{t} \coqdocvariable{sig1}))\coqdoceol
\coqdocindent{17.00em}
(\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvariable{t} \coqdocvariable{sig1})))\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.lowenheim proof.subst compose eqv}{\coqdocaxiom{subst\_compose\_eqv}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.add id unf}{\coqdocaxiom{add\_id\_unf}}. \coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{t} \coqdocvar{sig1}). \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{H}). \coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdocvar{admit}.\coqdoceol
\coqdocnoindent
\coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If a subsitution \coqdocvariable{sig1} is a ``01'' substitution and the domain of the
    substitution is a subset of a list of variable \coqdocvariable{l1} then the substitution
    \coqdocvariable{sig1} is an element of the set of all ``01'' substitutions of that list \coqdocvariable{l1}.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof. 01 in all}{\_01\_in\_all}{\coqdoclemma{\_01\_in\_all}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l1} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.terms.var}{\coqdocdefinition{var}}) (\coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.is 01 subst}{\coqdocdefinition{is\_01\_subst}} \coqdocvariable{sig} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{B Unification.terms.sub dmn list}{\coqdocdefinition{sub\_dmn\_list}} \coqdocvariable{l1} (\coqref{B Unification.terms.subst domain}{\coqdocdefinition{subst\_domain}} \coqdocvariable{sig}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{sig} (\coqref{B Unification.lowenheim formula.all 01 substs}{\coqdocdefinition{all\_01\_substs}} \coqdocvariable{l1}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.terms.is 01 subst}{\coqdocdefinition{is\_01\_subst}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is a specialized format of the \coqref{B Unification.lowenheim proof. 01 in all}{\coqdoclemma{\_01\_in\_all}} lemma. Instead of \coqdocvariable{l1} we
    have \coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqref{B Unification.poly.MonoOrder.t}{\coqdocdefinition{t}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof. 01 in rec}{\_01\_in\_rec}{\coqdoclemma{\_01\_in\_rec}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.is 01 subst}{\coqdocdefinition{is\_01\_subst}} \coqdocvariable{sig} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.sub dmn list}{\coqdocdefinition{sub\_dmn\_list}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t}) (\coqref{B Unification.terms.subst domain}{\coqdocdefinition{subst\_domain}} \coqdocvariable{sig}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{sig} (\coqref{B Unification.lowenheim formula.all 01 substs}{\coqdocdefinition{all\_01\_substs}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof. 01 in all}{\coqdocaxiom{\_01\_in\_all}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H0} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvar{t}) \coqdocvar{sig}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is a lemma to show that given a unifier \coqdocvariable{sig1} of \textit{t}, then the
    \coqref{B Unification.lowenheim proof.convert to 01 subst}{\coqdocdefinition{convert\_to\_01\_subst}} subtitution is a ``01'' subst and also the variables of
    term \textit{t} are a subset of the domain of the \coqref{B Unification.lowenheim proof.convert to 01 subst}{\coqdocdefinition{convert\_to\_01\_subst}}
    substitution. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.make unif is 01}{make\_unif\_is\_01}{\coqdoclemma{make\_unif\_is\_01}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{sig1} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{sig1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.is 01 subst}{\coqdocdefinition{is\_01\_subst}} (\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} (\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}} (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvariable{t} \coqdocvariable{sig1}))\coqdoceol
\coqdocindent{14.50em}
(\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvariable{t} \coqdocvariable{sig1})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.sub dmn list}{\coqdocdefinition{sub\_dmn\_list}}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t})\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.terms.subst domain}{\coqdocdefinition{subst\_domain}} (\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} (\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}} (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvariable{t} \coqdocvariable{sig1}))\coqdoceol
\coqdocindent{16.50em}
(\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvariable{t} \coqdocvariable{sig1}))).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocnoindent
\coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma to show that given a unifier of term \textit{t}, then there exists
    a substitution \coqdocvariable{sig2} that 1) belongs to all the ``01'' substitutions of term
    \textit{t} and it also unifies \textit{t}, by making \textit{t} equal to \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} when applied on it
    (it is equal, not just equivalent because we want \coqdocvariable{sig2} to be a ground
    substitution too). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.unif exists grnd unif}{unif\_exists\_grnd\_unif}{\coqdoclemma{unif\_exists\_grnd\_unif}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{sig1} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{sig1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sig2} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{sig2} (\coqref{B Unification.lowenheim formula.all 01 substs}{\coqdocdefinition{all\_01\_substs}} (\coqref{B Unification.terms.term unique vars}{\coqdocdefinition{term\_unique\_vars}} \coqdocvariable{t})) \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} \coqdocvariable{t} \coqdocvariable{sig2} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{\ensuremath{\exists}} (\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} (\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}} (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1}))\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1})). \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof. 01 in rec}{\coqdoclemma{\_01\_in\_rec}} \coqdockw{as} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H1} \coqdocvar{t} (\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} (\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}} (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1}))\coqdoceol
\coqdocindent{3.00em}
(\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1}))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.make unif is 01}{\coqdocaxiom{make\_unif\_is\_01}} \coqdockw{as} \coqdocvar{H2}. \coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{t} \coqdocvar{sig1}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{H}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H1} \coqdocvar{H2}). \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.unif grnd unif}{\coqdocaxiom{unif\_grnd\_unif}}. \coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{t} \coqdocvar{sig1} \coqdocvar{H}). \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.simplify eqv}{\coqdoclemma{simplify\_eqv}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H2} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t} (\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} (\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}}\coqdoceol
\coqdocindent{3.00em}
(\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1})) (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1})))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.trans compat2}{\coqdoclemma{trans\_compat2}}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H3} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t} (\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} (\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}}\coqdoceol
\coqdocindent{3.00em}
(\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1})) (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1}))) (\coqref{B Unification.terms.simplify}{\coqdocdefinition{simplify}} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t}\coqdoceol
\coqdocindent{3.00em}
(\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} (\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}} (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1}))\coqdoceol
\coqdocindent{3.00em}
(\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1}))))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H3} \coqdocvar{H0} \coqdocvar{H2}). \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H3}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.simplify eq T0}{\coqdocaxiom{simplify\_eq\_T0}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H4} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} \coqdocvar{t} (\coqref{B Unification.terms.subst compose}{\coqdocdefinition{subst\_compose}} (\coqref{B Unification.lowenheim proof.make unif subst}{\coqdocdefinition{make\_unif\_subst}}\coqdoceol
\coqdocindent{3.00em}
(\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1})) (\coqref{B Unification.lowenheim proof.add id subst}{\coqdocdefinition{add\_id\_subst}} \coqdocvar{t} \coqdocvar{sig1})))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{rewrite} \coqdocvar{H4}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{split}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Intermediate Lemmas}



 In this subsection we prove a series of lemmas for each of the two
    statements of the final proof, which were: 1) if a term is unifiable, then
    the \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} function produces a most general unifier (mgu). 2) if a
    term is not unifiable, then \coqdocvar{Lownheim\_Main} function produces a \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}
    substitution. 

\subsubsection{Not unifiable \textit{t} case}



 In this section we prove intermediate lemmas useful for the second statement
    of the final proof: if a term is not unifiable, then \coqdocvar{Lownheim\_Main}
    function produces a \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} substitution. 

 This is a lemma to show that if \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} returns \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdoctac{subst}, the
    term is unifiable. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.some subst unifiable}{some\_subst\_unifiable}{\coqdoclemma{some\_subst\_unifiable}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sig}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{sig1} \coqdocvar{H1}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}}. \coqdoctac{\ensuremath{\exists}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{inversion} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{sig1}. \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{find some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{find\_some}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{remember} (\coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{v}) \coqdocvar{sig1}) \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} \coqdoctac{in} \coqdocvar{Heqt}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.simplify eqv}{\coqdoclemma{simplify\_eqv}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{specialize} (\coqdocvar{H1} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{v}) \coqdocvar{sig1}) ). \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Heqt}. \coqdoctac{rewrite} \coqdocvar{Heqt} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{sig1}. \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{find some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{find\_some}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{remember} (\coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvar{t2}) \coqdocvar{sig1}) \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} \coqdoctac{in} \coqdocvar{Heqt}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.simplify eqv}{\coqdoclemma{simplify\_eqv}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{specialize} (\coqdocvar{H1} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvar{t2}) \coqdocvar{sig1})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Heqt}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}. \coqdoctac{rewrite} \coqdocvar{Heqt} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{sig1}. \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{find some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{find\_some}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{remember} (\coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{t2}) \coqdocvar{sig1}) \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} \coqdoctac{in} \coqdocvar{Heqt}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.simplify eqv}{\coqdoclemma{simplify\_eqv}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{specialize} (\coqdocvar{H1} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{t2}) \coqdocvar{sig1})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Heqt}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}. \coqdoctac{rewrite} \coqdocvar{Heqt} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This lemma shows that if no substituion makes \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} to return
    \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdoctac{subst}, the it returns \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.not Some is None}{not\_Some\_is\_None}{\coqdoclemma{not\_Some\_is\_None}} (\coqdocvar{t}: \coqref{B Unification.terms.term}{\coqdocinductive{term}}) :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sig}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.lowenheim proof.contrapositive opposite}{\coqdoclemma{contrapositive\_opposite}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.lowenheim proof.not None is Some}{\coqdoclemma{not\_None\_is\_Some}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{tauto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is a lemma to show that if a term \textit{t} is not unifiable, the
    \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function returns \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} with \textit{t} as input. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.not unifiable find unifier none subst}{not\_unifiable\_find\_unifier\_none\_subst}{\coqdoclemma{not\_unifiable\_find\_unifier\_none\_subst}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} \coqdocvariable{t} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.some subst unifiable}{\coqdoclemma{some\_subst\_unifiable}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{t}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.contrapositive}{\coqdoclemma{contrapositive}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H1} (\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvar{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig}) (\coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} \coqdocvar{t})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H1} \coqdocvar{H0}). \coqdoctac{specialize} (\coqdocvar{H1} \coqdocvar{H}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.not Some is None}{\coqdoclemma{not\_Some\_is\_None}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{t} \coqdocvar{H1}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H2}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Unifiable \textit{t} Case}



 In this secton we prove intermediate lemmas useful for the first statement
    of the final proof: if a term is unifiable, then \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} function
    produces a most general unifier (mgu). 

 Lemma to show that if \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} on an input term \textit{t} returns
    \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} $\sigma$, then $\sigma$ is a unifier of \textit{t}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.Some subst unifiable}{Some\_subst\_unifiable}{\coqdoclemma{Some\_subst\_unifiable}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}) (\coqdocvar{sig} : \coqref{B Unification.terms.subst}{\coqdocdefinition{subst}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{sig}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.lowenheim proof.eq some eq subst}{\coqdoclemma{eq\_some\_eq\_subst}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{find some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{find\_some}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{remember} (\coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{v}) \coqdocvar{sig}) \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}. \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} \coqdoctac{in} \coqdocvar{Heqt}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.simplify eqv}{\coqdoclemma{simplify\_eqv}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{specialize} (\coqdocvar{H1} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{v}) \coqdocvar{sig}) ). \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Heqt}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Heqt} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{find some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{find\_some}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{remember} (\coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvar{t2}) \coqdocvar{sig}) \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}. \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} \coqdoctac{in} \coqdocvar{Heqt}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.simplify eqv}{\coqdoclemma{simplify\_eqv}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{specialize} (\coqdocvar{H1} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvar{t2}) \coqdocvar{sig}) ). \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Heqt}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Heqt} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{find some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{find\_some}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{remember} (\coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{t2}) \coqdocvar{sig}) \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{t}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}. \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.update term}{\coqdocdefinition{update\_term}} \coqdoctac{in} \coqdocvar{Heqt}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.simplify eqv}{\coqdoclemma{simplify\_eqv}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{specialize} (\coqdocvar{H1} (\coqref{B Unification.terms.apply subst}{\coqdocdefinition{apply\_subst}} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{t2}) \coqdocvar{sig}) ). \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Heqt}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Heqt} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This lemma is the one using all the utilities defined in the ``utilities
    and admitted lemmas...'' section for the \coqref{B Unification.poly unif.unifiable}{\coqdocdefinition{unifiable}} \coqref{B Unification.poly.MonoOrder.t}{\coqdocdefinition{t}} case. It states that
    if there is a unifier \coqdocvariable{sig1} for term \textit{t} then there exists some
    substitution \coqdocvariable{sig2} for which the \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function returns
    \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig2}. Here is the main outline of the proof: As done in the utilities
    section, given any unifier \coqdocvariable{sig1} of a term \textit{t}, we can find a ``01'' unifier.
    Since our \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function also finds a ``01'' unifier by going through
    the list of available ``01'' unifiers, there must exist a ``01'' unifier \coqdocvariable{sig2}
    returned by our \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} function under the \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} wrapper. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.unif some subst}{unif\_some\_subst}{\coqdoclemma{unif\_some\_subst}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t}: \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sig1}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{sig1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sig2}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{t} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{\ensuremath{\exists}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.terms.T1 not equiv T0}{\coqdocaxiom{T1\_not\_equiv\_T0}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.lowenheim proof.existsb find}{\coqdoclemma{existsb\_find}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{existsb exists}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{existsb\_exists}}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.unif exists grnd unif}{\coqdoclemma{unif\_exists\_grnd\_unif}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H0} (\coqref{B Unification.terms.VAR}{\coqdocconstructor{VAR}} \coqdocvar{v}) \coqdocvar{x}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.lowenheim proof.existsb find}{\coqdoclemma{existsb\_find}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{existsb exists}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{existsb\_exists}}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.unif exists grnd unif}{\coqdoclemma{unif\_exists\_grnd\_unif}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H0} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '+' x}{\coqdocnotation{+}} \coqdocvar{t2}) \coqdocvar{x}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.lowenheim proof.existsb find}{\coqdoclemma{existsb\_find}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{existsb exists}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{existsb\_exists}}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.unif exists grnd unif}{\coqdoclemma{unif\_exists\_grnd\_unif}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H0} (\coqdocvar{t1} \coqref{B Unification.terms.:::x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{t2}) \coqdocvar{x}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is a lemma to show that if no substituion makes \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} return
    \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} $\sigma$, then it returns \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.not Some not unifiable}{not\_Some\_not\_unifiable}{\coqdoclemma{not\_Some\_not\_unifiable}} (\coqdocvar{t}: \coqref{B Unification.terms.term}{\coqdocinductive{term}}) :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sig}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.not Some is None}{\coqdoclemma{not\_Some\_is\_None}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{t} \coqdocvar{H}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.unif some subst}{\coqdoclemma{unif\_some\_subst}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{t} \coqdocvar{H1}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H} \coqdocvar{H2}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This lemma shows that if a term is unifiable then \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} returns
    \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} $\sigma$. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.unifiable find unifier some subst}{unifiable\_find\_unifier\_some\_subst}{\coqdoclemma{unifiable\_find\_unifier\_some\_subst}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} \coqdocvariable{t} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sig}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.contrapositive}{\coqdoclemma{contrapositive}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H0} (\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sig}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvar{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{sig}) (\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} \coqdocvar{t})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.not Some not unifiable}{\coqdoclemma{not\_Some\_not\_unifiable}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H1} \coqdocvar{t}). \coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{H1}). \coqdoctac{apply} \coqexternalref{NNPP}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Logic.Classical\_Prop}{\coqdoclemma{NNPP}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{firstorder}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This lemma shows that if a term is unifiable, then \coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} returns a
    unifier. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.find unifier is unifier}{find\_unifier\_is\_unifier}{\coqdoclemma{find\_unifier\_is\_unifier}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} \coqdocvariable{t} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} (\coqref{B Unification.lowenheim proof.convert to subst}{\coqdocdefinition{convert\_to\_subst}} (\coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.unifiable find unifier some subst}{\coqdoclemma{unifiable\_find\_unifier\_some\_subst}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{t} \coqdocvar{H}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}}. \coqdoctac{unfold} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{simpl}. \coqdoctac{unfold} \coqref{B Unification.lowenheim proof.convert to subst}{\coqdocdefinition{convert\_to\_subst}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H0} \coqdockw{as} [\coqdocvar{sig} \coqdocvar{H0}]. \coqdoctac{rewrite} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.Some subst unifiable}{\coqdoclemma{Some\_subst\_unifiable}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H1} \coqdocvar{t} \coqdocvar{sig}). \coqdoctac{specialize} (\coqdocvar{H1} \coqdocvar{H0}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Gluing Everything Together For the Final Proof}



 In this subsection we prove the two top-level final proof lemmas. Both of
    these proofs use the intermediate lemmas proved in the previous subsections.
    

 The first one states that given a uniable term \textit{t} and the fact that our
    Lowenheim builder produces an mgu, then the \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} function
    also produces an mgu. This is the part of the final proof for
    \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} that uses the building block that was provided by the
    previous section where we had proved that our ``lowenheim's builder'' produces
    an mgu given a unifiable term \textit{t}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.builder to main}{builder\_to\_main}{\coqdoclemma{builder\_to\_main}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} : \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} \coqdocvariable{t} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}} \coqdocvariable{t} (\coqref{B Unification.lowenheim formula.build lowenheim subst}{\coqdocdefinition{build\_lowenheim\_subst}}\coqdoceol
\coqdocindent{13.50em}
\coqdocvariable{t} (\coqref{B Unification.lowenheim proof.convert to subst}{\coqdocdefinition{convert\_to\_subst}} (\coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvariable{t}))) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}} \coqdocvariable{t} (\coqref{B Unification.lowenheim proof.convert to subst}{\coqdocdefinition{convert\_to\_subst}} (\coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} \coqdocvariable{t})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.lowenheim most general unifier}{\coqdoclemma{lowenheim\_most\_general\_unifier}} \coqdockw{as} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.find unifier is unifier}{\coqdoclemma{find\_unifier\_is\_unifier}} \coqdockw{as} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H2} \coqdocvar{t} \coqdocvar{H}). \coqdoctac{specialize} (\coqdocvar{H1} \coqdocvar{t} (\coqref{B Unification.lowenheim proof.convert to subst}{\coqdocdefinition{convert\_to\_subst}} (\coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvar{t}))).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{specialize} (\coqdocvar{H1} \coqdocvar{H2}). \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}}. \coqdoctac{destruct} (\coqref{B Unification.lowenheim formula.find unifier}{\coqdocdefinition{find\_unifier}} \coqdocvar{t}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{unfold} \coqref{B Unification.terms.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{apply} \coqref{B Unification.lowenheim proof.app subst T0}{\coqdoclemma{app\_subst\_T0}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.terms.most general unifier compat}{\coqdoclemma{most\_general\_unifier\_compat}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H3} \coqdocvar{t} \coqref{B Unification.terms.T0}{\coqdocconstructor{T0}} \coqdocvar{H2}). \coqdoctac{specialize} (\coqdocvar{H3} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H3}. \coqdoctac{unfold} \coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}}. \coqdoctac{intros}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.terms.more general substitution}{\coqdocdefinition{more\_general\_substitution}}. \coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.lowenheim proof.empty subst on term}{\coqdoclemma{empty\_subst\_on\_term}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{intros}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{s'}. \coqdoctac{unfold} \coqref{B Unification.terms.substitution factor through}{\coqdocdefinition{substitution\_factor\_through}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is the final top-level lemma that encapsulates all our efforts so far.
    It proves the two main statements required for the final proof. The two
    statements, as phrased in the beginning of the chapter are: 1) If a term is
    unifiable, then our own defined \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} function produces a most
    general unifier (mgu). 2) If a term is not unifiable, then our own defined
    \coqdocvar{Lownheim\_Main} function produces a \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} substitution. The two
    propositions are related with the ``$\wedge$'' symbol (namely, the
    propositional ``and'') and each is proven seperately using the intermediate
    lemmas proven in the previous section. This is why the final top-level proof
    is relatively short, because a lot of the significant components of the
    proof have already been proven as intermediate lemmas and in previous helper
    sections. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.lowenheim proof.lowenheim main most general unifier}{lowenheim\_main\_most\_general\_unifier}{\coqdoclemma{lowenheim\_main\_most\_general\_unifier}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t}: \coqref{B Unification.terms.term}{\coqdocinductive{term}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} \coqdocvariable{t} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.terms.most general unifier}{\coqdocdefinition{most\_general\_unifier}} \coqdocvariable{t} (\coqref{B Unification.lowenheim proof.convert to subst}{\coqdocdefinition{convert\_to\_subst}} (\coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} \coqdocvariable{t}))\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{B Unification.terms.unifiable}{\coqdocdefinition{unifiable}} \coqdocvariable{t} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}} \coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{apply} \coqref{B Unification.lowenheim proof.builder to main}{\coqdoclemma{builder\_to\_main}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.lowenheim proof.lowenheim most general unifier}{\coqdoclemma{lowenheim\_most\_general\_unifier}}. \coqdoctac{apply} \coqref{B Unification.lowenheim proof.find unifier is unifier}{\coqdoclemma{find\_unifier\_is\_unifier}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{pose} \coqdocvar{proof} \coqref{B Unification.lowenheim proof.not unifiable find unifier none subst}{\coqdoclemma{not\_unifiable\_find\_unifier\_none\_subst}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{specialize} (\coqdocvar{H0} \coqdocvar{t} \coqdocvar{H}). \coqdoctac{unfold} \coqref{B Unification.lowenheim formula.Lowenheim Main}{\coqdocdefinition{Lowenheim\_Main}}. \coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{B Unification.list util}{Library }{B\_Unification.list\_util}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclibrary{List}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Arith}{\coqdoclibrary{Arith}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{Nat}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorting}{\coqdoclibrary{Sorting}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclibrary{Permutation}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.omega.Omega}{\coqdoclibrary{Omega}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Introduction}



 The second half of the project revolves around the successive variable 
    elimination algorithm for solving unification problems. While we could
    implement this algorithm with the same data structures used for Lowenheim's,
    this algorithm lends itself well to a new representation of terms as
    polynomials.


    A \textit{polynomial} is a list of monomials being added together, where a
    \textit{monomial} is a list of variables being multiplied together. Since one of
    the rules is that $x \ast x \approx_{B} x$, we can guarantee that there are
    no repeated variables in any given monomial. Similarly, because
    $x + x \approx_{B} 0$, we can guarantee that there are no repeated monomials
    in a polynomial.


    Because of these properties, as well as the commutativity of addition and
    multiplication, we can represent both monomials and polynomials as
    unordered sets of variables and monomials, respectively. For simplicity
    when implementing and comparing these polynomials in Coq, we have opted
    to use the standard list structure, instead maintaining that the lists
    are maintained in our polynomial form after each stage.


    In order to effectively implement polynomial lists in this way, a set of
    utilities are needed to allow us to easily perform operations on these
    lists. This file serves to implement and prove facts about these functions,
    as well as to expand upon the standard library when necessary. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Comparisons Between Lists}



 Checking if a list of natural numbers is sorted is easy enough. Comparing
    lists of lists of nats is slightly harder, and requires the use of a new
    function, called \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}}. \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} simply takes in a comparison and applies
    the comparison across the list until it finds a point where the elements
    are not equal.


    In all cases throughout this project, the comparator used will be the
    standard nat \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} function.


    For example, [1;2;3] is less than [1;2;4], and [1;2] is greater than
    [1]. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.list util.lex}{lex}{\coqdocdefinition{lex}} \{\coqdocvar{T}\} (\coqdocvar{cmp}:\coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{comparison}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{comparison}}) (\coqdocvar{l1} \coqdocvar{l2}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{T}) : \coqexternalref{comparison}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{comparison}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l1}, \coqdocvariable{l2} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}, \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{Eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Eq}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}, \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{Lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Lt}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{\_}, \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{Gt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Gt}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h1} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{t1}, \coqdocvar{h2} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{t2} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{match} \coqdocvariable{cmp} \coqdocvar{h1} \coqdocvar{h2} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqexternalref{Eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Eq}} \ensuremath{\Rightarrow} \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqdocvariable{cmp} \coqdocvar{t1} \coqdocvar{t2}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{c} \ensuremath{\Rightarrow} \coqdocvar{c}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
There are some important but relatively straightforward properties of this
    function that are useful to prove. First, \textit{reflexivity}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.lex nat refl}{lex\_nat\_refl}{\coqdoclemma{lex\_nat\_refl}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l}, \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{l} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Eq}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqexternalref{Nat.compare refl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_refl}}. \coqdoctac{apply} \coqdocvar{IHl}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Next, \textit{antisymmetry}. This allows us to take a predicate or hypothesis about
    the comparison of two polynomials and reverse it.


    For example, \coqdocvariable{l} < \coqdocvariable{m} implies \coqdocvariable{m} > \coqdocvariable{l}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.lex nat antisym}{lex\_nat\_antisym}{\coqdoclemma{lex\_nat\_antisym}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{CompOpp}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{CompOpp}} (\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{m} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{m}; \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{m}; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqdocvar{a} \coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}} \coqdocvar{n}) \coqdocvar{eqn}:\coqdocvar{H}; \coqdoctac{rewrite} \coqexternalref{Nat.compare antisym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_antisym}} \coqdoctac{in} \coqdocvar{H};\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqexternalref{CompOpp iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdoclemma{CompOpp\_iff}} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{rewrite} \coqdocvar{H}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It is also useful to convert from the result of \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} to a
    hypothesis about equality in Coq. Clearly, if \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} returns \coqexternalref{Eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Eq}},
    the lists are exactly equal, and if it returns \coqexternalref{Lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Lt}} or \coqexternalref{Gt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Gt}} they are not. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.lex eq}{lex\_eq}{\coqdoclemma{lex\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Eq}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{induction} \coqdocvar{m}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{split}; \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{split}; \coqdoctac{intros}; \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{split}; \coqdoctac{intros}; \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{split}; \coqdoctac{intros}; \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} (\coqdocvar{a} \coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}} \coqdocvar{a0}) \coqdocvar{eqn}:\coqdocvar{Hcomp}; \coqdoctac{try} \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Nat.compare eq iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_eq\_iff}} \coqdoctac{in} \coqdocvar{Hcomp}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqexternalref{Nat.compare refl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_refl}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H2}. \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.lex neq}{lex\_neq}{\coqdoclemma{lex\_neq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Lt}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Gt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Gt}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{l} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{induction} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{split}; \coqdoctac{intro}. \coqdoctac{inversion} \coqdocvar{H}; \coqdoctac{inversion} \coqdocvar{H0}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{split}; \coqdoctac{intro}. \coqdoctac{intro}. \coqdoctac{inversion} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{split}; \coqdoctac{intro}. \coqdoctac{intro}. \coqdoctac{inversion} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{clear} \coqdocvar{IHm}. \coqdoctac{split}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{H}; \coqdoctac{intro}; \coqdoctac{apply} \coqref{B Unification.list util.lex eq}{\coqdoclemma{lex\_eq}} \coqdoctac{in} \coqdocvar{H0}; \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H0}; \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} (\coqdocvar{a} \coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}} \coqdocvar{a0}) \coqdocvar{eqn}:\coqdocvar{Hcomp}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{Hcomp}. \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqexternalref{Nat.compare eq iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_eq\_iff}} \coqdoctac{in} \coqdocvar{Hcomp}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqdocvar{Hcomp} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{intro}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{left}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{Hcomp}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{right}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{Hcomp}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.lex neq'}{lex\_neq'}{\coqdoclemma{lex\_neq'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Lt}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{l} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{m}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Gt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Gt}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{l} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{m}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{m}. \coqdoctac{split}; \coqdoctac{repeat} (\coqdoctac{intros}; \coqdoctac{apply} \coqref{B Unification.list util.lex neq}{\coqdoclemma{lex\_neq}}; \coqdoctac{auto}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It is also useful to be able to flip the arguments of a call to
    \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}}, since these two comparisons impact each other directly.


    If \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} returns that \coqdocvariable{l} = \coqdocvariable{m}, then this also means that \coqdocvariable{m} = \coqdocvariable{l}.
    More interesting is that if \coqdocvariable{l} < \coqdocvariable{m}, then \coqdocvariable{m} > \coqdocvariable{l}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.lex rev eq}{lex\_rev\_eq}{\coqdoclemma{lex\_rev\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Eq}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{m} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Eq}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{m}. \coqdoctac{split}; \coqdoctac{intro}; \coqdoctac{rewrite} \coqref{B Unification.list util.lex nat antisym}{\coqdoclemma{lex\_nat\_antisym}} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{unfold} \coqexternalref{CompOpp}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{CompOpp}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvar{m} \coqdocvar{l}) \coqdocvar{eqn}:\coqdocvar{H0}; \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvar{l} \coqdocvar{m}) \coqdocvar{eqn}:\coqdocvar{H0}; \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.lex rev lt gt}{lex\_rev\_lt\_gt}{\coqdoclemma{lex\_rev\_lt\_gt}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Lt}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{m} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Gt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Gt}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{m}. \coqdoctac{split}; \coqdoctac{intro}; \coqdoctac{rewrite} \coqref{B Unification.list util.lex nat antisym}{\coqdoclemma{lex\_nat\_antisym}} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{unfold} \coqexternalref{CompOpp}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{CompOpp}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvar{m} \coqdocvar{l}) \coqdocvar{eqn}:\coqdocvar{H0}; \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvar{l} \coqdocvar{m}) \coqdocvar{eqn}:\coqdocvar{H0}; \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Lastly is a property over lists. The comparison of two lists stays the same
    if the same new element is added onto the front of each list. Similarly, if
    the item at the front of two lists is equal, removing it from both does not
    change the lists' comparison. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.lex nat cons}{lex\_nat\_cons}{\coqdoclemma{lex\_nat\_cons}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{m} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} (\coqdocvariable{n} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}) (\coqdocvariable{n} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqexternalref{Nat.compare refl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_refl}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{lex\_nat\_refl} \coqdocvar{lex\_nat\_antisym} \coqdocvar{lex\_nat\_cons}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Extensions to the Standard Library}



 There were some facts about the standard library list functions that we
    found useful to prove, as they repeatedly came up in proofs of our more
    complex custom list functions.


    Specifically, because we are comparing sorted lists, it is often easier
    to disregard the sortedness of the lists and instead compare them as
    permutations of one another. As a result, many of the lemmas in the
    rest of this file revolve around proving that two lists are permutations
    of one another. 

\subsection{Facts about \texorpdfstring{\protect\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}}}{In}}

\begin{coqdoccode}
\end{coqdoccode}
First, a very simple fact about \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}}. This mostly follows from the standard
    library lemma \coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}}, but is more convenient for some of our
    proofs when formalized like this. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Permutation not In}{Permutation\_not\_In}{\coqdoclemma{Permutation\_not\_In}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l} \coqdocvar{l'},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{l'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{a} \coqdocvar{l} \coqdocvar{l'} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{intro}. \coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdocvar{a}) \coqdoctac{in} \coqdocvar{H}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Something else that seems simple but proves very useful to know is that if
    there are no elements in a list, that list must be empty. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nothing in empty}{nothing\_in\_empty}{\coqdoclemma{nothing\_in\_empty}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{a}, \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{l}; \coqdoctac{auto}. \coqdoctac{pose} (\coqdocvar{H} \coqdocvar{a}). \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{n}. \coqdocvar{exfalso}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{n}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Facts about \texorpdfstring{\protect\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}}{incl}}

\begin{coqdoccode}
\end{coqdoccode}
Next are some useful lemmas about \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}. First is that if one list is
    included in another, but one element of the second list is not in the first,
    then the first list is still included in the second with that element
    removed. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.incl not in}{incl\_not\_in}{\coqdoclemma{incl\_not\_in}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdocvariable{l} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{m}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdocvariable{l} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{a} \coqdocvar{l} \coqdocvar{m} \coqdocvar{Hincl} \coqdocvar{Hnin}. \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdoctac{in} *. \coqdoctac{intros} \coqdocvar{a0} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hincl}. \coqdoctac{destruct} (\coqdocvar{Hincl} \coqdocvar{a0}); \coqdoctac{auto}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hnin}. \coqdocvar{contradiction}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We also found it useful to relate \coqdoclibrary{Permutation} to \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}; if two lists are
    permutations of each other, then they must be set equivalent, or contain
    all of the same elements. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Permutation incl}{Permutation\_incl}{\coqdoclemma{Permutation\_incl}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} (\coqdocvar{l} \coqdocvar{m}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdocvariable{m} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{l} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} \coqdocvar{H0}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
+ \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}. \coqdoctac{intros} \coqdocvar{a}. \coqdoctac{apply} (\coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdocvar{\_} \coqdocvar{H}).\coqdoceol
\coqdocindent{1.00em}
+ \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}. \coqdoctac{intros} \coqdocvar{a}. \coqdoctac{apply} (\coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdocvar{\_} \coqdocvar{H0}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Unfortunately, the definition above cannot be changed into an iff
    relation, as \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} proves nothing about the lengths of the lists. We can,
    however, prove that if some list \coqdocvariable{m} includes a list \coqdocvariable{l}, then \coqdocvariable{m} includes
    all permutations of \coqdocvariable{l}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.incl Permutation}{incl\_Permutation}{\coqdoclemma{incl\_Permutation}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} (\coqdocvar{l} \coqdocvar{l'} \coqdocvar{m}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{l'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdocvariable{l'} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{l} \coqdocvar{l'} \coqdocvar{m} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{apply} \coqref{B Unification.list util.Permutation incl}{\coqdoclemma{Permutation\_incl}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{incl tran}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{incl\_tran}} \coqdockw{with} (\coqdocvar{m}:=\coqdocvar{l}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A really simple lemma is that if some list \coqdocvariable{l} is included in the empty
    list, then \coqdocvariable{l} must also be empty. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.incl nil}{incl\_nil}{\coqdoclemma{incl\_nil}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{X}\} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdocvariable{l} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{l}. \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}. \coqdoctac{split}; \coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{l}; [\coqdoctac{auto} \ensuremath{|} \coqdoctac{destruct} (\coqdocvar{H} \coqdocvar{x}); \coqdoctac{intuition}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{a} \coqdocvar{Hin}. \coqdoctac{destruct} \coqdocvar{l}; [\coqdoctac{auto} \ensuremath{|} \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hin}; \coqdoctac{auto}].\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The last fact about \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} is simply a new way of formalizing the definition
    that is convenient for some proofs. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.incl cons inv}{incl\_cons\_inv}{\coqdoclemma{incl\_cons\_inv}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}) \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdocvariable{l} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{a} \coqdocvar{l} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdoctac{in} *. \coqdoctac{intros} \coqdocvar{b} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Facts about \texorpdfstring{\protect\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}}}{count\_occ}}

\begin{coqdoccode}
\end{coqdoccode}
Next is some facts about \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}}. Firstly, if two lists are permutations
    of each other, than every element in the first list has the same number of
    occurences in the second list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ Permutation}{count\_occ\_Permutation}{\coqdoclemma{count\_occ\_Permutation}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l} \coqdocvar{l'},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{l'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l} \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l'} \coqdocvariable{a}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l} \coqdocvar{l'} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{x} \coqdocvar{a}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{a}); \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{x} \coqdocvar{a}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHPermutation2}. \coqdoctac{rewrite} \coqdocvar{IHPermutation1}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The function \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} also distributes over list concatenation, instead
    becoming addition. This is useful especially when dealing with count
    occurences of lists during induction. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ app}{count\_occ\_app}{\coqdoclemma{count\_occ\_app}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l} \coqdocvar{m} \coqdocvar{Aeq\_dec},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{l} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{m}) \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Nat.add}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{add}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l} \coqdocvariable{a}) (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{m} \coqdocvariable{a}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{a} \coqdocvar{l} \coqdocvar{m} \coqdocvar{Aeq\_dec}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a0} \coqdocvar{a}); \coqdoctac{simpl}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It is also convenient to reason about the relation between \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} and
    \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}}. If the element being removed is the same as the one being counted,
    then the count is obviously 0. If the elements are different, then the
    count is the same with or without the remove. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ remove}{count\_occ\_remove}{\coqdoclemma{count\_occ\_remove}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{Aeq\_dec} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{l}) \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a0}) \coqdocvar{eqn}:\coqdocvar{Haa0}; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a0} \coqdocvar{a}); \coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}). \coqdoctac{apply} \coqdocvar{IHl}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ neq remove}{count\_occ\_neq\_remove}{\coqdoclemma{count\_occ\_neq\_remove}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{Aeq\_dec} (\coqdocvar{a} \coqdocvar{b}:\coqdocvariable{A}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{a} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{b} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{l}) \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{b} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{simpl}; \coqdoctac{auto}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a0}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a0} \coqdocvar{b}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e0} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a0} \coqdocvar{b}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Facts about \texorpdfstring{\protect\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}}}{concat}}

\begin{coqdoccode}
\end{coqdoccode}
Similarly to the lemma \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}, \coqref{B Unification.list util.Permutation concat}{\coqdoclemma{Permutation\_concat}} shows that
    if two lists are permutations of each other then the flattening of each
    list are also permutations. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Permutation concat}{Permutation\_concat}{\coqdoclemma{Permutation\_concat}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} (\coqdocvar{l} \coqdocvar{m}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} (\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A})),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqdocvariable{l}) (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{l} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{Permutation app head}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_head}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqdocvar{l} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{y} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{x}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}. \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqdocvar{l} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{x} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{y}).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Permutation app head}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_head}}. \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} (\coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}} \coqdocvar{x} \coqdocvar{y}). \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqdocvar{l'}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Before the creation of this next lemma, it was relatively hard to reason
    about whether elements are in the flattening of a list of lists. This lemma
    states that if there is a list in the list of lists that contains the
    desired element, then that element will be in the flattened version. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.In concat exists}{In\_concat\_exists}{\coqdoclemma{In\_concat\_exists}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{ll} (\coqdocvar{a}:\coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{l}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{l} \coqdocvariable{ll} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqdocvariable{ll}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{ll} \coqdocvar{a}. \coqdoctac{split}; \coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{l} []]. \coqdoctac{apply} \coqexternalref{In split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocabbreviation{In\_split}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{l1} [\coqdocvar{l2} \coqdocvar{H}]].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdockw{with} (\coqdocvar{l}:=\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqdocvar{l} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l2})).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.Permutation concat}{\coqdoclemma{Permutation\_concat}}. \coqdoctac{apply} \coqexternalref{Permutation middle}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_middle}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{ll}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{\ensuremath{\exists}} \coqdocvar{a0}. \coqdoctac{split}; \coqdoctac{intuition}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{destruct} \coqdocvar{IHll}; \coqdoctac{auto}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{x}. \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This particular lemma is useful if the function being mapped returns a list
    of its input type. If the resulting lists are flattened after, then the
    result is the same as mapping the function without converting the output to
    lists. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.concat map}{concat\_map}{\coqdoclemma{concat\_map}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f}:\coqdocvariable{A}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{B}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{f} \coqdocvariable{a}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}) \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{f\_equal}. \coqdoctac{apply} \coqdocvar{IHl}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Another fact similar to the last is that if you flatten the result of
    mapping a function that maps a function over a list, we can rearrange the
    order of the \coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} and the \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}s. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.concat map map}{concat\_map\_map}{\coqdoclemma{concat\_map\_map}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{B} \coqdocvar{C} \coqdocvar{l} (\coqdocvar{f}:\coqdocvariable{B}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{C}) (\coqdocvar{g}:\coqdocvariable{A}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{B}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a} \ensuremath{\Rightarrow} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} (\coqdocvariable{g} \coqdocvariable{a})) \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{g} \coqdocvariable{l})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{f\_equal}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Lastly, if you \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} a function that converts every element of a list to
    \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}}, and then \coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} the list of \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}}s, you end with \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.concat map nil}{concat\_map\_nil}{\coqdoclemma{concat\_map\_nil}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}) \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}@\coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \coqdocvariable{A}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Facts about \texorpdfstring{\protect\coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}}}{Forall} and \texorpdfstring{\protect\coqexternalref{existsb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{existsb}}}{existsb}}

\begin{coqdoccode}
\end{coqdoccode}
This is similar to the inverse of \coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}}; any element in a list \coqdocvariable{l} must
    hold for predicate \coqdocvariable{p} if \coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} \coqdocvariable{p} is true of \coqdocvariable{l}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Forall In}{Forall\_In}{\coqdoclemma{Forall\_In}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}) \coqdocvar{a} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} \coqdocvariable{p} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{p} \coqdocvariable{a}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{l} \coqdocvar{a} \coqdocvar{p} \coqdocvar{Hin} \coqdocvar{Hfor}. \coqdoctac{apply} (\coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}} \coqdocvar{p} \coqdocvar{l}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In Coq, \coqexternalref{existsb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{existsb}} is effectively the ``or'' to \coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}}'s ``and'' when reasoning
    about lists. If there does not exist a single element in a list \coqdocvariable{l} where
    the predicate \coqdocvariable{p} holds, then \coqdocvariable{p} \coqdocvariable{a} must be false for any element \coqdocvariable{a} of
    \coqdocvariable{l}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.existsb false forall}{existsb\_false\_forall}{\coqdoclemma{existsb\_false\_forall}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{p} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{existsb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{existsb}} \coqdocvariable{p} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{a}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{p} \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{p} \coqdocvar{l} \coqdocvar{H} \coqdocvar{a} \coqdocvar{Hin}. \coqdoctac{destruct} (\coqdocvar{p} \coqdocvar{a}) \coqdocvar{eqn}:\coqdocvar{Hpa}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{exfalso}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{negb true iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_true\_iff}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqexternalref{eq true false abs}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.eq\_true\_false\_abs}} \coqdocvar{\_} \coqdocvar{H}). \coqdoctac{rewrite} \coqexternalref{negb false iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_false\_iff}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{existsb exists}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{existsb\_exists}}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{a}. \coqdoctac{split}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly to \coqref{B Unification.list util.Forall In}{\coqdoclemma{Forall\_In}}, this lemma is just another way of formalizing the
    definition of \coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} that proves useful when dealing with \coqexternalref{StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{StronglySorted}}
    lists. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Forall cons iff}{Forall\_cons\_iff}{\coqdoclemma{Forall\_cons\_iff}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{p} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} \coqdocvariable{p} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} \coqdocvariable{p} \coqdocvariable{l} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{p} \coqdocvariable{a}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{p} \coqdocvar{a} \coqdocvar{l}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intro} \coqdocvar{H}. \coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}}. \coqdoctac{intros} \coqdocvar{x} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Forall inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_inv}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} []. \coqdoctac{apply} \coqexternalref{Forall cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocconstructor{Forall\_cons}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If a predicate \coqdocvariable{p} holds for all elements of a list \coqdocvariable{l}, then \coqdocvariable{p} still
    holds if some elements are removed from \coqdocvariable{l}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Forall remove}{Forall\_remove}{\coqdoclemma{Forall\_remove}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} \coqdocvariable{p} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} \coqdocvariable{p} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{a} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.Forall cons iff}{\coqdoclemma{Forall\_cons\_iff}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a0}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.list util.Forall cons iff}{\coqdoclemma{Forall\_cons\_iff}}. \coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This next lemma is particularly useful for relating \coqexternalref{StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{StronglySorted}} lists
    to \coqdoclibrary{Sorted} lists; if some relation holds between all elements of a list,
    then this can be converted to the \coqexternalref{HdRel}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{HdRel}} proposition used by \coqdoclibrary{Sorted}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Forall HdRel}{Forall\_HdRel}{\coqdoclemma{Forall\_HdRel}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{X}\} \coqdocvar{r} (\coqdocvar{x}:\coqdocvariable{X}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} (\coqdocvariable{r} \coqdocvariable{x}) \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{HdRel}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{HdRel}} \coqdocvariable{r} \coqdocvariable{x} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{r} \coqdocvar{x} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{l}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{HdRel nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{HdRel\_nil}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{HdRel cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{HdRel\_cons}}. \coqdoctac{apply} \coqexternalref{Forall inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_inv}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Lastly, if some predicate \coqdocvariable{p} holds for all elements in a list \coqdocvariable{l}, and the
    elements of a second list \coqdocvariable{m} are all included in \coqdocvariable{l}, then \coqdocvariable{p} holds for
    all the elements in \coqdocvariable{m}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Forall incl}{Forall\_incl}{\coqdoclemma{Forall\_incl}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{X}\} \coqdocvar{p} (\coqdocvar{l} \coqdocvar{m}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} \coqdocvariable{p} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdocvariable{m} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} \coqdocvariable{p} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{p} \coqdocvar{l} \coqdocvar{m} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{induction} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Forall nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocconstructor{Forall\_nil}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}}. \coqdoctac{intros} \coqdocvar{x} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{H}. \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Facts about \texorpdfstring{\protect\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}}}{remove}}

\begin{coqdoccode}
\end{coqdoccode}
There are surprisingly few lemmas about \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} in the standard library, so
    in addition to those proven in other places, we opted to add quite a few
    simple facts about \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}}. First is that if an element is in a list after
    something has been removed, then clearly it was in the list before as well.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.In remove}{In\_remove}{\coqdoclemma{In\_remove}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{Aeq\_dec} (\coqdocvar{a} \coqdocvar{b}:\coqdocvariable{A}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{b} \coqdocvariable{l}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{b} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [|\coqdocvar{c} \coqdocvar{l} \coqdocvar{IHl}]; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{b} \coqdocvar{c}) \coqdocvar{eqn}:\coqdocvar{Heq}; \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{rewrite} \coqdocvar{Heq} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{right}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{H}; [\coqdoctac{rewrite} \coqdocvar{H}; \coqdoctac{intuition} \ensuremath{|} \coqdoctac{right}; \coqdoctac{auto}].\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly to \coqref{B Unification.list util.Forall remove}{\coqdoclemma{Forall\_remove}}, if a list was \coqexternalref{StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{StronglySorted}} before
    something was removed then it is also \coqexternalref{StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{StronglySorted}} after. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.StronglySorted remove}{StronglySorted\_remove}{\coqdoclemma{StronglySorted\_remove}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{Aeq\_dec} \coqdocvar{r} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{StronglySorted}} \coqdocvariable{r} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{StronglySorted}} \coqdocvariable{r} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{r} \coqdocvar{a} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a0}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{SSorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{SSorted\_cons}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.Forall remove}{\coqdoclemma{Forall\_remove}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If the item being removed from a list isn't in the list, then the list
    is equal with or without the remove. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.not In remove}{not\_In\_remove}{\coqdoclemma{not\_In\_remove}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a0}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H}. \coqdocvar{exfalso}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{IHl}. \coqdoctac{reflexivity}. \coqdoctac{intro} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The function \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} also distributes over list concatenation. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.remove distr app}{remove\_distr\_app}{\coqdoclemma{remove\_distr\_app}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} (\coqdocvariable{l} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{m}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{l} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l} \coqdocvar{m}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a0}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{f\_equal}. \coqdoctac{apply} \coqdocvar{IHl}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
More interestingly, if two lists were permutations before, they are also
    permutations after the same element has been removed from both lists. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.remove Permutation}{remove\_Permutation}{\coqdoclemma{remove\_Permutation}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l} \coqdocvar{l'},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{l'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{l}) (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{l'}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l} \coqdocvar{l'} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{x}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{y}); \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{x}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{perm swap}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_swap}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l'})); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The function \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} is also associative with itself. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.remove remove}{remove\_remove}{\coqdoclemma{remove\_remove}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{Aeq\_dec} (\coqdocvar{a} \coqdocvar{b}:\coqdocvariable{A}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{b} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{b} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{b} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [|\coqdocvar{c}]; \coqdoctac{simpl}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{b}); \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{b} \coqdocvar{c}); \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{c}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e0} \coqdoctac{in} \coqdocvar{n}. \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{n}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e} \coqdoctac{in} \coqdocvar{n}. \coqdoctac{rewrite} \coqdocvar{e0} \coqdoctac{in} \coqdocvar{n}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{c}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{b} \coqdocvar{c}); \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqdocvar{IHl}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{n}. \coqdoctac{rewrite} \coqdocvar{e0} \coqdoctac{in} \coqdocvar{n}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{b} \coqdocvar{c}); \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{c}); \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{c}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{b} \coqdocvar{c}); \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqdocvar{IHl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Lastly, if an element is being removed from a particular list twice, the
    inner \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} is redundant and can be removed. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.remove pointless}{remove\_pointless}{\coqdoclemma{remove\_pointless}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{l} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{m}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdoceol
\coqdocindent{1.00em}
\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} (\coqdocvariable{l} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l} \coqdocvar{m}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a0}) \coqdocvar{eqn}:\coqdocvar{Heq}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{Heq}. \coqdoctac{f\_equal}. \coqdoctac{apply} \coqdocvar{IHl}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Facts about \texorpdfstring{\protect\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}}}{nodup} and \texorpdfstring{\protect\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}}}{NoDup}}

\begin{coqdoccode}
\end{coqdoccode}
Next up - the \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} proposition and the closely related \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} function.
    The first lemma states that if there are no duplicates in a list, then the
    first two elements of that list must not be equal. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.NoDup neq}{NoDup\_neq}{\coqdoclemma{NoDup\_neq}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{l} (\coqdocvar{a} \coqdocvar{b}:\coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{b} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{a} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{l} \coqdocvar{a} \coqdocvar{b} \coqdocvar{Hdup}. \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{Hdup} \coqdockw{as} [].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{H0} \coqdockw{as} []. \coqdoctac{intro}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In a similar vein as many of the other \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} lemmas, if there were no
    duplicates in a list before the \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} then there are still none after. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.NoDup remove}{NoDup\_remove}{\coqdoclemma{NoDup\_remove}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a0}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{NoDup cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocconstructor{NoDup\_cons}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} []. \coqdoctac{intro}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} (\coqref{B Unification.list util.In remove}{\coqdoclemma{In\_remove}} \coqdocvar{Aeq\_dec} \coqdocvar{a0} \coqdocvar{a} \coqdocvar{l} \coqdocvar{H1}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Another lemma similar to \coqref{B Unification.list util.NoDup neq}{\coqdoclemma{NoDup\_neq}} is \coqref{B Unification.list util.NoDup forall neq}{\coqdoclemma{NoDup\_forall\_neq}}; if every element
    in a list is not equal to a certain \coqdocvariable{a}, and the list has no duplicates as
    is, then it is safe to add \coqdocvariable{a} to the list without creating duplicates. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.NoDup forall neq}{NoDup\_forall\_neq}{\coqdoclemma{NoDup\_forall\_neq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} (\coqdockw{fun} \coqdocvar{b} \ensuremath{\Rightarrow} \coqdocvariable{a} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{b}) \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{a} \coqdocvar{l} \coqdocvar{Hf} \coqdocvar{Hn}. \coqdoctac{apply} \coqexternalref{NoDup cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocconstructor{NoDup\_cons}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.Forall cons iff}{\coqdoclemma{Forall\_cons\_iff}} \coqdoctac{in} \coqdocvar{Hf} \coqdockw{as} []. \coqdoctac{apply} \coqdocvar{IHl}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{Hn}. \coqdoctac{apply} \coqdocvar{Hn}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H1}. \coqdocvar{contradiction}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This lemma is really just a reformalization of \coqexternalref{NoDup remove 2}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_remove\_2}}, which
    allows us to easily prove that some \coqdocvariable{a} is not in the preceeding elements
    \coqdocvariable{l1} or the following elements \coqdocvariable{l2} when the whole list \coqdocvariable{l} has no
    duplicates. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.NoDup In split}{NoDup\_In\_split}{\coqdoclemma{NoDup\_In\_split}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l} \coqdocvar{l1} \coqdocvar{l2},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l1} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{a} \coqdocvar{l} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{NoDup remove 2}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_remove\_2}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{split}; \coqdoctac{intro}; \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now some facts about the function \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}}; if the \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} predicate
    is already true about a certain list, then calling \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} on it
    changes nothing. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.no nodup NoDup}{no\_nodup\_NoDup}{\coqdoclemma{no\_nodup\_NoDup}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} []. \coqdoctac{destruct} (\coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{contradiction}. \coqdoctac{f\_equal}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If a list is sorted (with a transitive relation) before calling \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}}
    on it, the list is also sorted after. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Sorted nodup}{Sorted\_nodup}{\coqdoclemma{Sorted\_nodup}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{r} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sets.Relations\_1}{\coqdocdefinition{Relations\_1.Transitive}} \coqdocvariable{r} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvariable{r} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvariable{r} (\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{r} \coqdocvar{l} \coqdocvar{Ht} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{StronglySorted Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_Sorted}}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} []. \coqdoctac{destruct} (\coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{SSorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{SSorted\_cons}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}}. \coqdoctac{intros} \coqdocvar{x} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}} \coqdoctac{in} \coqdocvar{Hin}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can also show that in some cases, if there are repeated calls to \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}},
    they are ``pointless'' - in other words, we can remove the inner call and
    only keep the outer one. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nodup pointless}{nodup\_pointless}{\coqdoclemma{nodup\_pointless}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqexternalref{Nat.eq dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{Nat.eq\_dec}} (\coqdocvariable{l} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqexternalref{Nat.eq dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{Nat.eq\_dec}} \coqdocvariable{m}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqexternalref{Nat.eq dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{Nat.eq\_dec}} (\coqdocvariable{l} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{m}. \coqdoctac{induction} \coqdocvar{l}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.list util.no nodup NoDup}{\coqdoclemma{no\_nodup\_NoDup}}; \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{NoDup nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_nodup}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}; \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdocvar{exfalso}. \coqdoctac{apply} \coqdocvar{n}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{i}; \coqdoctac{destruct} \coqdocvar{i}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{intuition}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdocvar{exfalso}. \coqdoctac{apply} \coqdocvar{n}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{i}; \coqdoctac{destruct} \coqdocvar{i}; \coqdoctac{intuition}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}}. \coqdoctac{right}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{f\_equal}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And lastly, similarly to our other \coqdoclibrary{Permutation} lemmas this far, if two
    lists were permutations of each other before \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} they are also
    permutations after.


    This lemma was slightly more complex than previous \coqdoclibrary{Permutation} lemmas,
    but the proof is still very similar. It is solved by induction on the
    \coqdoclibrary{Permutation} hypothesis. The first and last cases are trivial, and the
    second case (where we must prove \coqdoclibrary{Permutation} (\coqdocvariable{x} :: \coqdocvariable{l}) (\coqdocvariable{x} :: \coqdocvariable{l'})) becomes
    simple with the use of \coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}}.


    The last case (where we must show \coqdoclibrary{Permutation} (\coqdocvariable{x} :: \coqdocvariable{y} :: \coqdocvariable{l}) (\coqdocvariable{y} :: \coqdocvariable{x} :: \coqdocvariable{l}))
    was slightly complicated by the fact that destructing \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}} gives us
    a hypothesis like \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqdocvariable{y} :: \coqdocvariable{l}), which seems useless in reasoning about
    the other list at first. However, by also destructing whether or not \coqdocvariable{x}
    and \coqdocvariable{y} are equal, we can easily prove this case as well. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Permutation nodup}{Permutation\_nodup}{\coqdoclemma{Permutation\_nodup}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} (\coqdocvar{l} \coqdocvar{m}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l}) (\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqdocvariable{Aeq\_dec} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}} \coqdocvar{Aeq\_dec} \coqdocvar{x} \coqdocvar{l}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdockw{with} (\coqdocvar{l'}:=\coqdocvar{l'}) \coqdoctac{in} \coqdocvar{i}; \coqdoctac{auto}. \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}};\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{assert} (\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvar{x} \coqdocvar{l'}). \coqdoctac{intro}. \coqdoctac{apply} \coqdocvar{n}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdockw{with} (\coqdocvar{l'}:=\coqdocvar{l}) \coqdoctac{in} \coqdocvar{H0}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}; \coqdoctac{auto}. \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}; \coqdoctac{try} \coqdocvar{contradiction}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}} \coqdocvar{Aeq\_dec} \coqdocvar{y} (\coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{l})). \coqdoctac{destruct} \coqdocvar{i}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{y}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{x} \coqdocvar{y}). \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}; \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}). \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}};\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{assert} (\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvar{y} \coqdocvar{l}). \coqdoctac{intro}; \coqdoctac{apply} \coqdocvar{n}; \coqdoctac{rewrite} \coqdocvar{e}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}; \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}; \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}). \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{x} \coqdocvar{y}). \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}). \coqdoctac{rewrite} \coqdocvar{e0}. \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}};\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{auto}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{assert} (\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvar{y} \coqdocvar{l}). \coqdoctac{intro}; \coqdoctac{apply} \coqdocvar{n0}; \coqdoctac{rewrite} \coqdocvar{e}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqdocvar{e0}. \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{assert} (\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvar{y} \coqdocvar{l}). \coqdoctac{intro}; \coqdoctac{apply} \coqdocvar{n}; \coqdoctac{intuition}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}};\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x}); \coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{perm swap}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_swap}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqdocvar{Aeq\_dec} \coqdocvar{l'})); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Facts about \texorpdfstring{\protect\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}}}{partition}}

\begin{coqdoccode}
\end{coqdoccode}
The final function in the standard library we found it useful to prove facts
    about is \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}}. First, we show the relation between \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} and
    \coqexternalref{filter}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{filter}}: filtering a list gives you a result that is equal to the first
    list \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} would return. This lemma is proven one way, and then
    reformalized to be more useful in later proofs. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.partition filter fst}{partition\_filter\_fst}{\coqdoclemma{partition\_filter\_fst}} \{\coqdocvar{A}\} \coqdocvar{p} \coqdocvar{l} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{fst}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{fst}} (\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvariable{p} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqexternalref{filter}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{filter}} \coqdocvariable{A} \coqdocvariable{p} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvar{p} \coqdocvar{l}); \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{p} \coqdocvar{a}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.partition filter fst'}{partition\_filter\_fst'}{\coqdoclemma{partition\_filter\_fst'}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{p} (\coqdocvar{l} \coqdocvar{t} \coqdocvar{f} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvariable{p} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{t}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{f}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqexternalref{filter}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{filter}} \coqdocvariable{A} \coqdocvariable{p} \coqdocvariable{l} .\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{p} \coqdocvar{l} \coqdocvar{t} \coqdocvar{f} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.partition filter fst}{\coqdoclemma{partition\_filter\_fst}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{now} \coqdoctac{rewrite} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We would like to be able to state a similar fact about the second list
    returned by \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}}, but clearly these are all the elements ``thrown out''
    by \coqexternalref{filter}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{filter}}. Instead, we first create a simple definition for negating
    a function, and prove two quick facts about the relation between some \coqdocvariable{p}
    and \coqref{B Unification.list util.neg}{\coqdocdefinition{neg}} \coqdocvariable{p}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.list util.neg}{neg}{\coqdocdefinition{neg}} \{\coqdocvar{A}:\coqdockw{Type}\} := \coqdockw{fun} (\coqdocvar{p}:\coqdocvariable{A}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqexternalref{bool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}}) \ensuremath{\Rightarrow} \coqdockw{fun} \coqdocvar{a} \ensuremath{\Rightarrow} \coqexternalref{negb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{negb}} (\coqdocvariable{p} \coqdocvariable{a}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.neg true false}{neg\_true\_false}{\coqdoclemma{neg\_true\_false}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{p} (\coqdocvar{a}:\coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{p} \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{B Unification.list util.neg}{\coqdocdefinition{neg}} \coqdocvariable{p} \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{p} \coqdocvar{a}. \coqdoctac{unfold} \coqref{B Unification.list util.neg}{\coqdocdefinition{neg}}. \coqdoctac{split}; \coqdoctac{intro}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqdocvar{p} \coqdocvar{a}); \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.neg false true}{neg\_false\_true}{\coqdoclemma{neg\_false\_true}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{p} (\coqdocvar{a}:\coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{p} \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{B Unification.list util.neg}{\coqdocdefinition{neg}} \coqdocvariable{p} \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{p} \coqdocvar{a}. \coqdoctac{unfold} \coqref{B Unification.list util.neg}{\coqdocdefinition{neg}}. \coqdoctac{split}; \coqdoctac{intro}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqdocvar{p} \coqdocvar{a}); \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
With the addition of this \coqref{B Unification.list util.neg}{\coqdocdefinition{neg}} proposition, we can now prove two lemmas
    relating the second \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} list and \coqexternalref{filter}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{filter}} in the same way we
    proved the lemmas about the first \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.partition filter snd}{partition\_filter\_snd}{\coqdoclemma{partition\_filter\_snd}} \{\coqdocvar{A}\} \coqdocvar{p} \coqdocvar{l} : \coqdoceol
\coqdocindent{1.00em}
\coqexternalref{snd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{snd}} (\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvariable{p} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqexternalref{filter}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{filter}} \coqdocvariable{A} (\coqref{B Unification.list util.neg}{\coqdocdefinition{neg}} \coqdocvariable{p}) \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvar{p} \coqdocvar{l}); \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{p} \coqdocvar{a}) \coqdocvar{eqn}:\coqdocvar{Hp}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{apply} \coqref{B Unification.list util.neg true false}{\coqdoclemma{neg\_true\_false}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{rewrite} \coqdocvar{Hp}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{apply} \coqref{B Unification.list util.neg false true}{\coqdoclemma{neg\_false\_true}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{rewrite} \coqdocvar{Hp}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.partition filter snd'}{partition\_filter\_snd'}{\coqdoclemma{partition\_filter\_snd'}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{p} (\coqdocvar{l} \coqdocvar{t} \coqdocvar{f} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvariable{p} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{t}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{f}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{f} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqexternalref{filter}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{filter}} \coqdocvariable{A} (\coqref{B Unification.list util.neg}{\coqdocdefinition{neg}} \coqdocvariable{p}) \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{p} \coqdocvar{l} \coqdocvar{t} \coqdocvar{f} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.partition filter snd}{\coqdoclemma{partition\_filter\_snd}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{now} \coqdoctac{rewrite} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
These lemmas about \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} and \coqexternalref{filter}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{filter}} are now put to use in two
    important lemmas about \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}}. If some list \coqdocvariable{l} is partitioned into
    two lists (\coqref{B Unification.poly.MonoOrder.t}{\coqdocdefinition{t}}, \coqdocvariable{f}), then every element in \textit{t} must return true for the
    filtering predicate and every element in \coqdocvariable{f} must return false. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.part fst true}{part\_fst\_true}{\coqdoclemma{part\_fst\_true}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{p} (\coqdocvar{l} \coqdocvar{t} \coqdocvar{f} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvariable{p} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{t}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{f}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{a}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{t} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{p} \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{p} \coqdocvar{l} \coqdocvar{t} \coqdocvar{f} \coqdocvar{Hpart} \coqdocvar{a} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{Hf}: \coqdocvar{t} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{filter}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{filter}} \coqdocvar{p} \coqdocvar{l}).\coqdoceol
\coqdocindent{1.00em}
- \coqdocvar{now} \coqdoctac{apply} \coqref{B Unification.list util.partition filter fst'}{\coqdoclemma{partition\_filter\_fst'}} \coqdockw{with} \coqdocvar{f}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{assert} (\coqdocvar{Hass} := \coqexternalref{filter In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{filter\_In}} \coqdocvar{p} \coqdocvar{a} \coqdocvar{l}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{Hass}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{now} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hf}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.part snd false}{part\_snd\_false}{\coqdoclemma{part\_snd\_false}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{p} (\coqdocvar{x} \coqdocvar{t} \coqdocvar{f} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvariable{p} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{t}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{f}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{a}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{f} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{p} \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{p} \coqdocvar{l} \coqdocvar{t} \coqdocvar{f} \coqdocvar{Hpart} \coqdocvar{a} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{Hf}: \coqdocvar{f} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{filter}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{filter}} (\coqref{B Unification.list util.neg}{\coqdocdefinition{neg}} \coqdocvar{p}) \coqdocvar{l}).\coqdoceol
\coqdocindent{1.00em}
- \coqdocvar{now} \coqdoctac{apply} \coqref{B Unification.list util.partition filter snd'}{\coqdoclemma{partition\_filter\_snd'}} \coqdockw{with} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{assert} (\coqdocvar{Hass} := \coqexternalref{filter In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{filter\_In}} (\coqref{B Unification.list util.neg}{\coqdocdefinition{neg}} \coqdocvar{p}) \coqdocvar{a} \coqdocvar{l}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.neg false true}{\coqdoclemma{neg\_false\_true}} \coqdoctac{in} \coqdocvar{Hass}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{Hass}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{now} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hf}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Next is a rather obvious but useful lemma, which states that if a list \coqdocvariable{l}
    was split into (\coqref{B Unification.poly.MonoOrder.t}{\coqdocdefinition{t}}, \coqdocvariable{f}) then appending these lists back together results
    in a list that is a permutation of the original. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.partition Permutation}{partition\_Permutation}{\coqdoclemma{partition\_Permutation}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{p} (\coqdocvar{l} \coqdocvar{t} \coqdocvar{f}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvariable{p} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{t}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{f}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} (\coqdocvariable{t} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{f}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{p} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} (\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvar{p} \coqdocvar{l}). \coqdoctac{destruct} (\coqdocvar{p} \coqdocvar{a}); \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}. \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{f\_equal}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{t0}). \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqdocvar{t0} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l1}). \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}} \coqdockw{with} (\coqdocvar{l}:=\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{l1}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The last and hardest fact about \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} states that if the list being
    partitioned was already sorted, then the resulting two lists will also
    be sorted. This seems simple, as \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} iterates through the elements
    in order and maintains the order in its children, but was surprisingly
    difficult to prove.


    After performing induction, the next step was to destruct \coqdocvariable{f} \coqdocvariable{a}, to see
    which of the two lists the induction element would end up in. In both
    cases, the list that \textit{doesn't} receive the new element is already clearly
    sorted by the induction hypothesis, but proving the other one is sorted
    is slightly harder.


    By using \coqref{B Unification.list util.Forall HdRel}{\coqdoclemma{Forall\_HdRel}} (defined earlier), we reduced the problem in both
    cases to only having to show that the new element holds the relation \coqdocvariable{c}
    between all elements of the list it was \coqdocvar{cons}ed onto. After some
    manipulation and the use of \coqref{B Unification.list util.partition Permutation}{\coqdoclemma{partition\_Permutation}} and \coqref{B Unification.list util.Forall incl}{\coqdoclemma{Forall\_incl}}, this
    follows from the fact that we know the new element holds the relation
    between all elements of the original list \coqdocvariable{p}, and therefore also holds it
    between the elements of the partitioned list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.part Sorted}{part\_Sorted}{\coqdoclemma{part\_Sorted}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{X}\} (\coqdocvar{c}:\coqdocvariable{X}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{X}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdockw{Prop}) \coqdocvar{f} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sets.Relations\_1}{\coqdocdefinition{Relations\_1.Transitive}} \coqdocvariable{c} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvariable{c} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{r}, \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvariable{f} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{l}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvariable{c} \coqdocvariable{l} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvariable{c} \coqdocvariable{r}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{c} \coqdocvar{f} \coqdocvar{p} \coqdocvar{Htran} \coqdocvar{Hsort}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{assert} (\coqdocvar{H0}:=\coqdocvar{H}); \coqdoctac{auto}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} (\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvar{f} \coqdocvar{p}) \coqdockw{as} [\coqdocvar{g} \coqdocvar{d}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqdocvar{f} \coqdocvar{a}); \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{assert} (\coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} (\coqdocvar{c} \coqdocvar{a}) \coqdocvar{g} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvar{c} \coqdocvar{g} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvar{c} \coqdocvar{r} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{7.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvar{c} (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{g}) \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvar{c} \coqdocvar{r}).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{intros} \coqdocvar{H4}. \coqdoctac{split}. \coqdoctac{apply} \coqexternalref{Sorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_cons}}. \coqdoctac{apply} \coqdocvar{H4}. \coqdoctac{apply} \coqref{B Unification.list util.Forall HdRel}{\coqdoclemma{Forall\_HdRel}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqdocvar{H4}. \coqdoctac{apply} \coqdocvar{H4}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H1}. \coqdoctac{split}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{Hsort}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{Hsort} \coqdockw{as} [].\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} (\coqref{B Unification.list util.Forall incl}{\coqdoclemma{Forall\_incl}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H5}). \coqdoctac{apply} \coqref{B Unification.list util.partition Permutation}{\coqdoclemma{partition\_Permutation}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H2} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{Permutation cons inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_inv}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqref{B Unification.list util.Permutation incl}{\coqdoclemma{Permutation\_incl}} \coqdoctac{in} \coqdocvar{H0} \coqdockw{as} []. \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}. \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdoctac{in} \coqdocvar{H6}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{intros} \coqdocvar{a0} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H6}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{apply} \coqdocvar{IHp}. \coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{Hsort}; \coqdoctac{apply} \coqdocvar{Hsort}. \coqdoctac{f\_equal}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{assert} (\coqexternalref{Forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{Forall}} (\coqdocvar{c} \coqdocvar{a}) \coqdocvar{d} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvar{c} \coqdocvar{l} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvar{c} \coqdocvar{d} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{7.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvar{c} \coqdocvar{l} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvar{c} (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{d})).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{intros} \coqdocvar{H4}. \coqdoctac{split}. \coqdoctac{apply} \coqdocvar{H4}. \coqdoctac{apply} \coqexternalref{Sorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_cons}}. \coqdoctac{apply} \coqdocvar{H4}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqref{B Unification.list util.Forall HdRel}{\coqdoclemma{Forall\_HdRel}}. \coqdoctac{apply} \coqdocvar{H4}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H1}. \coqdoctac{split}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{Hsort}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{Hsort} \coqdockw{as} [].\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} (\coqref{B Unification.list util.Forall incl}{\coqdoclemma{Forall\_incl}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H5}). \coqdoctac{apply} \coqref{B Unification.list util.partition Permutation}{\coqdoclemma{partition\_Permutation}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H3} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'{}'}:=\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{d} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l}) \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{Permutation cons inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_inv}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'{}'}:=\coqdocvar{l} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{d}) \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqref{B Unification.list util.Permutation incl}{\coqdoclemma{Permutation\_incl}} \coqdoctac{in} \coqdocvar{H0} \coqdockw{as} []. \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}. \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} \coqdoctac{in} \coqdocvar{H6}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{intros} \coqdocvar{a0} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H6}. \coqdoctac{intuition}. \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}} \coqdockw{with} (\coqdocvar{l'}:=\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{d}).\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{apply} \coqdocvar{IHp}. \coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{Hsort}; \coqdoctac{apply} \coqdocvar{Hsort}. \coqdoctac{f\_equal}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{New Functions over Lists}



 In order to easily perform the operations we need on lists, we defined three
    major list functions of our own, each with their own proofs. These
    generalized list functions all help to make it much easier to deal with our
    polynomial and monomial lists later in the development. 

\subsection{Distributing two Lists: \texorpdfstring{\protect\coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}}}{distribute}}

\begin{coqdoccode}
\end{coqdoccode}
The first and most basic of the three is \coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}}. Similarly to the
    ``FOIL'' technique learned in middle school for multiplying two polynomials,
    this function serves to create every combination of one element from each
    list. It is done concisely with the use of higher order functions below. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.list util.distribute}{distribute}{\coqdocdefinition{distribute}} \{\coqdocvar{A}\} (\coqdocvar{l} \coqdocvar{m} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} (\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A})) : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} (\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}) :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a} \ensuremath{\Rightarrow} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvariable{a}) \coqdocvariable{l}) \coqdocvariable{m}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}} function will play a larger role later, mostly as a part of
    our polynomial multiplication function. For now, however, there are only
    two very simple lemmas to be proven, both stating that distributing \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}}
    over a list results in \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.distribute nil}{distribute\_nil}{\coqdoclemma{distribute\_nil}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} (\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A})),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.distribute nil r}{distribute\_nil\_r}{\coqdoclemma{distribute\_nil\_r}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} (\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A})),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}} \coqdocvariable{l} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Cancelling out Repeated Elements: \texorpdfstring{\protect\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}}{nodup\_cancel}}

\begin{coqdoccode}
\end{coqdoccode}
The next list function, and possibly the most prolific function in our
    entire development, is \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}. Similarly to the standard library
    \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} function, \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} takes a list that may or may not have
    duplicates in it and returns a list without duplicates.


    The difference between ours and the standard function is that rather than
    just removing all duplicates and leaving one of each element, the elements
    in a \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} list cancel out in pairs. For example, the list
    [1;1;1] would become [1], whereas [1;1;1;1] would become [].


    This is implemented with the \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} function and \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}}, and is
    largely the reason for needing so many lemmas about those two functions. If
    there is an \textit{even} number of occurences of an element \coqdocvariable{a} in the original
    list \coqdocvariable{a} :: \coqdocvariable{l}, which implies there is an \textit{odd} number of occurences of this
    element in \coqdocvariable{l}, then all instances are removed. On the other hand, if there
    is an \textit{odd} number of occurences in the original list, one occurence is
    kept, and the rest are removed.


    By calling \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} recursively on \coqdocvariable{xs} \textit{before} calling \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}},
    Coq is easily able to determine that \coqdocvariable{xs} is the decreasing argument,
    removing the need for a more complicated definition with ``fuel''. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.list util.nodup cancel}{nodup\_cancel}{\coqdocdefinition{nodup\_cancel}} \{\coqdocvar{A}\} \coqdocvar{Aeq\_dec} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}) : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{xs} \ensuremath{\Rightarrow} \coqdoceol
\coqdocindent{2.00em}
\coqdockw{let} \coqdocvar{count} := \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvar{xs} \coqdocvar{x} \coqdoctac{in}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{let} \coqdocvar{xs'} := \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvar{x} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvar{xs}) \coqdoctac{in}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{if} \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} \coqdocvariable{count} \coqdockw{then} \coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{xs'} \coqdockw{else} \coqdocvariable{xs'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now onto lemmas. To begin with, there are a few facts true of \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} that
    are also true of \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}, which are useful in many proofs.
    \coqref{B Unification.list util.nodup cancel in}{\coqdoclemma{nodup\_cancel\_in}} is the same as the standard library's \coqdocvar{nodup\_in}, with
    one important difference: this implication is \textit{not} bidirectional. Because
    even parity elements are removed completely, not all elements in \coqdocvariable{l} are
    guaranteed to be in \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{l}.


    \coqref{B Unification.list util.NoDup nodup cancel}{\coqdoclemma{NoDup\_nodup\_cancel}} is much simpler, and effectively exactly the same
    as \coqexternalref{NoDup nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_nodup}}.


    In these proofs, and most others from this point on, the shape will be
    very similar to the proof of the corresponding \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} proof. The main
    difference is that, instead of destructing \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}} like one would
    for \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}}, we destruct the evenness of \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}}, as that is what
    drives the main \coqdockw{if} statement of the function. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nodup cancel in}{nodup\_cancel\_in}{\coqdoclemma{nodup\_cancel\_in}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [|\coqdocvar{b} \coqdocvar{l} \coqdocvar{IHl}]; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{b}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{l} \coqdocvar{b})).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{n}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.list util.In remove}{\coqdoclemma{In\_remove}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.In remove}{\coqdoclemma{In\_remove}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.NoDup nodup cancel}{NoDup\_nodup\_cancel}{\coqdoclemma{NoDup\_nodup\_cancel}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocnoindent
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [|\coqdocvar{a} \coqdocvar{l'} \coqdocvar{Hrec}]; \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{constructor}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{l'} \coqdocvar{a})); \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{NoDup cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocconstructor{NoDup\_cons}}; [\coqdoctac{apply} \coqexternalref{remove In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{remove\_In}} \ensuremath{|} \coqdoctac{apply} \coqref{B Unification.list util.NoDup remove}{\coqdoclemma{NoDup\_remove}}; \coqdoctac{auto}].\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.NoDup remove}{\coqdoclemma{NoDup\_remove}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Although not standard library lemmas, the \coqref{B Unification.list util.no nodup NoDup}{\coqdoclemma{no\_nodup\_NoDup}} and
    \coqref{B Unification.list util.Sorted nodup}{\coqdoclemma{Sorted\_nodup}} facts we proved earlier in this file are also both true
    of \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}, and proven in almost the same way. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.no nodup cancel NoDup}{no\_nodup\_cancel\_NoDup}{\coqdoclemma{no\_nodup\_cancel\_NoDup}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} []. \coqdoctac{assert} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{l} \coqdocvar{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{count occ not In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{count\_occ\_not\_In}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{simpl}. \coqdoctac{f\_equal}. \coqdoctac{rewrite} \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}}. \coqdoctac{auto}. \coqdoctac{intro}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel in}{\coqdoclemma{nodup\_cancel\_in}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Sorted nodup cancel}{Sorted\_nodup\_cancel}{\coqdoclemma{Sorted\_nodup\_cancel}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{Rel} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sets.Relations\_1}{\coqdocdefinition{Relations\_1.Transitive}} \coqdocvariable{Rel} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvariable{Rel} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqdocvariable{Rel} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{Rel} \coqdocvar{l} \coqdocvar{Ht} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{StronglySorted Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_Sorted}}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{l} \coqdocvar{a})).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{SSorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{SSorted\_cons}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.StronglySorted remove}{\coqdoclemma{StronglySorted\_remove}}. \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.Forall remove}{\coqdoclemma{Forall\_remove}}. \coqdoctac{apply} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}}. \coqdoctac{rewrite} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel in}{\coqdoclemma{nodup\_cancel\_in}} \coqdoctac{in} \coqdocvar{Hin}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.list util.StronglySorted remove}{\coqdoclemma{StronglySorted\_remove}}. \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
An interesting side effect of the ``cancelling'' behavior of this function
    is that while the number of occurences of an item may change after calling
    \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}, the evenness of the count never will. If an element was
    odd before there will be one occurence, and if it was even before there
    will be none. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ nodup cancel}{count\_occ\_nodup\_cancel}{\coqdoclemma{count\_occ\_nodup\_cancel}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} \coqdocvar{p} (\coqdocvar{a}:\coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p}) \coqdocvariable{a}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{a}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{a}. \coqdoctac{induction} \coqdocvar{p} \coqdockw{as} [|\coqdocvar{b}]; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{b})) \coqdocvar{eqn}:\coqdocvar{Hb}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{b} \coqdocvar{a}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ remove}{\coqdoclemma{count\_occ\_remove}}. \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{Hb}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb odd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_odd}} \coqdoctac{in} \coqdocvar{Hb}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqexternalref{negb true iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_true\_iff}} \coqdoctac{in} \coqdocvar{Hb}. \coqdoctac{rewrite} \coqdocvar{Hb}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.count occ neq remove}{\coqdoclemma{count\_occ\_neq\_remove}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{b} \coqdocvar{a}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ remove}{\coqdoclemma{count\_occ\_remove}}. \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{Hb}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb odd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_odd}} \coqdoctac{in} \coqdocvar{Hb}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqexternalref{negb false iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_false\_iff}} \coqdoctac{in} \coqdocvar{Hb}. \coqdoctac{rewrite} \coqdocvar{Hb}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.count occ neq remove}{\coqdoclemma{count\_occ\_neq\_remove}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqref{B Unification.list util.Permutation nodup}{\coqdoclemma{Permutation\_nodup}} lemma was challenging to prove before, and this
    version for \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} faces the same problems. The first and fourth
    cases are easy, and the second isn't too bad after using
    \coqref{B Unification.list util.count occ Permutation}{\coqdoclemma{count\_occ\_Permutation}}. The third case faces the same problems as before,
    but requires some extra work when transitioning from reasoning about
    \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} (\coqdocvariable{x} :: \coqdocvariable{l}) \coqdocvariable{y}) to \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} (\coqdocvariable{y} :: \coqdocvariable{l}) \coqdocvariable{x}.


    This is accomplished by using \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}, \coqexternalref{Nat.negb odd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_odd}}, and \coqexternalref{negb true iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{negb\_true\_iff}}.
    In this way, we can convert something saying \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqdocvar{S} \coqdocvariable{n}) = \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} to
    \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} \coqdocvariable{n} = \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nodup cancel Permutation}{nodup\_cancel\_Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{Aeq\_dec} (\coqdocvar{l} \coqdocvar{l'}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{l'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l}) (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l'}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{l} \coqdocvar{l'} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} \coqdocvar{eqn}:\coqdocvar{Hevn}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} (\coqref{B Unification.list util.count occ Permutation}{\coqdoclemma{count\_occ\_Permutation}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H}) \coqdoctac{in} \coqdocvar{Hevn}. \coqdoctac{rewrite} \coqdocvar{Hevn}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}. \coqdoctac{apply} \coqref{B Unification.list util.remove Permutation}{\coqdoclemma{remove\_Permutation}}. \coqdoctac{apply} \coqdocvar{IHPermutation}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} (\coqref{B Unification.list util.count occ Permutation}{\coqdoclemma{count\_occ\_Permutation}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H}) \coqdoctac{in} \coqdocvar{Hevn}. \coqdoctac{rewrite} \coqdocvar{Hevn}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.list util.remove Permutation}{\coqdoclemma{remove\_Permutation}}. \coqdoctac{apply} \coqdocvar{IHPermutation}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{l} \coqdocvar{x})) \coqdocvar{eqn}:\coqdocvar{Hevx};\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{l} \coqdocvar{y})) \coqdocvar{eqn}:\coqdocvar{Hevy}; \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{x} \coqdocvar{y}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb odd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_odd}} \coqdoctac{in} \coqdocvar{Hevy}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqexternalref{negb true iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_true\_iff}} \coqdoctac{in} \coqdocvar{Hevy}. \coqdoctac{rewrite} \coqdocvar{Hevy}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} (\coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{n}; \coqdocvar{contradiction}). \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb odd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_odd}} \coqdoctac{in} \coqdocvar{Hevx}. \coqdoctac{rewrite} \coqexternalref{negb true iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_true\_iff}} \coqdoctac{in} \coqdocvar{Hevx}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Hevx}. \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{x} \coqdocvar{y}); \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqref{B Unification.list util.remove remove}{\coqdoclemma{remove\_remove}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{Hevy}. \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}). \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{x} \coqdocvar{y});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqdocvar{Hevx}. \coqdoctac{rewrite} \coqref{B Unification.list util.remove remove}{\coqdoclemma{remove\_remove}}. \coqdoctac{apply} \coqexternalref{perm swap}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_swap}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e} \coqdoctac{in} \coqdocvar{Hevy}. \coqdoctac{rewrite} \coqdocvar{Hevy} \coqdoctac{in} \coqdocvar{Hevx}. \coqdoctac{inversion} \coqdocvar{Hevx}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{Hevy}. \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}). \coqdoctac{rewrite} \coqdocvar{Hevx}. \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.remove remove}{\coqdoclemma{remove\_remove}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{Hevx}. \coqdoctac{rewrite} \coqdocvar{Hevx} \coqdoctac{in} \coqdocvar{Hevy}. \coqdoctac{inversion} \coqdocvar{Hevy}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{Hevy}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x}); \coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Hevx}. \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{x} \coqdocvar{y}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}. \coqdoctac{rewrite} \coqref{B Unification.list util.remove remove}{\coqdoclemma{remove\_remove}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb odd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_odd}} \coqdoctac{in} \coqdocvar{Hevy}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqexternalref{negb false iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_false\_iff}} \coqdoctac{in} \coqdocvar{Hevy}. \coqdoctac{rewrite} \coqdocvar{Hevy}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x}); \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb odd}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_odd}} \coqdoctac{in} \coqdocvar{Hevx}. \coqdoctac{rewrite} \coqexternalref{negb false iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_false\_iff}} \coqdoctac{in} \coqdocvar{Hevx}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Hevx}. \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{Hevy}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{y} \coqdocvar{x}); \coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Hevx}. \coqdoctac{rewrite} \coqref{B Unification.list util.remove remove}{\coqdoclemma{remove\_remove}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} \coqdocvar{l'}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
As mentioned earlier, in the original definition of the function, it was
    helpful to reverse the order of \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} and the recursive call to
    \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}. This is possible because these operations are associative,
    which is proven below. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nodup cancel remove assoc}{nodup\_cancel\_remove\_assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{Aeq\_dec} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{p}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} \coqdocvar{eqn}:\coqdocvar{Hevn}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a0}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e}. \coqdoctac{rewrite} \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}}; \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{remove In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{remove\_In}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ neq remove}{\coqdoclemma{count\_occ\_neq\_remove}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqdocvar{Hevn}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{f\_equal}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHp}. \coqdoctac{rewrite} \coqref{B Unification.list util.remove remove}{\coqdoclemma{remove\_remove}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a0}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e}. \coqdoctac{rewrite} \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}}; \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{remove In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{remove\_In}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ neq remove}{\coqdoclemma{count\_occ\_neq\_remove}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqdocvar{Hevn}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.remove remove}{\coqdoclemma{remove\_remove}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHp}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The entire point of defining \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} was so that repeated elements
    in a list cancel out; clearly then, if an entire list appears twice it
    will cancel itself out. This proof would be much easier if the order of
    \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} and \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} was swapped, but the above proof of the two
    being associative makes it easier to manage. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nodup cancel self}{nodup\_cancel\_self}{\coqdoclemma{nodup\_cancel\_self}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A}\} \coqdocvar{Aeq\_dec} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{l} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} \coqdocvar{eqn}:\coqdocvar{Hevn}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}} \coqdoctac{in} \coqdocvar{Hevn}. \coqdoctac{destruct} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{a}) \coqdocvar{eqn}:\coqdocvar{Hx}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hevn}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Hx} \coqdoctac{in} \coqdocvar{Hevn}. \coqdoctac{inversion} \coqdocvar{Hevn}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hevn}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Hx} \coqdoctac{in} \coqdocvar{Hevn}. \coqdoctac{rewrite} \coqexternalref{Nat.add comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{add\_comm}} \coqdoctac{in} \coqdocvar{Hevn}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hevn}. \coqdoctac{destruct} (\coqexternalref{plus}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} \coqdocvar{n} \coqdocvar{n}) \coqdocvar{eqn}:\coqdocvar{Help}. \coqdoctac{inversion} \coqdocvar{Hevn}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{replace} (\coqexternalref{plus}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} \coqdocvar{n} \coqdocvar{n}) \coqdockw{with} (\coqexternalref{plus}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} 0 (2 \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{n})) \coqdoctac{in} \coqdocvar{Help}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{pose} (\coqexternalref{Nat.even add mul 2}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_add\_mul\_2}} 0 \coqdocvar{n}). \coqdoctac{pose} (\coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}} \coqdocvar{n0}). \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Help} \coqdoctac{in} \coqdocvar{e1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{e0} \coqdoctac{in} \coqdocvar{e1}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{e1}. \coqdoctac{apply} \coqexternalref{Nat.even spec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_spec}} \coqdoctac{in} \coqdocvar{Hevn}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Nat.odd spec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{odd\_spec}} \coqdoctac{in} \coqdocvar{e1}. \coqdoctac{apply} (\coqexternalref{Nat.Even Odd False}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{Even\_Odd\_False}} \coqdocvar{\_} \coqdocvar{Hevn}) \coqdoctac{in} \coqdocvar{e1}. \coqdoctac{inversion} \coqdocvar{e1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{clear} \coqdocvar{Hevn}. \coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}}. \coqdoctac{rewrite} \coqref{B Unification.list util.remove distr app}{\coqdoclemma{remove\_distr\_app}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.remove distr app}{\coqdoclemma{remove\_distr\_app}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{IHp}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Next up is a useful fact about \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} that results from \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}.
    Because when there's an even number of an element they all get removed,
    we can say that there will not be any in the resulting list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.not in nodup cancel}{not\_in\_nodup\_cancel}{\coqdoclemma{not\_in\_nodup\_cancel}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{m}:\coqdocvariable{A}) \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{m}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{m} \coqdocvar{p} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{m}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_even}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqexternalref{negb true iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_true\_iff}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{remove In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{remove\_In}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{IHp}; \coqdoctac{auto}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{a})).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{H0}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{apply} \coqref{B Unification.list util.In remove}{\coqdoclemma{In\_remove}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.In remove}{\coqdoclemma{In\_remove}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly to the above lemma, because \coqdocvariable{a} will already be removed from
    \coqdocvariable{p} by \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}, whether or not a \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} is added doesn't make a
    difference. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nodup extra remove}{nodup\_extra\_remove}{\coqdoclemma{nodup\_extra\_remove}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{a}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{p} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{p} \coqdockw{as} [|\coqdocvar{b}]; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{b}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{b} \coqdocvar{b}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_even}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqexternalref{negb true iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_true\_iff}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}}. \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{b})) \coqdocvar{eqn}:\coqdocvar{Hev}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.count occ neq remove}{\coqdoclemma{count\_occ\_neq\_remove}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqdocvar{Hev}. \coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{IHp}. \coqdoctac{auto}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}). \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.count occ neq remove}{\coqdoclemma{count\_occ\_neq\_remove}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqdocvar{Hev}. \coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHp}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{b} \coqdocvar{a});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} (\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}). \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Lastly, one of the toughest \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} lemmas. Similarly to
    \coqref{B Unification.list util.nodup pointless}{\coqdoclemma{nodup\_pointless}}, if \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} is going to be applied later, there is
    no need for it to be applied twice. This lemma proves to be very useful when
    proving that two different polynomials are equal, because, as we will see
    later, there are often repeated calls to \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} inside one another.
    This lemma makes it significantly easier to deal with, as we can remove the
    redundant \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}s.


    This proof proved to be challenging, mostly because it is hard to reason
    about the parity of the same element in two different lists. In the proof,
    we begin with induction over \coqdocvariable{p}, and then move to destructing the count of
    \coqdocvariable{a} in each list. The first case follows easily from the two even
    hypotheses, \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}, and a couple other lemmas. The second case is
    almost exactly the same, except \coqdocvariable{a} is removed by \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} and never
    makes it out front, so the call to \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}} is removed.


    The third case, where \coqdocvariable{a} appears an odd number of times in \coqdocvariable{p} and an even
    number of times in \coqdocvariable{q}, is slightly different, but still solved
    relatively easily with the use of \coqref{B Unification.list util.nodup extra remove}{\coqdoclemma{nodup\_extra\_remove}}. The fourth case
    is by far the hardest. We begin by asserting that, since the count of \coqdocvariable{a} in
    \coqdocvariable{q} is odd, there must be at least one, and therefore we can rewrite
    with \coqexternalref{In split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocabbreviation{In\_split}} to get \coqdocvariable{q} into the form of \coqdocvariable{l1} ++ \coqdocvariable{a} ++ \coqdocvariable{l2}. We then assert
    that, since the count of \coqdocvariable{a} in \coqdocvariable{q} is odd, the count in \coqdocvariable{l1} ++ \coqdocvariable{l2}, or \coqdocvariable{q}
    with one \coqdocvariable{a} removed, must surely be even. These facts, combined with
    \coqref{B Unification.list util.remove distr app}{\coqdoclemma{remove\_distr\_app}}, \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}, and \coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}}, allow
    us to slowly but surely work \coqdocvariable{a} out to the front and eliminate it with
    \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}. All that is left to do at that point is to perform similar
    steps in the induction hypothesis, so that both \coqdocvar{IHp} and our goal are in
    terms of \coqdocvariable{l1} and \coqdocvariable{l2}. \coqdocvar{IHp} is then used to finish the proof. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nodup cancel pointless}{nodup\_cancel\_pointless}{\coqdoclemma{nodup\_cancel\_pointless}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{p} \coqdocvar{q}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}))\coqdoceol
\coqdocindent{7.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{a})) \coqdocvar{eqn}:\coqdocvar{Hevp};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{q} \coqdocvar{a})) \coqdocvar{eqn}:\coqdocvar{Hevq}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{Hevp}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}, \coqref{B Unification.list util.count occ remove}{\coqdoclemma{count\_occ\_remove}}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}, \coqexternalref{Nat.even add}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_add}}, \coqdocvar{Hevp}, \coqdocvar{Hevq}. \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}}. \coqdoctac{rewrite} \coqref{B Unification.list util.remove pointless}{\coqdoclemma{remove\_pointless}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}}. \coqdoctac{apply} \coqref{B Unification.list util.remove Permutation}{\coqdoclemma{remove\_Permutation}}. \coqdoctac{apply} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{Hevp}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}, \coqref{B Unification.list util.count occ remove}{\coqdoclemma{count\_occ\_remove}}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}, \coqexternalref{Nat.even add}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_add}}, \coqdocvar{Hevp}, \coqdocvar{Hevq}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}}. \coqdoctac{rewrite} \coqref{B Unification.list util.remove pointless}{\coqdoclemma{remove\_pointless}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}}. \coqdoctac{apply} \coqref{B Unification.list util.remove Permutation}{\coqdoclemma{remove\_Permutation}}. \coqdoctac{apply} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{Hevp}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}, \coqexternalref{Nat.even add}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_add}}, \coqdocvar{Hevp}, \coqdocvar{Hevq}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} (\coqref{B Unification.list util.nodup extra remove}{\coqdoclemma{nodup\_extra\_remove}} \coqdocvar{a}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.remove pointless}{\coqdoclemma{remove\_pointless}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.list util.remove Permutation}{\coqdoclemma{remove\_Permutation}}. \coqdoctac{apply} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{rewrite} \coqexternalref{Nat.even add}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_add}}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ remove}{\coqdoclemma{count\_occ\_remove}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Hevq}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{assert} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{q} \coqdocvar{a} \coqexternalref{::nat scope:x '>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{>}} 0). \coqdoctac{destruct} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{\_} \coqdocvar{q} \coqdocvar{\_}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{inversion} \coqdocvar{Hevq}. \coqdoctac{apply} \coqexternalref{gt Sn O}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Gt}{\coqdoclemma{gt\_Sn\_O}}. \coqdoctac{apply} \coqexternalref{count occ In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{count\_occ\_In}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{in split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_split}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [\coqdocvar{l1} [\coqdocvar{l2} \coqdocvar{H}]]. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{simpl} \coqdocvar{nodup\_cancel} \coqdoctac{at} 2.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Hevp}. \coqdoctac{simpl} \coqdocvar{app}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{IHp}. \coqdoctac{simpl} \coqdocvar{nodup\_cancel} \coqdoctac{at} 3.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{rewrite} \coqexternalref{Nat.even add}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_add}}. \coqdoctac{rewrite} \coqdocvar{Hevp}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H} \coqdoctac{at} 2.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Hevq}. \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{Aeq\_dec} (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvar{Aeq\_dec} \coqdocvar{a} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} \coqdocvar{p}) \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l2})).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}. \coqdoctac{apply} \coqexternalref{Permutation middle}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_middle}} \coqdockw{with} (\coqdocvar{l2}:=\coqdocvar{l2}) (\coqdocvar{l1}:=\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}}\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{Aeq\_dec} \coqdocvar{a} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} \coqdocvar{p}) \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l1}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{assert} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} (\coqdocvar{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l2}) \coqdocvar{a}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hevq}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}} \coqdoctac{in} \coqdocvar{Hevq}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hevq}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a}); \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqexternalref{plus comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Plus}{\coqdocabbreviation{plus\_comm}} \coqdoctac{in} \coqdocvar{Hevq}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqexternalref{plus Sn m}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdoclemma{plus\_Sn\_m}} \coqdoctac{in} \coqdocvar{Hevq}. \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}} \coqdoctac{in} \coqdocvar{Hevq}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_even}} \coqdoctac{in} \coqdocvar{Hevq}. \coqdoctac{rewrite} \coqexternalref{negb false iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_false\_iff}} \coqdoctac{in} \coqdocvar{Hevq}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{symmetry}. \coqdoctac{rewrite} \coqexternalref{plus comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Plus}{\coqdocabbreviation{plus\_comm}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ remove}{\coqdoclemma{count\_occ\_remove}}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{replace} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} \coqdocvar{\_}) \coqdockw{with} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}. \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} (\coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}} \coqdocvar{\_} \coqdocvar{\_} (\coqdocvar{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{l2})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.list util.remove distr app}{\coqdoclemma{remove\_distr\_app}}. \coqdoctac{simpl}; \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.remove pointless}{\coqdoclemma{remove\_pointless}}. \coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.remove distr app}{\coqdoclemma{remove\_distr\_app}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.nodup cancel remove assoc}{\coqdoclemma{nodup\_cancel\_remove\_assoc}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with}\coqdoceol
\coqdocindent{4.00em}
(\coqdocvar{l'{}'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l2})) \coqdoctac{in} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{IHp}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'{}'}:=\coqdoceol
\coqdocindent{4.00em}
\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l2})) \coqdoctac{in} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHp}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}, \coqexternalref{Nat.even add}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_add}}, \coqdocvar{Hevp} \coqdoctac{in} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H0} \coqdoctac{in} \coqdocvar{IHp}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}, \coqexternalref{Nat.even add}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_add}}, \coqref{B Unification.list util.count occ nodup cancel}{\coqdoclemma{count\_occ\_nodup\_cancel}}, \coqdocvar{Hevp}, \coqdocvar{H0} \coqdoctac{in} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHp}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}. \coqdoctac{apply} \coqexternalref{Permutation middle}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_middle}} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
(\coqdocvar{l1}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l1}).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}. \coqdoctac{apply} \coqexternalref{Permutation middle}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_middle}} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
(\coqdocvar{l1}:=\coqdocvar{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l1}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This lemma is simply a reformalization of the above for convenience, which
    follows simply because of \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nodup cancel pointless r}{nodup\_cancel\_pointless\_r}{\coqdoclemma{nodup\_cancel\_pointless\_r}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{p} \coqdocvar{q}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{q}))\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} \coqdocvar{q} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{p})). \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Aeq\_dec} (\coqdocvar{q} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{p})). \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
An interesting side effect of \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}} is that now we can
    show that \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} almost ``distributes'' over \coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}}. More formally,
    to prove that the \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} of two lists appended together is a
    permutation of \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} applied to two other lists appended, it is
    sufficient to show that the first of each and the second of each are
    permutations after applying \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} to them individually. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nodup cancel app Permutation}{nodup\_cancel\_app\_Permutation}{\coqdoclemma{nodup\_cancel\_app\_Permutation}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a}) (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{b}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{c}) (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{d}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{c})) (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{b} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{d})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}} \coqdocvar{a}),\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\leftarrow} (\coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}} \coqdocvar{b}), \ensuremath{\leftarrow} (\coqref{B Unification.list util.nodup cancel pointless r}{\coqdoclemma{nodup\_cancel\_pointless\_r}} \coqdocvar{\_} \coqdocvar{c}),\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\leftarrow} (\coqref{B Unification.list util.nodup cancel pointless r}{\coqdoclemma{nodup\_cancel\_pointless\_r}} \coqdocvar{\_} \coqdocvar{d}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{apply} \coqexternalref{Permutation app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Comparing Parity of Lists: \texorpdfstring{\protect\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}}}{parity\_match}}

\begin{coqdoccode}
\end{coqdoccode}
The final major definition over lists we wrote is \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}}.
    \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} is closely related to \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}, and allows us to make
    statements about lists being equal after applying \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} to them.
    Clearly, if an element appears an even number of times in both lists, then
    it won't appear at all after \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}, and if an element appears an
    odd number of times in both lists, then it will appear once after
    \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}. The ultimate goal of creating this definition is to prove a
    lemma that if the parity of two lists matches, they are permutations
    of each other after applying \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}.


    The definition simply states that for all elements, the parity of the number
    of occurences in each list is equal. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.list util.parity match}{parity\_match}{\coqdocdefinition{parity\_match}} \{\coqdocvar{A}\} \coqdocvar{Aeq\_dec} (\coqdocvar{l} \coqdocvar{m}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l} \coqdocvariable{x}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{m} \coqdocvariable{x}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A useful lemma in working towards this proof is that if the count of every
    variable in a list is even, then there will be no variables in the resulting
    list. This is relatively easy to prove, as we have already proven
    \coqref{B Unification.list util.not in nodup cancel}{\coqdoclemma{not\_in\_nodup\_cancel}} and can contradict away the other cases. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.even nodup cancel}{even\_nodup\_cancel}{\coqdoclemma{even\_nodup\_cancel}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{p}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{x}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{H} \coqdocvar{m}. \coqdoctac{intro}. \coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} *. \coqdoctac{pose} (\coqdocvar{H} \coqdocvar{m}) \coqdockw{as} \coqdocvar{H1}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{m}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_even}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqexternalref{negb true iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_true\_iff}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H1} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{remove In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{remove\_In}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{a})).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{destruct} \coqdocvar{H0}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{apply} \coqref{B Unification.list util.In remove}{\coqdoclemma{In\_remove}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqref{B Unification.list util.not in nodup cancel}{\coqdoclemma{not\_in\_nodup\_cancel}} \coqdoctac{in} \coqdocvar{H1}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.list util.In remove}{\coqdoclemma{In\_remove}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{apply} \coqref{B Unification.list util.not in nodup cancel}{\coqdoclemma{not\_in\_nodup\_cancel}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{contradiction}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The above lemma can then be used in combination with \coqref{B Unification.list util.nothing in empty}{\coqdoclemma{nothing\_in\_empty}} to
    easily prove \coqref{B Unification.list util.parity match empty}{\coqdoclemma{parity\_match\_empty}}, which will be useful in two cases of our
    goal lemma. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.parity match empty}{parity\_match\_empty}{\coqdoclemma{parity\_match\_empty}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{q}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{q} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{pose} (\coqref{B Unification.list util.even nodup cancel}{\coqdoclemma{even\_nodup\_cancel}} \coqdocvar{q} \coqdocvar{H}). \coqdoctac{apply} \coqref{B Unification.list util.nothing in empty}{\coqdoclemma{nothing\_in\_empty}} \coqdoctac{in} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{n}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} definition is also reflexive, symmetric, and
    transitive, and knowing this will make future proofs easier. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.parity match refl}{parity\_match\_refl}{\coqdoclemma{parity\_match\_refl}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{l}. \coqdoctac{unfold} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.parity match sym}{parity\_match\_sym}{\coqdoclemma{parity\_match\_sym}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{l} \coqdocvar{m}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} \coqdocvariable{m} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{m}. \coqdoctac{unfold} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}}. \coqdoctac{split}; \coqdoctac{intros} \coqdocvar{H} \coqdocvar{x}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.parity match trans}{parity\_match\_trans}{\coqdoclemma{parity\_match\_trans}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{p} \coqdocvar{q} \coqdocvar{r}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} \coqdocvariable{q} \coqdocvariable{r} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{r}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{unfold} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdoctac{in} *. \coqdoctac{intros} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{parity\_match\_refl} \coqdocvar{parity\_match\_sym} \coqdocvar{parity\_match\_trans}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
There are also a few interesting facts that can be proved about elements
    being \coqdocvar{cons}ed onto lists in a \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}}. First is that if the parity
    of two lists is equal, then the parities will also be equal after adding
    another element to the front, and vice versa. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.parity match cons}{parity\_match\_cons}{\coqdoclemma{parity\_match\_cons}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l1} \coqdocvar{l2},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l1}) (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l2}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l1} \coqdocvariable{l2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l1} \coqdocvar{l2}. \coqdoctac{unfold} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}}. \coqdoctac{split}; \coqdoctac{intros} \coqdocvar{H} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{pose} (\coqdocvar{H} \coqdocvar{x}). \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{e}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{x}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}} \coqdoctac{in} \coqdocvar{e}. \coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_even}} \coqdoctac{in} \coqdocvar{e}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{negb sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_sym}} \coqdoctac{in} \coqdocvar{e}. \coqdoctac{rewrite} \coqexternalref{negb involutive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_involutive}} \coqdoctac{in} \coqdocvar{e}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{x}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}. \coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_even}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{negb sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_sym}}. \coqdoctac{rewrite} \coqexternalref{negb involutive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_involutive}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly, adding the same element twice to a list does not change the
    parities of any elements in the list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.parity match double}{parity\_match\_double}{\coqdoclemma{parity\_match\_double}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}) \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l}. \coqdoctac{unfold} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}}. \coqdoctac{intros} \coqdocvar{x}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{x}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The last \coqdocvar{cons} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} lemma states that if you remove an element
    from one list and add it to the other, the parity will not be affected.
    This follows because if they both had an even number of \coqdocvariable{a} before they
    will both have an odd number after, and if it was odd before it will be
    even after. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.parity match cons swap}{parity\_match\_cons\_swap}{\coqdoclemma{parity\_match\_cons\_swap}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l1} \coqdocvar{l2},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l1}) \coqdocvariable{l2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l1} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l2}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{H}. \coqdoctac{apply} (\coqref{B Unification.list util.parity match cons}{\coqdoclemma{parity\_match\_cons}} \coqdocvar{a}) \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.parity match sym}{\coqdoclemma{parity\_match\_sym}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.list util.parity match trans}{\coqdoclemma{parity\_match\_trans}} \coqdockw{with} (\coqdocvar{r}:=\coqdocvar{l1}) \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.parity match sym}{\coqdoclemma{parity\_match\_sym}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.list util.parity match double}{\coqdoclemma{parity\_match\_double}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This next lemma states that if we know that some element \coqdocvariable{a} appears in
    the \textit{rest} of the list an even number of times, than clearly it appears in
    \coqdocvariable{l2} an odd number of times and must be in the list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.parity match In}{parity\_match\_In}{\coqdoclemma{parity\_match\_In}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{l1} \coqdocvar{l2},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{l1} \coqdocvariable{a}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l1}) \coqdocvariable{l2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{apply} \coqref{B Unification.list util.parity match cons swap}{\coqdoclemma{parity\_match\_cons\_swap}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{H0} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_even}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqexternalref{negb true iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_true\_iff}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} \coqdocvar{l2} \coqdocvar{a} \coqexternalref{::nat scope:x '>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{>}} 0). \coqdoctac{destruct} \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{gt Sn O}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Gt}{\coqdoclemma{gt\_Sn\_O}}. \coqdoctac{apply} \coqexternalref{count occ In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{count\_occ\_In}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The last fact to prove before attempting the big lemma is that if two lists
    are permutations of each other, then their parities must match because
    they contain the same elements the same number of times. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.Permutation parity match}{Permutation\_parity\_match}{\coqdoclemma{Permutation\_parity\_match}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{p} \coqdocvar{q}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{q} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.list util.parity match cons}{\coqdoclemma{parity\_match\_cons}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{repeat} \coqdoctac{apply} \coqref{B Unification.list util.parity match cons swap}{\coqdoclemma{parity\_match\_cons\_swap}}. \coqdoctac{unfold} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}}. \coqdoctac{intros} \coqdocvar{x0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{destruct} \coqdocvar{Aeq\_dec};\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} (\coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}; \coqdoctac{rewrite} \coqexternalref{Nat.odd succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{odd\_succ}}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.list util.parity match trans}{\coqdoclemma{parity\_match\_trans}} \coqdockw{with} (\coqdocvar{q}:=\coqdocvar{l'}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Finally, the big one. The first three cases are straightforward, especially
    now that we have already proven \coqref{B Unification.list util.parity match empty}{\coqdoclemma{parity\_match\_empty}}. The third case is
    more complicated. We begin by destructing if \coqdocvariable{a} and \coqdocvariable{a0} are equal. In the
    case that they are, the proof is relatively straightforward;
    \coqref{B Unification.list util.parity match cons}{\coqdoclemma{parity\_match\_cons}}, \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}, and \coqref{B Unification.list util.remove Permutation}{\coqdoclemma{remove\_Permutation}} take care of it.


    In the case that they are not equal, we next destruct if the number of
    occurences is even or not. If it is odd, we can use \coqref{B Unification.list util.parity match In}{\coqdoclemma{parity\_match\_In}} and
    \coqexternalref{In split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocabbreviation{In\_split}} to rewrite \coqdocvariable{l2} in terms of \coqdocvariable{a}. From there, we use permutation
    facts to rearrange \coqdocvariable{a} to be at the front, and the rest of the proof is
    similar to the proof when \coqdocvariable{a} and \coqdocvariable{a0} are equal.


    The final case is when they are not equal and the number of occurences is
    even. After using \coqref{B Unification.list util.parity match cons swap}{\coqdoclemma{parity\_match\_cons\_swap}}, we can get to a point where we
    know that \coqdocvariable{a} appears in \coqdocvariable{q} ++ \coqdocvariable{a0} an even number of times. This means that
    \coqdocvariable{a} will not be in \coqdocvariable{q} ++ \coqdocvariable{a0} after applying \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}, so we can
    rewrite with \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}} in the reverse direction to get the two sides
    of the permutation goal to be more similar. Then, because it is wrapped in
    \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{a}, we can clearly add an \coqdocvariable{a} on the inside without it having any
    effect. Then all that is left is to apply \coqref{B Unification.list util.remove Permutation}{\coqdoclemma{remove\_Permutation}}, and we end
    up with a goal matching the induction hypothesis.


    This lemma is very powerful, especially when dealing with \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}
    with functions applied to the elements of a list. This will come into
    play later in this file. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.parity nodup cancel Permutation}{parity\_nodup\_cancel\_Permutation}{\coqdoclemma{parity\_nodup\_cancel\_Permutation}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{p} \coqdocvar{q}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p}) (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{q} \coqdocvar{H}. \coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p}; \coqdoctac{induction} \coqdocvar{q}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdocvar{nodup\_cancel} \coqdoctac{at} 1. \coqdoctac{apply} \coqref{B Unification.list util.parity match empty}{\coqdoclemma{parity\_match\_empty}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdocvar{nodup\_cancel} \coqdoctac{at} 2. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqref{B Unification.list util.parity match empty}{\coqdoclemma{parity\_match\_empty}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.parity match sym}{\coqdoclemma{parity\_match\_sym}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{clear} \coqdocvar{IHq}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a0}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.list util.parity match cons}{\coqdoclemma{parity\_match\_cons}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} \coqdocvar{eqn}:\coqdocvar{Hev}; \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hev}; \coqdoctac{rewrite} \coqdocvar{Hev}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}. \coqdoctac{apply} \coqref{B Unification.list util.remove Permutation}{\coqdoclemma{remove\_Permutation}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.list util.remove Permutation}{\coqdoclemma{remove\_Permutation}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl} \coqdocvar{nodup\_cancel} \coqdoctac{at} 1. \coqdoctac{destruct} \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} \coqdocvar{eqn}:\coqdocvar{Hev}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{assert} (\coqdocvar{Hev'}:=\coqdocvar{Hev}).\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{apply} \coqref{B Unification.list util.parity match In}{\coqdoclemma{parity\_match\_In}} \coqdockw{with} (\coqdocvar{l2}:=\coqdocvar{a0} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{q}) \coqdoctac{in} \coqdocvar{Hev}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{destruct} \coqdocvar{Hev}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H0}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{In split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocabbreviation{In\_split}} \coqdoctac{in} \coqdocvar{H0} \coqdockw{as} [\coqdocvar{l1} [\coqdocvar{l2} \coqdocvar{H0}]]. \coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
(\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{l2} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{a0} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{l1})).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{rewrite} \coqexternalref{app comm cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_comm\_cons}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (\coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}). \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{H0} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqref{B Unification.list util.parity match trans}{\coqdoclemma{parity\_match\_trans}} \coqdockw{with} (\coqdocvar{r}:=\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{l2} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{a0} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{l1}) \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqref{B Unification.list util.parity match cons}{\coqdoclemma{parity\_match\_cons}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hev'}. \coqdoctac{rewrite} \coqdocvar{Hev'}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}. \coqdoctac{apply} \coqref{B Unification.list util.remove Permutation}{\coqdoclemma{remove\_Permutation}}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqdocvar{IHp}. \coqdoctac{auto}. \coqdoctac{rewrite} \coqexternalref{app comm cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_comm\_cons}}. \coqdoctac{apply} \coqref{B Unification.list util.Permutation parity match}{\coqdoclemma{Permutation\_parity\_match}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.list util.parity match cons swap}{\coqdoclemma{parity\_match\_cons\_swap}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hev}. \coqdoctac{assert} (\coqdocvar{Hev2}:=\coqdocvar{Hev}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.count occ Permutation}{\coqdoclemma{count\_occ\_Permutation}} \coqdockw{with} (\coqdocvar{l'}:=\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{q} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{a0}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}) \coqdoctac{in} \coqdocvar{Hev}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hev}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}} \coqdoctac{in} \coqdocvar{Hev}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_even}} \coqdoctac{in} \coqdocvar{Hev}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqexternalref{negb false iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_false\_iff}} \coqdoctac{in} \coqdocvar{Hev}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}} \coqdocvar{\_} \coqdocvar{Aeq\_dec} \coqdocvar{a}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{assert} (\coqdockw{\ensuremath{\forall}} \coqdocvar{l}, \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvar{Aeq\_dec} \coqdocvar{a} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{5.00em}
\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvar{Aeq\_dec} \coqdocvar{a} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}))).\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{intros} \coqdocvar{l}. \coqdoctac{simpl}. \coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{\_} \coqdocvar{l} \coqdocvar{a})).\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{a}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{rewrite} (\coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_}(\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_})). \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{remove In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{remove\_In}}.\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{rewrite} (\coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_}(\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_})). \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{remove In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{remove\_In}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} (\coqdocvar{H0} (\coqdocvar{a0}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{q})). \coqdoctac{apply} \coqref{B Unification.list util.remove Permutation}{\coqdoclemma{remove\_Permutation}}. \coqdoctac{apply} \coqdocvar{IHp}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqref{B Unification.list util.not in nodup cancel}{\coqdoclemma{not\_in\_nodup\_cancel}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.count occ Permutation}{\coqdoclemma{count\_occ\_Permutation}} \coqdockw{with} (\coqdocvar{l'}:=\coqdocvar{a0} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{q}) \coqdoctac{in} \coqdocvar{Hev}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{auto}. \coqdoctac{replace} (\coqdocvar{a0}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{q}) \coqdockw{with} (\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{a0}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{q}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}. \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{replace} (\coqdocvar{a0} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{q}) \coqdockw{with} (\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{a0}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{q}); \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Combining nodup\_cancel and Other Functions}

\subsection{Using \texorpdfstring{\protect\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}}{nodup\_cancel} over \texorpdfstring{\protect\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}}{map}}

\begin{coqdoccode}
\end{coqdoccode}
Our next goal is to prove things about the relation between \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}
    and \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} over lists. In particular, we want to prove a lemma similar to
    \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}}, that allows us to remove redundant
    \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}s.


    The challenging part of proving this lemma is that it is often hard to
    reason about how, for example, the number of times \coqdocvariable{a} appears in \coqdocvariable{p}
    relates to the number of times \coqdocvariable{f} \coqdocvariable{a} appears in \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p}. Many of the
    functions we map across lists in practice are not one-to-one, meaning that
    there could be some \coqdocvariable{b} such that \coqdocvariable{f} \coqdocvariable{a} = \coqdocvariable{f} \coqdocvariable{b}. However, at the end of the
    day, these repeated elements will cancel out with each other and the
    parities will match, hence why \coqref{B Unification.list util.parity nodup cancel Permutation}{\coqdoclemma{parity\_nodup\_cancel\_Permutation}} is
    extremely useful.


    To begin, we need to prove a couple facts comparing the number of occurences
    of elements in a list. The first lemma states that the number of times some
    \coqdocvariable{a} appears in \coqdocvariable{p} is less than or equal to the number of times \coqdocvariable{f} \coqdocvariable{a}
    appears in \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ map lt}{count\_occ\_map\_lt}{\coqdoclemma{count\_occ\_map\_lt}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} \coqdocvar{p} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{f},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p}) (\coqdocvariable{f} \coqdocvariable{a}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{a} \coqdocvar{f}. \coqdoctac{induction} \coqdocvar{p}. \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{le n S}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Le}{\coqdoclemma{le\_n\_S}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Building off this idea, the next lemma states that the number of times \coqdocvariable{f} \coqdocvariable{a}
    appears in \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p} with \coqdocvariable{a} removed is equal to the count of \coqdocvariable{f} \coqdocvariable{a} in
    \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p} minus the count of \coqdocvariable{a} in \coqdocvariable{p}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ map sub}{count\_occ\_map\_sub}{\coqdoclemma{count\_occ\_map\_sub}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} \coqdocvar{f} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{p})) (\coqdocvariable{f} \coqdocvariable{a}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p}) (\coqdocvariable{f} \coqdocvariable{a}) \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{-}} \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{a}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{f} \coqdocvar{a} \coqdocvar{p}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec};\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{Aeq\_dec}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e0}; \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqexternalref{Nat.sub succ l}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{sub\_succ\_l}}. \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.list util.count occ map lt}{\coqdoclemma{count\_occ\_map\_lt}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{Aeq\_dec}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}; \coqdocvar{contradiction}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It is also true that if there is some \coqdocvariable{x} that is \textit{not} equal to \coqdocvariable{f} \coqdocvariable{a}, then
    the count of that \coqdocvariable{x} in \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p} is the same as the count of \coqdocvariable{x} in
    \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p} with \coqdocvariable{a} removed. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ map neq remove}{count\_occ\_map\_neq\_remove}{\coqdoclemma{count\_occ\_map\_neq\_remove}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} \coqdocvar{f} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{p} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{f} \coqdocvariable{a} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{p})) \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p}) \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{p} \coqdockw{as} [|\coqdocvar{b}]; \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{a} \coqdocvar{b}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{Aeq\_dec}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e} \coqdoctac{in} \coqdocvar{e0}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e0}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The next lemma is similar to \coqref{B Unification.list util.count occ map lt}{\coqdoclemma{count\_occ\_map\_lt}}, except it involves some \coqdocvariable{b}
    where \coqdocvariable{a} is not equal to \coqdocvariable{b}, but \coqdocvariable{f} \coqdocvariable{a} = \coqdocvariable{f} \coqdocvariable{b}. Then clearly, the sum of \coqdocvariable{a}
    in \coqdocvariable{p} and \coqdocvariable{b} in \coqdocvariable{p} is less than the count of \coqdocvariable{f} \coqdocvariable{a} in \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.f equal sum lt}{f\_equal\_sum\_lt}{\coqdoclemma{f\_equal\_sum\_lt}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} \coqdocvar{f} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{b} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{b} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{a} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{f} \coqdocvariable{a}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{f} \coqdocvariable{b}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{b} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{+}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p}) (\coqdocvariable{f} \coqdocvariable{a}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{f} \coqdocvar{a} \coqdocvar{b} \coqdocvar{p} \coqdocvar{Hne} \coqdocvar{Hfe}. \coqdoctac{induction} \coqdocvar{p} \coqdockw{as} [|\coqdocvar{c}]; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqdocvar{Hfe}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{le n S}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Le}{\coqdoclemma{le\_n\_S}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hfe}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqexternalref{plus comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Plus}{\coqdocabbreviation{plus\_comm}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqexternalref{plus comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Plus}{\coqdocabbreviation{plus\_comm}}. \coqdoctac{apply} \coqexternalref{le n S}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Le}{\coqdoclemma{le\_n\_S}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{le S}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_S}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For the next lemma, we once again try to compare the count of \coqdocvariable{a} to the
    count of \coqdocvariable{f} \coqdocvariable{a}, but also involve \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}. Clearly, there is no way
    for there to be more \coqdocvariable{a}'s in \coqdocvariable{p} than \coqdocvariable{f} \coqdocvariable{a}'s in \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p} even with
    the addition of \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ nodup map lt}{count\_occ\_nodup\_map\_lt}{\coqdoclemma{count\_occ\_nodup\_map\_lt}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} \coqdocvar{p} \coqdocvar{f} (\coqdocvar{a}:\coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p}) \coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p})) (\coqdocvariable{f} \coqdocvariable{a}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{f} \coqdocvar{a}. \coqdoctac{induction} \coqdocvar{p} \coqdockw{as} [|\coqdocvar{b}]; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} \coqdocvar{eqn}:\coqdocvar{Hev}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{apply} \coqexternalref{le n S}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Le}{\coqdoclemma{le\_n\_S}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.count occ remove}{\coqdoclemma{count\_occ\_remove}}. \coqdoctac{apply} \coqexternalref{Nat.le 0 l}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{le\_0\_l}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.count occ neq remove}{\coqdoclemma{count\_occ\_neq\_remove}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{firstorder}. \coqdoctac{apply} \coqref{B Unification.list util.not in nodup cancel}{\coqdoclemma{not\_in\_nodup\_cancel}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{b} \coqdocvar{a}) \coqdocvar{eqn}:\coqdocvar{Hba}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ remove}{\coqdoclemma{count\_occ\_remove}}. \coqdoctac{apply} \coqexternalref{Nat.le 0 l}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{le\_0\_l}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.count occ neq remove}{\coqdoclemma{count\_occ\_neq\_remove}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqdocvar{Aeq\_dec} (\coqdocvar{f} \coqdocvar{b}) (\coqdocvar{f} \coqdocvar{a})) \coqdocvar{eqn}:\coqdocvar{Hfba}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ map sub}{\coqdoclemma{count\_occ\_map\_sub}}. \coqdoctac{rewrite} \coqdocvar{e}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Nat.le add le sub l}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{le\_add\_le\_sub\_l}}. \coqdoctac{apply} \coqref{B Unification.list util.f equal sum lt}{\coqdoclemma{f\_equal\_sum\_lt}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \coqref{B Unification.list util.count occ map neq remove}{\coqdoclemma{count\_occ\_map\_neq\_remove}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
All of these lemmas now come together for the core one, a variation of
    \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}} but involving \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f}. We begin by applying
    \coqref{B Unification.list util.parity nodup cancel Permutation}{\coqdoclemma{parity\_nodup\_cancel\_Permutation}}, and destructing if \coqdocvariable{a} appears in \coqdocvariable{p} an
    even number of times or not.


    The even case is relatively easy to prove, and only involves using the usual
    combination of \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}, \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}}, and \coqref{B Unification.list util.not in nodup cancel}{\coqdoclemma{not\_in\_nodup\_cancel}}.


    The odd case is trickier, and where we involve all of the newly proved
    lemmas. If \coqdocvariable{x} and \coqdocvariable{f} \coqdocvariable{a} are not equal, the proof follows just from
    \coqref{B Unification.list util.count occ map neq remove}{\coqdoclemma{count\_occ\_map\_neq\_remove}} and the induction hypothesis.


    If they are equal, we begin by rewriting with \coqref{B Unification.list util.count occ map sub}{\coqdoclemma{count\_occ\_map\_sub}} and
    \coqexternalref{Nat.even sub}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_sub}}. After a few more rewrites, it becomes the case that we need to
    prove that the boolean equivalence of the parities of \coqdocvariable{f} \coqdocvariable{a} in \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p}
    and \coqdocvariable{a} in \coqdocvariable{p} is equal to the negated parity of \coqdocvariable{f} \coqdocvariable{a} in \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p}.
    Because we know that \coqdocvariable{a} appears in \coqdocvariable{p} an odd number of times from
    destructing \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} earlier, this follows immediately. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nodup cancel map}{nodup\_cancel\_map}{\coqdoclemma{nodup\_cancel\_map}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{p}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}) \coqdocvar{f},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p})))\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{f}. \coqdoctac{apply} \coqref{B Unification.list util.parity nodup cancel Permutation}{\coqdoclemma{parity\_nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}}. \coqdoctac{intros} \coqdocvar{x}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{\_} \coqdocvar{p} \coqdocvar{a})) \coqdocvar{eqn}:\coqdocvar{Hev}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}. \coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_even}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}}. \coqdoctac{rewrite} \coqdocvar{IHp}. \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.list util.not in nodup cancel}{\coqdoclemma{not\_in\_nodup\_cancel}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}}. \coqdoctac{apply} \coqdocvar{IHp}. \coqdoctac{apply} \coqref{B Unification.list util.not in nodup cancel}{\coqdoclemma{not\_in\_nodup\_cancel}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ map sub}{\coqdoclemma{count\_occ\_map\_sub}}. \coqdoctac{rewrite} \coqexternalref{Nat.even sub}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_sub}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e} \coqdoctac{in} \coqdocvar{IHp}. \coqdoctac{rewrite} \coqdocvar{IHp}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ nodup cancel}{\coqdoclemma{count\_occ\_nodup\_cancel}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Hev}. \coqdoctac{rewrite} \coqexternalref{Nat.even succ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_succ}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{Nat.negb even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{negb\_even}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{\_} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvar{f} \coqdocvar{p}) \coqdocvar{\_})); \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.list util.count occ nodup map lt}{\coqdoclemma{count\_occ\_nodup\_map\_lt}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.count occ map neq remove}{\coqdoclemma{count\_occ\_map\_neq\_remove}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Using \texorpdfstring{\protect\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}}{nodup\_cancel} over \texorpdfstring{\protect\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}}}{concat} \texorpdfstring{\protect\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}}{map}}

\begin{coqdoccode}
\end{coqdoccode}
Similarly to map, the same property of not needing repeated \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}s
    applies when the lists are being flattened and mapped over. This final
    section of the file seeks to, in very much the same way as earlier, prove
    this.


    We begin with a simple lemma about math that will come into play soon -
    if a number is less than or equal to 1, then it is either 0 or 1. This is
    immediately solved with firstorder logic. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.n le 1}{n\_le\_1}{\coqdoclemma{n\_le\_1}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} 1 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{n}; \coqdoctac{firstorder}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The main difference between this section and the section about map is that
    all of the functions being mapped will clearly be returning lists as their
    output, and then being concatenated with the rest of the result. This makes
    things slightly harder, as we can't reason about the number of times, for
    example, some \coqdocvariable{f} \coqdocvariable{a} appears in a list. Instead, we have to reason about the
    number of times that some \coqdocvariable{x} appears in a list, where \coqdocvariable{x} is one of the
    elements of the list \coqdocvariable{f} \coqdocvariable{a}.


    In practice, these lemmas are only going to be applied in situations where
    every \coqdocvariable{f} \coqdocvariable{a} has no duplicates in it. In other words, as the lemma above
    states, there will be either 0 or 1 of each \coqdocvariable{x} in a list. The next two
    lemmas prove some consequences of this.


    First is that if the count of \coqdocvariable{x} in \coqdocvariable{f} \coqdocvariable{a} is 0, then clearly removing
    \coqdocvariable{a} from some list \coqdocvariable{p} will not affect the count of \coqdocvariable{x} in the
    concatenated version of the list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ map sub not in}{count\_occ\_map\_sub\_not\_in}{\coqdoclemma{count\_occ\_map\_sub\_not\_in}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} \coqdocvar{f} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{f} \coqdocvariable{a}) \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{p}))) \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p})) \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{f} \coqdocvar{a} \coqdocvar{p} \coqdocvar{x} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{p} \coqdockw{as} [|\coqdocvar{b}]; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{firstorder}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
On the other hand, if the count of some \coqdocvariable{x} in \coqdocvariable{f} \coqdocvariable{a} is 1, then the count
    of \coqdocvariable{a} in the original list must be less than or equal to the count of \coqdocvariable{x}
    in the final list, depending on if some \coqdocvariable{b} exists such that \coqdocvariable{f} \coqdocvariable{a} also
    contains \coqdocvariable{x}. More useful is the fact that if \coqdocvariable{x} appears once in \coqdocvariable{f} \coqdocvariable{x}, the
    count of \coqdocvariable{x} in the final list with \coqdocvariable{a} removed is equal to the count of \coqdocvariable{x}
    in the final list minus the count of \coqdocvariable{a} in the list. Both of these proofs
    are relatively straightforward, and mostly follow from firstorder logic. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ concat map lt}{count\_occ\_concat\_map\_lt}{\coqdoclemma{count\_occ\_concat\_map\_lt}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} \coqdocvar{p} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{f} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{f} \coqdocvariable{a}) \coqdocvariable{x}  \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 1 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p})) \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{a} \coqdocvar{f} \coqdocvar{x} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{p}. \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{simpl}. \coqdoctac{firstorder}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{induction} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{Aeq\_dec} (\coqdocvar{f} \coqdocvar{a0}) \coqdocvar{x}); \coqdoctac{firstorder}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ map sub in}{count\_occ\_map\_sub\_in}{\coqdoclemma{count\_occ\_map\_sub\_in}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} \coqdocvar{f} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{f} \coqdocvariable{a}) \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 1 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqdocvariable{Aeq\_dec} \coqdocvariable{a} \coqdocvariable{p}))) \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p})) \coqdocvariable{x} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{-}} \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{a}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{f} \coqdocvar{a} \coqdocvar{p} \coqdocvar{x} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{p} \coqdockw{as} [|\coqdocvar{b}]; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{e}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{rewrite} \coqdocvar{IHp}. \coqdoctac{rewrite} \coqexternalref{Nat.add sub assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{add\_sub\_assoc}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.count occ concat map lt}{\coqdoclemma{count\_occ\_concat\_map\_lt}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Continuing the pattern of proving similar facts as we did during the
    \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} proof, we now prove a version of \coqref{B Unification.list util.f equal sum lt}{\coqdoclemma{f\_equal\_sum\_lt}} involving \coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}}.
    This lemma states that, if we know there will be no duplicates in \coqdocvariable{f} \coqdocvariable{x} for
    all \coqdocvariable{x}, and that there are some \coqdocvariable{a} and \coqdocvariable{b} such that they are not equal
    but \coqdocvariable{x} in in both \coqdocvariable{f} \coqdocvariable{a} and \coqdocvariable{f} \coqdocvariable{b}, then clearly the sum of the count of \coqdocvariable{a}
    and the count of \coqdocvariable{b} is less than or equal to the count of \coqdocvariable{x} in the list
    after applying the function and flattening. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.f equal concat sum lt}{f\_equal\_concat\_sum\_lt}{\coqdoclemma{f\_equal\_concat\_sum\_lt}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} \coqdocvar{f} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{b} \coqdocvar{p} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{b} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{a} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqdocvariable{f} \coqdocvariable{x})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{f} \coqdocvariable{a}) \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 1 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{f} \coqdocvariable{b}) \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 1 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{b} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{+}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p} \coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p})) \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{f} \coqdocvar{a} \coqdocvar{b} \coqdocvar{p} \coqdocvar{x} \coqdocvar{Hne} \coqdocvar{Hnd} \coqdocvar{Hfa} \coqdocvar{Hfb}. \coqdoctac{induction} \coqdocvar{p} \coqdockw{as} [|\coqdocvar{c}]; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{firstorder}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{firstorder}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{pose} (\coqdocvar{Hnd} \coqdocvar{c}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} (\coqexternalref{NoDup count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_count\_occ}} \coqdocvar{Aeq\_dec}) \coqdoctac{in} \coqdocvar{n1}. \coqdoctac{pose} (\coqdocvar{n1} \coqdocvar{x}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.list util.n le 1}{\coqdoclemma{n\_le\_1}} \coqdoctac{in} \coqdocvar{l}. \coqdoctac{clear} \coqdocvar{n1}. \coqdoctac{destruct} \coqdocvar{l}; \coqdoctac{firstorder}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The last step before we are able to prove \coqref{B Unification.list util.nodup cancel concat map}{\coqdoclemma{nodup\_cancel\_concat\_map}} is
    to actually involve \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} rather than just \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}}. This lemma
    states that given \coqdocvariable{f} \coqdocvariable{x} has no duplicates and \coqdocvariable{a} appears once in \coqdocvariable{f} \coqdocvariable{a},
    the count of \coqdocvariable{a} in \coqdocvariable{p} after applying \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} is less than or equal
    to the count of \coqdocvariable{x} after applying \coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} and \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}.


    The first cases, when the count is even, are relatively straightforward.
    The second cases, when the count is odd, are slightly more complicated. We
    destruct if \coqdocvariable{a} and \coqdocvariable{b} (where \coqdocvariable{b} is our induction element) are equal. If
    they are, then the proof is solved by firstorder logic. On the other hand,
    if they are not, we make use of our \coqref{B Unification.list util.n le 1}{\coqdoclemma{n\_le\_1}} fact proved before to find out
    how many times \coqdocvariable{x} appears in \coqdocvariable{f} \coqdocvariable{b}. If it is zero, then we rewrite with
    the 0 fact proved earlier and are done. In the final case, we rewrite
    with the 1 subtraction fact we proved earlier, and it follows from
    \coqref{B Unification.list util.f equal concat sum lt}{\coqdoclemma{f\_equal\_concat\_sum\_lt}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.count occ nodup concat map lt}{count\_occ\_nodup\_concat\_map\_lt}{\coqdoclemma{count\_occ\_nodup\_concat\_map\_lt}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} \coqdocvar{p} \coqdocvar{f} (\coqdocvar{a}:\coqdocvariable{A}) \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqdocvariable{f} \coqdocvariable{x})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqdocvariable{f} \coqdocvariable{a}) \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 1 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p}) \coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvariable{Aeq\_dec} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p}))) \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{f} \coqdocvar{a} \coqdocvar{x} \coqdocvar{Hn} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{p} \coqdockw{as} [|\coqdocvar{b}]; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} \coqdocvar{eqn}:\coqdocvar{Hev}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{Aeq\_dec}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ remove}{\coqdoclemma{count\_occ\_remove}}, \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{firstorder}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.count occ neq remove}{\coqdoclemma{count\_occ\_neq\_remove}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{firstorder}. \coqdoctac{apply} \coqref{B Unification.list util.not in nodup cancel}{\coqdoclemma{not\_in\_nodup\_cancel}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqdocvar{Aeq\_dec} \coqdocvar{b} \coqdocvar{a}) \coqdocvar{eqn}:\coqdocvar{Hba}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ remove}{\coqdoclemma{count\_occ\_remove}}. \coqdoctac{firstorder}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.list util.count occ neq remove}{\coqdoclemma{count\_occ\_neq\_remove}}; \coqdoctac{auto}. \coqdoctac{assert} (\coqdocvar{Hn1}:=(\coqdocvar{Hn} \coqdocvar{b})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} (\coqexternalref{NoDup count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_count\_occ}} \coqdocvar{Aeq\_dec}) \coqdoctac{in} \coqdocvar{Hn1}. \coqdoctac{assert} (\coqdocvar{Hn2}:=(\coqdocvar{Hn1} \coqdocvar{x})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{clear} \coqdocvar{Hn1}. \coqdoctac{apply} \coqref{B Unification.list util.n le 1}{\coqdoclemma{n\_le\_1}} \coqdoctac{in} \coqdocvar{Hn2}. \coqdoctac{destruct} \coqdocvar{Hn2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \coqref{B Unification.list util.count occ map sub not in}{\coqdoclemma{count\_occ\_map\_sub\_not\_in}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} (\coqref{B Unification.list util.count occ map sub in}{\coqdoclemma{count\_occ\_map\_sub\_in}} \coqdocvar{\_} \coqdocvar{\_} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} \coqdocvar{p})) \coqdoctac{in} \coqdocvar{H0} \coqdockw{as} \coqdocvar{H1}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{apply} \coqexternalref{Nat.le add le sub l}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{le\_add\_le\_sub\_l}}. \coqdoctac{apply} \coqref{B Unification.list util.f equal concat sum lt}{\coqdoclemma{f\_equal\_concat\_sum\_lt}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Finally, the proof we've been building up to. Once again, we begin the proof
    by converting to a \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}} problem and then perform induction on the
    list. The case where \coqdocvariable{a} appears an even number of times in the list is
    easy, and follows from the same combination of \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}} and
    \coqexternalref{Nat.even add}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_add}} that we have used before.


    The case where \coqdocvariable{a} appears an odd number of times is slightly more complex.
    Once again, we apply \coqref{B Unification.list util.n le 1}{\coqdoclemma{n\_le\_1}} to determine how many times our \coqdocvariable{x} appears
    in \coqdocvariable{f} \coqdocvariable{a}. If it is zero times, we use \coqref{B Unification.list util.count occ map sub not in}{\coqdoclemma{count\_occ\_map\_sub\_not\_in}} like above,
    and then the induction hypothesis solves it. If \coqdocvariable{x} appears once in \coqdocvariable{f} \coqdocvariable{a},
    we instead use \coqref{B Unification.list util.count occ map sub in}{\coqdoclemma{count\_occ\_map\_sub\_in}} combined with \coqexternalref{Nat.even sub}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_sub}}. Then, after
    rewriting with the induction hypothesis, we can easily solve the lemma with
    the use of \coqref{B Unification.list util.count occ nodup cancel}{\coqdoclemma{count\_occ\_nodup\_cancel}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.list util.nodup cancel concat map}{nodup\_cancel\_concat\_map}{\coqdoclemma{nodup\_cancel\_concat\_map}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{Aeq\_dec}\} (\coqdocvar{p}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{A}) \coqdocvar{f},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqdocvariable{f} \coqdocvariable{x})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} \coqdocvariable{p}))))\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvariable{Aeq\_dec} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{p}))).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{Aeq\_dec} \coqdocvar{p} \coqdocvar{f} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.list util.parity nodup cancel Permutation}{\coqdoclemma{parity\_nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.list util.parity match}{\coqdocdefinition{parity\_match}}. \coqdoctac{intros} \coqdocvar{x}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{\_} \coqdocvar{p} \coqdocvar{a})) \coqdocvar{eqn}:\coqdocvar{Hev}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{Nat.even add}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_add}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}}. \coqdoctac{rewrite} \coqdocvar{IHp}. \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.list util.not in nodup cancel}{\coqdoclemma{not\_in\_nodup\_cancel}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{assert} (\coqdocvar{H0}:=(\coqdocvar{H} \coqdocvar{a})). \coqdoctac{rewrite} (\coqexternalref{NoDup count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_count\_occ}} \coqdocvar{Aeq\_dec}) \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{H1}:=(\coqdocvar{H0} \coqdocvar{x})). \coqdoctac{clear} \coqdocvar{H0}. \coqdoctac{apply} \coqref{B Unification.list util.n le 1}{\coqdoclemma{n\_le\_1}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ app}{\coqdoclemma{count\_occ\_app}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqexternalref{Nat.even add}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_add}}. \coqdoctac{destruct} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} (\coqref{B Unification.list util.count occ map sub not in}{\coqdoclemma{count\_occ\_map\_sub\_not\_in}} \coqdocvar{\_} \coqdocvar{\_} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} \coqdocvar{p})) \coqdoctac{in} \coqdocvar{H0} \coqdockw{as} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H0}, \coqdocvar{H1}, \coqdocvar{IHp}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{\_} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvar{f} \coqdocvar{p})) \coqdocvar{x})); \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} (\coqref{B Unification.list util.count occ map sub in}{\coqdoclemma{count\_occ\_map\_sub\_in}} \coqdocvar{\_} \coqdocvar{\_} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{Aeq\_dec} \coqdocvar{p})) \coqdoctac{in} \coqdocvar{H0} \coqdockw{as} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H0}, \coqdocvar{H1}, \coqexternalref{Nat.even sub}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{even\_sub}}, \coqdocvar{IHp}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.list util.count occ nodup cancel}{\coqdoclemma{count\_occ\_nodup\_cancel}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Hev}. \coqdoctac{destruct} (\coqexternalref{Nat.even}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{even}} (\coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}} \coqdocvar{\_} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvar{f} \coqdocvar{p})) \coqdocvar{x})); \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.list util.count occ nodup concat map lt}{\coqdoclemma{count\_occ\_nodup\_concat\_map\_lt}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\end{coqdoccode}
\coqlibrary{B Unification.poly}{Library }{B\_Unification.poly}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Arith}{\coqdoclibrary{Arith}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclibrary{List}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Logic.FunctionalExtensionality}{\coqdoclibrary{FunctionalExtensionality}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorting}{\coqdoclibrary{Sorting}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclibrary{Permutation}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{Nat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{B Unification.list util}{\coqdoclibrary{list\_util}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Monomials and Polynomials}



\subsection{Data Type Definitions}



 Now that we have defined those functions over lists and proven all of those
    facts about them, we can begin to apply all of them to our specific project
    of unification. The first step is to define the data structures we plan on
    using.


    As mentioned earlier, because of the ten axioms that hold true during
    \coqdocvariable{B}-unification, we can represent all possible terms with lists of lists of
    numbers. The numbers represent variables, and a list of variables is a
    monomial, where each variable is multiplied together. A polynomial, then, is
    a list of monomials where each monomial is added together.


    In this representation, the term 0 is represented as the empty polynomial,
    and the term 1 is represented as the polynomial containing only the empty
    monomial.


    In addition to the definitions of \coqref{B Unification.poly.var}{\coqdocdefinition{var}}, \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}, and \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}, we also have
    definitions for \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} amd \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}}; these are a proofs of
    decidability of varailes and monomials respectively. They make use of a
    special Coq data structure that allows them to be used as a comparison
    function - for example, we can \coqdoctac{destruct} (\coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} \coqdocvariable{a} \coqdocvariable{b}) to compare the
    two cases where \coqdocvariable{a} = \coqdocvariable{b} and $a \neq b$. In addition to being useful in some
    proofs, this is also needed by some functions, such as \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} and
    \coqexternalref{count occ}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{count\_occ}}, since they compare variables and monomials. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.var}{var}{\coqdocdefinition{var}} := \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.var eq dec}{var\_eq\_dec}{\coqdocdefinition{var\_eq\_dec}} := \coqexternalref{Nat.eq dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{Nat.eq\_dec}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.mono}{mono}{\coqdocdefinition{mono}} := \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.mono eq dec}{mono\_eq\_dec}{\coqdocdefinition{mono\_eq\_dec}} := (\coqexternalref{list eq dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{list\_eq\_dec}} \coqexternalref{Nat.eq dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{Nat.eq\_dec}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.poly}{poly}{\coqdocdefinition{poly}} := \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Comparisons of monomials and polynomials}



 In order to easily compare monomials, we make use of the \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} function we
    defined at the beginning of the \coqdoclibrary{list\_util} file. For convenience, we also
    define \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}}, which is a proposition that states that some monomial is
    less than another. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.mono cmp}{mono\_cmp}{\coqdocdefinition{mono\_cmp}} := \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.mono lt}{mono\_lt}{\coqdocdefinition{mono\_lt}} \coqdocvar{m} \coqdocvar{n} := \coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}} \coqdocvariable{m} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Lt}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A simple but useful definition is \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}}, which allows us to take any
    polynomial and get a list of all the variables in it. This is simply done
    by concatenating all of the monomials into one large list of variables and
    removing any repeated variables.


    Clearly then, there will never be any duplicates in the \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} of some
    polynomial. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.vars}{vars}{\coqdocdefinition{vars}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}} := \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqdocvariable{p}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Unfold} \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.NoDup vars}{NoDup\_vars}{\coqdoclemma{NoDup\_vars}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p}. \coqdoctac{unfold} \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}}. \coqdoctac{apply} \coqexternalref{NoDup nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_nodup}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This next lemma allows us to convert from a statement about \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} to a
    statement about the monomials themselves. If some variable \coqdocvariable{x} is not in the
    variables of a polynomial \coqdocvariable{p}, then every monomial in \coqdocvariable{p} must not contain
    \coqdocvariable{x}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.in mono in vars}{in\_mono\_in\_vars}{\coqdoclemma{in\_mono\_in\_vars}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m} : \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{p}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}} \coqdoctac{in} *. \coqdoctac{intro}. \coqdoctac{apply} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{unfold} \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdoctac{in} *. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{in app or}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_or}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdocvar{exfalso}. \coqdoctac{apply} (\coqdocvar{H} \coqdocvar{a}). \coqdoctac{intuition}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{H} \coqdocvar{m} \coqdocvar{Hin} \coqdocvar{Hin'}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{clear} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdoctac{in} *. \coqdoctac{rewrite} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}}. \coqdoctac{rewrite} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}} \coqdoctac{in} \coqdocvar{IHp}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{in or app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_or\_app}}. \coqdoctac{destruct} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{left}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Stronger Definitions}



 Because, as far as Coq is concerned, any list of natural numbers is a
    monomial, it is necessary to define a few more predicates about monomials
    and polynomials to ensure our desired properties hold. Using these in proofs
    will prevent any random list from being used as a monomial or polynomial.


    Monomials are simply lists of natural numbers that, for ease of comparison,
    are sorted least to greatest. A small sublety is that we are insisting they
    are sorted with \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}}, meaning less than, rather than \coqdocvar{le}, or less than or
    equal to. This way, the \coqdoclibrary{Sorted} predicate will insist that each number is
    \textit{less than} the one following it, thereby preventing any values from being
    equal to each other. In this way, we simultaneously enforce the sorting and
    lack of duplicated values in a monomial. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.is mono}{is\_mono}{\coqdocdefinition{is\_mono}} (\coqdocvar{m} : \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}) : \coqdockw{Prop} := \coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}} \coqdocvariable{m}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Polynomials are sorted lists of lists, where all of the lists in the
    polynomial are monomials. Similarly to the last example, we use \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}}
    to simultaneously enforce sorting and no duplicates. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.is poly}{is\_poly}{\coqdocdefinition{is\_poly}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}} \coqdocvariable{p} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{NoDup\_cons} \coqdocvar{NoDup\_nil} \coqdocvar{Sorted\_cons}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
There are a few useful things we can prove about these definitions too.
    First, because of the sorting, every element in a monomial is guaranteed to
    be less than the element after it. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mono order}{mono\_order}{\coqdoclemma{mono\_order}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} (\coqdocvariable{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{y} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{m}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} \coqexternalref{::nat scope:x '<' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{<}} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{y} \coqdocvar{m} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{HdRel inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{HdRel\_inv}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly, if \coqdocvariable{x} :: \coqdocvariable{m} is a monomial, then \coqdocvariable{m} is also a monomial. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mono cons}{mono\_cons}{\coqdoclemma{mono\_cons}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} (\coqdocvariable{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{m}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} []. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The same properties hold for \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} as well; any list in a polynomial is
    guaranteed to be less than the lists after it, and if \coqdocvariable{m} :: \coqdocvariable{p} is a
    polynomial, we know both that \coqdocvariable{p} is a polynomial and that \coqdocvariable{m} is a
    monomial. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.poly order}{poly\_order}{\coqdoclemma{poly\_order}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqdocvariable{m} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{n} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{p}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}} \coqdocvariable{m} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{HdRel inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{HdRel\_inv}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.poly cons}{poly\_cons}{\coqdoclemma{poly\_cons}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqdocvariable{m} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{p}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{split}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros}. \coqdoctac{apply} \coqdocvar{H0}, \coqexternalref{in cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_cons}}, \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{H0}, \coqexternalref{in eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_eq}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Lastly, for completeness, nil is both a polynomial and monomial, the
    polynomial representation for one as we described before is a polynomial,
    and a singleton variable is a polynomial. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.nil is mono}{nil\_is\_mono}{\coqdoclemma{nil\_is\_mono}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.nil is poly}{nil\_is\_poly}{\coqdoclemma{nil\_is\_poly}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}}. \coqdoctac{split}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro}; \coqdocvar{contradiction}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.one is poly}{one\_is\_poly}{\coqdoclemma{one\_is\_poly}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}}. \coqdoctac{split}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro}. \coqdoctac{intro}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.poly.nil is mono}{\coqdoclemma{nil\_is\_mono}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.var is poly}{var\_is\_poly}{\coqdoclemma{var\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x}. \coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Sorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_cons}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{destruct} \coqdocvar{H}; \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In unification, a common concept is a \textit{ground term}, or a term that contains
    no variables. If some polynomial is a ground term, then it must either be
    equal to 0 or 1. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.no vars is ground}{no\_vars\_is\_ground}{\coqdoclemma{no\_vars\_is\_ground}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{H1} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{inversion} \coqdocvar{H6}. \coqdoctac{inversion} \coqdocvar{H8}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{rewrite} \coqdocvar{H0} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{inversion} \coqdocvar{i}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{mono\_order} \coqdocvar{mono\_cons} \coqdocvar{poly\_order} \coqdocvar{poly\_cons} \coqdocvar{nil\_is\_mono} \coqdocvar{nil\_is\_poly}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{var\_is\_poly} \coqdocvar{one\_is\_poly}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Sorted Lists and Sorting}



 Clearly, because we want to maintain that our monomials and polynomials
    are sorted at all times, we will be dealing with Coq's \coqdoclibrary{Sorted} proposition
    a lot. In addition, not every list we want to operate on will already be
    perfectly sorted, so it is often necessary to sort lists ourselves. This
    next section serves to give us all of the tools necessary to operate on
    sorted lists. 

\subsection{Sorting Lists}



 In order to sort our lists, we will make use of the \coqdoclibrary{Sorting} module in the
    standard library, which implements a version of merge sort.


    For sorting variables in a monomial, we can simply reuse the already
    provided \coqdocvar{NatSort} module. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdockw{Import} \coqdef{B Unification.poly.VarSort}{VarSort}{\coqdocmodule{VarSort}} := \coqexternalref{NatSort}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Mergesort}{\coqdocmodule{NatSort}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Sorting the monomials in a polynomial is slightly more complicated, but
    still straightforward thanks to the \coqdoclibrary{Sorting} module. First, we need to
    define a \coqref{B Unification.poly.MonoOrder}{\coqdocmodule{MonoOrder}}, which must be a total less-than-or-equal-to
    comparator.


    This is accomplished by using our \coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}} defined earlier, and simply
    returning true for either less than or equal to.


    We also prove a relatively simple lemma about this new \coqref{B Unification.poly.MonoOrder}{\coqdocmodule{MonoOrder}}, which
    states that if \coqdocvariable{x} \ensuremath{\le} \coqdocvariable{y} and \coqdocvariable{y} \ensuremath{\le} \coqdocvariable{x}, then \coqdocvariable{x} must be equal to \coqdocvariable{y}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Structures.Orders}{\coqdoclibrary{Orders}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{B Unification.poly.MonoOrder}{MonoOrder}{\coqdocmodule{MonoOrder}} <: \coqexternalref{TotalLeBool}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Structures.Orders}{\coqdocmodule{TotalLeBool}}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Definition} \coqdef{B Unification.poly.MonoOrder.t}{t}{\coqdocdefinition{t}} := \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Definition} \coqdef{B Unification.poly.MonoOrder.leb}{leb}{\coqdocdefinition{leb}} \coqdocvar{m} \coqdocvar{n} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}} \coqdocvariable{m} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Lt}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Eq}} \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Gt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Gt}} \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Infix} \coqdef{B Unification.poly.MonoOrder.:::x '<=m' x}{"}{"}<=m" := \coqref{B Unification.poly.MonoOrder.leb}{\coqdocdefinition{leb}} (\coqdoctac{at} \coqdockw{level} 35).\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Lemma} \coqdef{B Unification.poly.MonoOrder.leb total}{leb\_total}{\coqdoclemma{leb\_total}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n}, \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{m} \coqref{B Unification.poly.MonoOrder.:::x '<=m' x}{\coqdocnotation{\ensuremath{\le}}}\coqref{B Unification.poly.MonoOrder.:::x '<=m' x}{\coqdocnotation{m}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqref{B Unification.poly.MonoOrder.:::x '<=m' x}{\coqdocnotation{\ensuremath{\le}}}\coqref{B Unification.poly.MonoOrder.:::x '<=m' x}{\coqdocnotation{m}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}. \coqdoctac{unfold} "<=m". \coqdoctac{destruct} (\coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}} \coqdocvar{n} \coqdocvar{m}) \coqdocvar{eqn}:\coqdocvar{Hcomp}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}} \coqdoctac{in} *. \coqdoctac{apply} \coqref{B Unification.list util.lex rev lt gt}{\coqdoclemma{lex\_rev\_lt\_gt}} \coqdoctac{in} \coqdocvar{Hcomp}. \coqdoctac{rewrite} \coqdocvar{Hcomp}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{B Unification.poly.MonoOrder}{\coqdocmodule{MonoOrder}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.leb both eq}{leb\_both\_eq}{\coqdoclemma{leb\_both\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdocvariable{x} \coqdocvariable{y}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdocvariable{y} \coqdocvariable{x}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{y} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{unfold} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}}, \coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdoctac{in} *.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}} \coqdocvar{y} \coqdocvar{x}) \coqdocvar{eqn}:\coqdocvar{Hyx}; \coqdoctac{destruct} (\coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}} \coqdocvar{x} \coqdocvar{y}) \coqdocvar{eqn}:\coqdocvar{Hxy};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}} \coqdoctac{in} *;\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{try} (\coqdoctac{apply} \coqref{B Unification.list util.lex rev lt gt}{\coqdoclemma{lex\_rev\_lt\_gt}} \coqdoctac{in} \coqdocvar{Hxy}; \coqdoctac{rewrite} \coqdocvar{Hxy} \coqdoctac{in} \coqdocvar{Hyx}; \coqdoctac{inversion} \coqdocvar{Hyx});\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{try} (\coqdoctac{apply} \coqref{B Unification.list util.lex rev lt gt}{\coqdoclemma{lex\_rev\_lt\_gt}} \coqdoctac{in} \coqdocvar{Hyx}; \coqdoctac{rewrite} \coqdocvar{Hxy} \coqdoctac{in} \coqdocvar{Hyx}; \coqdoctac{inversion} \coqdocvar{Hyx});\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{try} \coqdoctac{inversion} \coqdocvar{H}; \coqdoctac{try} \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.lex eq}{\coqdoclemma{lex\_eq}} \coqdoctac{in} \coqdocvar{Hxy}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
After this order has been defined and its totality has been proven, we
    simply define a new \coqref{B Unification.poly.MonoSort}{\coqdocmodule{MonoSort}} module to be a sort based on this
    \coqref{B Unification.poly.MonoOrder}{\coqdocmodule{MonoOrder}}.


    Now, we have a simple \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} function for both monomials and polynomials,
    as well as a few useful lemmas about the \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} functions' correctness. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdockw{Import} \coqdef{B Unification.poly.MonoSort}{MonoSort}{\coqdocmodule{MonoSort}} := \coqexternalref{Sort}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Mergesort}{\coqdocmodule{Sort}} \coqref{B Unification.poly.MonoOrder}{\coqdocmodule{MonoOrder}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
One technique that helps us deal with the difficulty of sorted lists
    is proving that each of our four comparators - \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}}, \coqdocvar{VarOrder}, \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}},
    and \coqref{B Unification.poly.MonoOrder}{\coqdocmodule{MonoOrder}} - are all transitive. This allows us to seamlessly pass
    between the standard library's \coqdoclibrary{Sorted} and \coqexternalref{StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{StronglySorted}} propositions,
    making many proofs significantly easier.


    All four of these are proved relatively easily, mostly by induction and
    destructing the comparison of the individual values. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.lt Transitive}{lt\_Transitive}{\coqdoclemma{lt\_Transitive}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sets.Relations\_1}{\coqdocdefinition{Relations\_1.Transitive}} \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sets.Relations\_1}{\coqdocdefinition{Relations\_1.Transitive}}. \coqdoctac{intros}. \coqdoctac{apply} \coqexternalref{Nat.lt trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{lt\_trans}} \coqdockw{with} (\coqdocvar{m}:=\coqdocvar{y}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.VarOrder Transitive}{VarOrder\_Transitive}{\coqdoclemma{VarOrder\_Transitive}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sets.Relations\_1}{\coqdocdefinition{Relations\_1.Transitive}} (\coqdockw{fun} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqexternalref{NatOrder.leb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Mergesort}{\coqdocdefinition{NatOrder.leb}} \coqdocvariable{x} \coqdocvariable{y})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sets.Relations\_1}{\coqdocdefinition{Relations\_1.Transitive}}, \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{x}, \coqdocvar{y}, \coqdocvar{z}; \coqdoctac{intros}; \coqdoctac{try} \coqdoctac{reflexivity}; \coqdoctac{simpl} \coqdoctac{in} *.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{IHx} \coqdockw{with} (\coqdocvar{y}:=\coqdocvar{y}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mono lt Transitive}{mono\_lt\_Transitive}{\coqdoclemma{mono\_lt\_Transitive}} : \coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sets.Relations\_1}{\coqdocdefinition{Relations\_1.Transitive}} \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sets.Relations\_1}{\coqdocdefinition{Relations\_1.Transitive}}, \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}}, \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}}, \coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{x}, \coqdocvar{y}, \coqdocvar{z}; \coqdoctac{intros}; \coqdoctac{try} \coqdoctac{reflexivity}; \coqdoctac{simpl} \coqdoctac{in} *.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqdocvar{a} \coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}} \coqdocvar{n0}) \coqdocvar{eqn}:\coqdocvar{Han0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Nat.compare eq iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_eq\_iff}} \coqdoctac{in} \coqdocvar{Han0}. \coqdoctac{rewrite} \coqdocvar{Han0} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqdocvar{n} \coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}} \coqdocvar{n0}) \coqdocvar{eqn}:\coqdocvar{Hn0}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \coqexternalref{Nat.compare antisym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_antisym}} \coqdoctac{in} \coqdocvar{Hn0}. \coqdoctac{unfold} \coqexternalref{CompOpp}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{CompOpp}} \coqdoctac{in} \coqdocvar{Hn0}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{destruct} (\coqdocvar{n0}\coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}}\coqdocvar{n}); \coqdoctac{try} \coqdoctac{inversion} \coqdocvar{Hn0}. \coqdoctac{apply} (\coqdocvar{IHx} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H} \coqdocvar{H0}).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \coqexternalref{Nat.compare antisym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_antisym}} \coqdoctac{in} \coqdocvar{Hn0}. \coqdoctac{unfold} \coqexternalref{CompOpp}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{CompOpp}} \coqdoctac{in} \coqdocvar{Hn0}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{destruct} (\coqdocvar{n0}\coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}}\coqdocvar{n}); \coqdoctac{try} \coqdoctac{inversion} \coqdocvar{Hn0}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} (\coqdocvar{n} \coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}} \coqdocvar{n0}) \coqdocvar{eqn}:\coqdocvar{Hnn0}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Nat.compare eq iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_eq\_iff}} \coqdoctac{in} \coqdocvar{Hnn0}. \coqdoctac{rewrite} \coqdocvar{Hnn0} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{Han0} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Nat.compare lt iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_lt\_iff}} \coqdoctac{in} \coqdocvar{Hnn0}. \coqdoctac{apply} \coqexternalref{Nat.compare gt iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_gt\_iff}} \coqdoctac{in} \coqdocvar{Han0}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Nat.lt trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{lt\_trans}} \coqdockw{with} (\coqdocvar{n}:=\coqdocvar{n}) \coqdoctac{in} \coqdocvar{Han0}; \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{Nat.compare lt iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_lt\_iff}} \coqdoctac{in} \coqdocvar{Han0}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqexternalref{Nat.compare antisym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_antisym}} \coqdoctac{in} \coqdocvar{Han0}. \coqdoctac{unfold} \coqexternalref{CompOpp}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{CompOpp}} \coqdoctac{in} \coqdocvar{Han0}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{destruct} (\coqdocvar{a}\coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}}\coqdocvar{n}); \coqdoctac{try} \coqdoctac{inversion} \coqdocvar{Han0}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.MonoOrder Transitive}{MonoOrder\_Transitive}{\coqdoclemma{MonoOrder\_Transitive}} : \coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sets.Relations\_1}{\coqdocdefinition{Relations\_1.Transitive}} (\coqdockw{fun} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdocvariable{x} \coqdocvariable{y})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sets.Relations\_1}{\coqdocdefinition{Relations\_1.Transitive}}, \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}}, \coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}}, \coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{x}, \coqdocvar{y}, \coqdocvar{z}; \coqdoctac{intros}; \coqdoctac{try} \coqdoctac{reflexivity}; \coqdoctac{simpl} \coqdoctac{in} *.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqdocvar{a} \coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}} \coqdocvar{n}) \coqdocvar{eqn}:\coqdocvar{Han}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Nat.compare eq iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_eq\_iff}} \coqdoctac{in} \coqdocvar{Han}. \coqdoctac{rewrite} \coqdocvar{Han}. \coqdoctac{destruct} (\coqdocvar{n} \coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}} \coqdocvar{n0}) \coqdocvar{eqn}:\coqdocvar{Hn0}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} (\coqdocvar{IHx} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H} \coqdocvar{H0}).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} (\coqdocvar{n} \coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}} \coqdocvar{n0}) \coqdocvar{eqn}:\coqdocvar{Hn0}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Nat.compare eq iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_eq\_iff}} \coqdoctac{in} \coqdocvar{Hn0}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hn0}. \coqdoctac{rewrite} \coqdocvar{Han}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Nat.compare lt iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_lt\_iff}} \coqdoctac{in} \coqdocvar{Han}. \coqdoctac{apply} \coqexternalref{Nat.compare lt iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_lt\_iff}} \coqdoctac{in} \coqdocvar{Hn0}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (\coqexternalref{Nat.lt trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{lt\_trans}} \coqdocvar{a} \coqdocvar{n} \coqdocvar{n0} \coqdocvar{Han}) \coqdoctac{in} \coqdocvar{Hn0}. \coqdoctac{apply} \coqexternalref{Nat.compare lt iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_lt\_iff}} \coqdoctac{in} \coqdocvar{Hn0}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqdocvar{Hn0}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Sorting and Permutations}



 The entire purpose of ensuring our monomials and polynomials remain sorted
    at all times is so that two polynomials containing the same elements are
    treated as equal. This definition obviously lends itself very well to the
    use of the \coqdoclibrary{Permutation} predicate from the standard library, which explains
    why we proved so many lemmas about permutations during \coqdoclibrary{list\_util}.


    When comparing equality of polynomials or monomials, this \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} function is
    often extremely tricky to deal with. Induction over a list being passed to
    \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} is nearly impossible, because the induction element \coqdocvariable{a} is not
    guaranteed to be the least value, so will not easily make it outside of the
    sort function. As a result, the induction hypothesis is almost always
    useless.


    To combat this, we will prove a series of lemmas relating \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} to
    \coqdoclibrary{Permutation}, since clearly sorting has no effect when we are comparing
    the lists in an unordered fashion. The simplest of these lemmas is that
    if either term of a \coqdoclibrary{Permutation} is wrapped in a \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} function, we can
    easily get rid of it without changing the provability of these statements.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.Permutation VarSort l}{Permutation\_VarSort\_l}{\coqdoclemma{Permutation\_VarSort\_l}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{m} \coqdocvariable{n} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvariable{m}) \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{n}. \coqdoctac{split}; \coqdoctac{intro}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqdocvar{m}). \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{VarSort.Permuted\_sort}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvar{m})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{VarSort.Permuted\_sort}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.Permutation VarSort r}{Permutation\_VarSort\_r}{\coqdoclemma{Permutation\_VarSort\_r}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{m} \coqdocvariable{n} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{m} (\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvariable{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{n}. \coqdoctac{split}; \coqdoctac{intro}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation VarSort l}{\coqdoclemma{Permutation\_VarSort\_l}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqref{B Unification.poly.Permutation VarSort l}{\coqdoclemma{Permutation\_VarSort\_l}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.Permutation MonoSort r}{Permutation\_MonoSort\_r}{\coqdoclemma{Permutation\_MonoSort\_r}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{p} (\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{split}; \coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqdocvar{q}). \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvar{q})). \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.Permutation MonoSort l}{Permutation\_MonoSort\_l}{\coqdoclemma{Permutation\_MonoSort\_l}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvariable{p}) \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{split}; \coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort r}{\coqdoclemma{Permutation\_MonoSort\_r}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{rewrite} \coqref{B Unification.poly.Permutation MonoSort r}{\coqdoclemma{Permutation\_MonoSort\_r}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
More powerful is the idea that, if we know we are dealing with sorted lists,
    there is no difference between proving lists are equal and proving they
    are \coqdoclibrary{Permutation}s. While this seems intuitive, it is actually fairly
    complicated to prove in Coq.


    For monomials, the proof begins by performing induction on both lists. The
    first three cases are very straightforward, and the only challenge comes
    from the third case. We approach the third case by first comparing the two
    induction elements, \coqdocvariable{a} and \coqdocvariable{a0}.


    This forms three goals for us - one where \coqdocvariable{a} = \coqdocvariable{a0}, one where \coqdocvariable{a} < \coqdocvariable{a0}, and
    one where \coqdocvariable{a} > \coqdocvariable{a0}. The first goal is extremely straightforward, and follows
    from the induction hypothesis almost immediately after using a few \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}}
    lemmas.


    This leaves us with the next two goals, which seem to be more challenging at
    first. However, some further thought leads us to the conclusion that both
    goals should both be contradictions. If the lists are both sorted, and they
    contain all the same elements, then they should have the same element, at
    the head of the list, which is the least element of the set. This element is
    clearly \coqdocvariable{a} for the first list, and \coqdocvariable{a0} for the second. However, our
    destruct of \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}} has left us with a hypothesis stating that they are
    not equal! This is the source of the contradiction.


    To get Coq to see our contradiction, we first make use of the \coqexternalref{Transitive}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Classes.RelationClasses}{\coqdocclass{Transitive}}
    lemmas we proved earlier to convert to \coqexternalref{StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{StronglySorted}}. This allows us to
    get a hypothesis in the second goal that states that \coqdocvariable{a0} must be less than
    everything in the second list. Because \coqdocvariable{a} is not equal to \coqdocvariable{a0}, this
    implied that \coqdocvariable{a} is somewhere else in the second list, and therefore \coqdocvariable{a0} is
    less than \coqdocvariable{a}. This clearly contradicts the fact that \coqdocvariable{a} < \coqdocvariable{a0}. The third
    goal looks the same, but in reverse. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.Permutation Sorted mono eq}{Permutation\_Sorted\_mono\_eq}{\coqdoclemma{Permutation\_Sorted\_mono\_eq}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{m} \coqdocvar{n} : \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{m} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqexternalref{Nat.leb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqexternalref{Nat.leb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{n} \coqdocvar{Hp} \coqdocvar{Hsl} \coqdocvar{Hsm}. \coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{m}; \coqdoctac{induction} \coqdocvar{n}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_nil}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}, \coqexternalref{Permutation nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_nil}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{clear} \coqdocvar{IHn}. \coqdoctac{apply} \coqref{B Unification.list util.Permutation incl}{\coqdoclemma{Permutation\_incl}} \coqdoctac{in} \coqdocvar{Hp} \coqdockw{as} \coqdocvar{Hp'}. \coqdoctac{destruct} \coqdocvar{Hp'}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqdocvar{a} \coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}} \coqdocvar{a0}) \coqdocvar{eqn}:\coqdocvar{Hcomp}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Nat.compare eq iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_eq\_iff}} \coqdoctac{in} \coqdocvar{Hcomp}. \coqdoctac{rewrite} \coqdocvar{Hcomp} \coqdoctac{in} *.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation cons inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_inv}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{f\_equal}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHm}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{Hsl}. \coqdoctac{apply} \coqdocvar{Hsl}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{Hp}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{Hsm}. \coqdoctac{apply} \coqdocvar{Hsm}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Nat.compare lt iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_lt\_iff}} \coqdoctac{in} \coqdocvar{Hcomp} \coqdockw{as} \coqdocvar{Hneq}. \coqdoctac{apply} \coqref{B Unification.list util.incl cons inv}{\coqdoclemma{incl\_cons\_inv}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{Hsm}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{Hsm} \coqdockw{as} [].\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}; \coqdoctac{try} (\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hneq}; \coqdoctac{apply} \coqexternalref{Nat.lt irrefl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{lt\_irrefl}} \coqdoctac{in} \coqdocvar{Hneq};\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{contradiction}). \coqdoctac{pose} (\coqref{B Unification.list util.Forall In}{\coqdoclemma{Forall\_In}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H} \coqdocvar{H3}). \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{i}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{unfold} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{apply} \coqexternalref{Nat.leb le}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{leb\_le}} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{apply} \coqexternalref{lt not le}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Lt}{\coqdoclemma{lt\_not\_le}} \coqdoctac{in} \coqdocvar{Hneq}.\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.poly.VarOrder Transitive}{\coqdoclemma{VarOrder\_Transitive}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Nat.compare gt iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_gt\_iff}} \coqdoctac{in} \coqdocvar{Hcomp} \coqdockw{as} \coqdocvar{Hneq}. \coqdoctac{apply} \coqref{B Unification.list util.incl cons inv}{\coqdoclemma{incl\_cons\_inv}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{Hsl}. \coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{Hsl} \coqdockw{as} [].\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{destruct} \coqdocvar{H0}; \coqdoctac{try} (\coqdoctac{rewrite} \coqdocvar{H0} \coqdoctac{in} \coqdocvar{Hneq};\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{gt irrefl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Gt}{\coqdoclemma{gt\_irrefl}} \coqdoctac{in} \coqdocvar{Hneq}; \coqdocvar{contradiction}). \coqdoctac{pose} (\coqref{B Unification.list util.Forall In}{\coqdoclemma{Forall\_In}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H0} \coqdocvar{H3}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{unfold} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{apply} \coqexternalref{Nat.leb le}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{leb\_le}} \coqdoctac{in} \coqdocvar{i}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{lt not le}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Lt}{\coqdoclemma{lt\_not\_le}} \coqdoctac{in} \coqdocvar{Hneq}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.poly.VarOrder Transitive}{\coqdoclemma{VarOrder\_Transitive}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We also wish to prove the same thing for polynomials. This proof is
    identical in spirit, as we do the same double induction, destructing of
    compare, and find the same two contradictions. The only difference is the
    use of lemmas about \coqref{B Unification.list util.lex}{\coqdocdefinition{lex}} instead of \coqexternalref{Nat.compare}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{compare}}, since now we are dealing
    with lists of lists. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.Permutation Sorted eq}{Permutation\_Sorted\_eq}{\coqdoclemma{Permutation\_Sorted\_eq}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l} \coqdocvar{m} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} (\coqdockw{fun} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdocvariable{x} \coqdocvariable{y})) \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} (\coqdockw{fun} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdocvariable{x} \coqdocvariable{y})) \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{m} \coqdocvar{Hp} \coqdocvar{Hsl} \coqdocvar{Hsm}. \coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{l}; \coqdoctac{induction} \coqdocvar{m}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_nil}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}, \coqexternalref{Permutation nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_nil}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{clear} \coqdocvar{IHm}. \coqdoctac{apply} \coqref{B Unification.list util.Permutation incl}{\coqdoclemma{Permutation\_incl}} \coqdoctac{in} \coqdocvar{Hp} \coqdockw{as} \coqdocvar{Hp'}. \coqdoctac{destruct} \coqdocvar{Hp'}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}} \coqdocvar{a} \coqdocvar{a0}) \coqdocvar{eqn}:\coqdocvar{Hcomp}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.lex eq}{\coqdoclemma{lex\_eq}} \coqdoctac{in} \coqdocvar{Hcomp}. \coqdoctac{rewrite} \coqdocvar{Hcomp} \coqdoctac{in} *.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation cons inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_inv}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{f\_equal}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHl}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{Hsl}. \coqdoctac{apply} \coqdocvar{Hsl}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{Hp}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{Hsm}. \coqdoctac{apply} \coqdocvar{Hsm}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.lex neq'}{\coqdoclemma{lex\_neq'}} \coqdoctac{in} \coqdocvar{Hcomp} \coqdockw{as} \coqdocvar{Hneq}. \coqdoctac{apply} \coqref{B Unification.list util.incl cons inv}{\coqdoclemma{incl\_cons\_inv}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{Hsm}. \coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{Hsm} \coqdockw{as} [].\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}; \coqdoctac{try} (\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hneq}; \coqdocvar{contradiction}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{pose} (\coqref{B Unification.list util.Forall In}{\coqdoclemma{Forall\_In}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H} \coqdocvar{H3}). \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{unfold} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}},\coqdoceol
\coqdocindent{4.00em}
\coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}}, \coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{apply} \coqref{B Unification.list util.lex rev lt gt}{\coqdoclemma{lex\_rev\_lt\_gt}} \coqdoctac{in} \coqdocvar{Hcomp}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqdocvar{Hcomp} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{inversion} \coqdocvar{i}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.poly.MonoOrder Transitive}{\coqdoclemma{MonoOrder\_Transitive}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.lex neq'}{\coqdoclemma{lex\_neq'}} \coqdoctac{in} \coqdocvar{Hcomp} \coqdockw{as} \coqdocvar{Hneq}. \coqdoctac{apply} \coqref{B Unification.list util.incl cons inv}{\coqdoclemma{incl\_cons\_inv}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{Hsl}. \coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{Hsl} \coqdockw{as} [].\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{destruct} \coqdocvar{H0}; \coqdoctac{try} (\coqdoctac{rewrite} \coqdocvar{H0} \coqdoctac{in} \coqdocvar{Hneq}; \coqdocvar{contradiction}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{pose} (\coqref{B Unification.list util.Forall In}{\coqdoclemma{Forall\_In}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H0} \coqdocvar{H3}). \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{unfold} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} \coqdoctac{in} \coqdocvar{i}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{rewrite} \coqdocvar{Hcomp} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{inversion} \coqdocvar{i}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.poly.MonoOrder Transitive}{\coqdoclemma{MonoOrder\_Transitive}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Another useful form of these two lemmas is that if at any point we are
    attempting to prove that \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} of one list equals \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} of another, we
    can ditch the \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} and instead prove that the two lists are permutations.
    These lemmas will come up a lot in future proofs, and has made some of our
    work much easier. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.Permutation sort mono eq}{Permutation\_sort\_mono\_eq}{\coqdoclemma{Permutation\_sort\_mono\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{m}. \coqdoctac{split}; \coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{assert} (\coqdocvar{H0} : \coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvar{l}) (\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvar{m})).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l}:=(\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvar{l})) (\coqdocvar{l'}:=\coqdocvar{m})\coqdoceol
\coqdocindent{4.00em}
(\coqdocvar{l'{}'}:=\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvar{m}).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{H} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{VarSort.Permuted\_sort}} \coqdocvar{l})).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{VarSort.Permuted\_sort}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} (\coqref{B Unification.poly.Permutation Sorted mono eq}{\coqdoclemma{Permutation\_Sorted\_mono\_eq}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H0} (\coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{VarSort.LocallySorted\_sort}} \coqdocvar{l})\coqdoceol
\coqdocindent{4.00em}
(\coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{VarSort.LocallySorted\_sort}} \coqdocvar{m})).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{assert} (\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvar{l}) (\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvar{m})).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Permutation refl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_refl}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{pose} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{VarSort.Permuted\_sort}} \coqdocvar{l}). \coqdoctac{pose} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{VarSort.Permuted\_sort}} \coqdocvar{m}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{p}) \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{p0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{H0}) \coqdoctac{in} \coqdocvar{p0}. \coqdoctac{apply} \coqdocvar{p0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.Permutation sort eq}{Permutation\_sort\_eq}{\coqdoclemma{Permutation\_sort\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{m} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{m}. \coqdoctac{split}; \coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{assert} (\coqdocvar{H0} : \coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvar{l}) (\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvar{m})).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l}:=\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvar{l}) (\coqdocvar{l'}:=\coqdocvar{m}) (\coqdocvar{l'{}'}:=\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvar{m}).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{H} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}} \coqdocvar{l})).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} (\coqref{B Unification.poly.Permutation Sorted eq}{\coqdoclemma{Permutation\_Sorted\_eq}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H0} (\coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{LocallySorted\_sort}} \coqdocvar{l})\coqdoceol
\coqdocindent{4.00em}
(\coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{LocallySorted\_sort}} \coqdocvar{m})).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{assert} (\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvar{l}) (\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvar{m})).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Permutation refl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_refl}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{pose} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}} \coqdocvar{l}). \coqdoctac{pose} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}} \coqdocvar{m}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{p}) \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{p0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{H0}) \coqdoctac{in} \coqdocvar{p0}. \coqdoctac{apply} \coqdocvar{p0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Repairing Invalid Monomials \& Polynomials}



 Clearly, there is a very strict set of rules we would like to be true about
    all of the polynomials and monomials we workd with. These rules are,
    however, relatively tricky to maintain when it comes to writing functions
    that operate over monomials and polynomials. Rather than rely on our
    ability to define every function to perfectly maintain this set of rules,
    we decided to define two functions to ``repair'' any invalid monomials or
    polynomials. These functions, given a list of variables or a list of list of
    variables, will apply a few functions to them such that at the end, we are
    left with a properly formatted monomial or polynomial. 

\subsection{Converting Between \texorpdfstring{\protect\coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}}}{lt} and \texorpdfstring{\protect}{le}\coqdocvar{le}}



 A small problem with the \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} function provided by the standard
    library is that it requires us to use a \coqdocvar{le} comparator, as opposed to \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}}
    like we use in our \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} and \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} definitions. However, as we said
    before, because our lists have no duplicates \coqdocvar{le} and \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}} are equivalent.
    Obviously, though, saying this isn't enough - we must prove it for it to be
    useful to us in proofs.


    The first step to proving this is proving that this is true when dealing
    with the \coqexternalref{HdRel}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{HdRel}} definition that \coqdoclibrary{Sorted} is built on top of. These lemmas
    state that, if \coqdocvariable{a} holds the \coqdocvar{le} relation with a list, and there are also
    no duplicates in \coqdocvariable{a} :: \coqdocvariable{l}, that \coqdocvariable{a} also holds the \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}} relation with the
    list. These proofs are both relatively straightforward, especially with the
    use of the \coqref{B Unification.list util.NoDup neq}{\coqdoclemma{NoDup\_neq}} lemma proven earlier. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.HdRel le lt}{HdRel\_le\_lt}{\coqdoclemma{HdRel\_le\_lt}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{HdRel}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{HdRel}} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqexternalref{Nat.leb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdocvariable{a} \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{m}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{HdRel}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{HdRel}} \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}} \coqdocvariable{a} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{m} []. \coqdocvar{remember} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqexternalref{Nat.leb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdockw{as} \coqdocvar{le}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{HdRel nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{HdRel\_nil}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{HdRel cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{HdRel\_cons}}. \coqdoctac{apply} \coqexternalref{HdRel inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{HdRel\_inv}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} (\coqref{B Unification.list util.NoDup neq}{\coqdoclemma{NoDup\_neq}} \coqdocvar{\_} \coqdocvar{a} \coqdocvar{n}) \coqdoctac{in} \coqdocvar{H0}; \coqdoctac{intuition}. \coqdoctac{rewrite} \coqdocvar{Heqle} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Nat.leb le}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{leb\_le}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} (\coqdocvar{a} \coqexternalref{::nat scope:x '?=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{?=}} \coqdocvar{n}) \coqdocvar{eqn}:\coqdocvar{Hcomp}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Nat.compare eq iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_eq\_iff}} \coqdoctac{in} \coqdocvar{Hcomp}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Nat.compare lt iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_lt\_iff}} \coqdoctac{in} \coqdocvar{Hcomp}. \coqdoctac{apply} \coqdocvar{Hcomp}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Nat.compare gt iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{compare\_gt\_iff}} \coqdoctac{in} \coqdocvar{Hcomp}. \coqdoctac{apply} \coqexternalref{leb correct conv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Compare\_dec}{\coqdoclemma{leb\_correct\_conv}} \coqdoctac{in} \coqdocvar{Hcomp}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{leb correct}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Compare\_dec}{\coqdoclemma{leb\_correct}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hcomp}. \coqdoctac{inversion} \coqdocvar{Hcomp}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.HdRel mono le lt}{HdRel\_mono\_le\_lt}{\coqdoclemma{HdRel\_mono\_le\_lt}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{HdRel}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{HdRel}} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdocvariable{a} \coqdocvariable{p} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqdocvariable{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{p}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{HdRel}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{HdRel}} \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}} \coqdocvariable{a} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{p} []. \coqdocvar{remember} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdockw{as} \coqdocvar{le}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{HdRel nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{HdRel\_nil}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{HdRel cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{HdRel\_cons}}. \coqdoctac{apply} \coqexternalref{HdRel inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{HdRel\_inv}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} (\coqref{B Unification.list util.NoDup neq}{\coqdoclemma{NoDup\_neq}} \coqdocvar{\_} \coqdocvar{a} \coqdocvar{l}) \coqdoctac{in} \coqdocvar{H0}; \coqdoctac{intuition}. \coqdoctac{rewrite} \coqdocvar{Heqle} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqref{B Unification.poly.mono cmp}{\coqdocdefinition{mono\_cmp}} \coqdocvar{a} \coqdocvar{l}) \coqdocvar{eqn}:\coqdocvar{Hcomp}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.lex eq}{\coqdoclemma{lex\_eq}} \coqdoctac{in} \coqdocvar{Hcomp}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now, to apply these lemmas - we prove that if a list is \coqdoclibrary{Sorted} with a \coqdocvar{le}
    operator and has no duplicates, that it is also \coqdoclibrary{Sorted} with the
    corresponding \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}} operator. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.VarSort Sorted}{VarSort\_Sorted}{\coqdoclemma{VarSort\_Sorted}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqexternalref{Nat.leb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} []. \coqdocvar{remember} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqexternalref{Nat.leb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdockw{as} \coqdocvar{le}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Sorted nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_nil}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Sorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_cons}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHm}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.HdRel le lt}{\coqdoclemma{HdRel\_le\_lt}}. \coqdoctac{split}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Heqle}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.MonoSort Sorted}{MonoSort\_Sorted}{\coqdoclemma{MonoSort\_Sorted}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdocvariable{p} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} []. \coqdocvar{remember} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdockw{as} \coqdocvar{le}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Sorted nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_nil}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Sorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_cons}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.HdRel mono le lt}{\coqdoclemma{HdRel\_mono\_le\_lt}}. \coqdoctac{split}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Heqle}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For convenience, we also include the inverse - if a list is \coqdoclibrary{Sorted} with an
    \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}} operator, it is also \coqdoclibrary{Sorted} with the matching \coqdocvar{le} operator. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.Sorted VarSorted}{Sorted\_VarSorted}{\coqdoclemma{Sorted\_VarSorted}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{m} : \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqexternalref{Nat.leb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Sorted nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_nil}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Sorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_cons}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHSorted}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{l}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{HdRel nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{HdRel\_nil}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{HdRel cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{HdRel\_cons}}. \coqdoctac{apply} \coqexternalref{HdRel inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{HdRel\_inv}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{Nat.lt le incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{lt\_le\_incl}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Nat.leb le}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{leb\_le}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.Sorted MonoSorted}{Sorted\_MonoSorted}{\coqdoclemma{Sorted\_MonoSorted}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} (\coqdockw{fun} \coqdocvar{n} \coqdocvar{m} \ensuremath{\Rightarrow} \coqexternalref{is true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{is\_true}} (\coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}} \coqdocvariable{n} \coqdocvariable{m})) \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Sorted nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_nil}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Sorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_cons}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHSorted}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{l}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{HdRel nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{HdRel\_nil}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{HdRel cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{HdRel\_cons}}. \coqdoctac{apply} \coqexternalref{HdRel inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{HdRel\_inv}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{unfold} \coqref{B Unification.poly.leb}{\coqdocdefinition{MonoOrder.leb}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Another obvious side effect of what we have just proven is that if a list is
    \coqdoclibrary{Sorted} with an \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}} operator, clearly there are no duplicates, as no
    elements are equal to each other. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.NoDup VarSorted}{NoDup\_VarSorted}{\coqdoclemma{NoDup\_VarSorted}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{m}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} []. \coqdoctac{apply} \coqref{B Unification.list util.NoDup forall neq}{\coqdoclemma{NoDup\_forall\_neq}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}}. \coqdoctac{intros} \coqdocvar{x} \coqdocvar{Hin}. \coqdoctac{rewrite} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Nat.lt neq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{lt\_neq}}. \coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHm}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.lt Transitive}{\coqdoclemma{lt\_Transitive}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.NoDup MonoSorted}{NoDup\_MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} []. \coqdoctac{apply} \coqref{B Unification.list util.NoDup forall neq}{\coqdoclemma{NoDup\_forall\_neq}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}}. \coqdoctac{intros} \coqdocvar{x} \coqdocvar{Hin}. \coqdoctac{rewrite} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{pose} (\coqref{B Unification.list util.lex neq'}{\coqdoclemma{lex\_neq'}} \coqdocvar{a} \coqdocvar{x}). \coqdoctac{destruct} \coqdocvar{a0}. \coqdoctac{apply} \coqdocvar{H1} \coqdoctac{in} \coqdocvar{H0}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHp}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.mono lt Transitive}{\coqdoclemma{mono\_lt\_Transitive}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
There are a few more useful lemmas we would like to prove about our sort
    functions before we can define and prove the correctness of our repair
    functions. Mostly, we want to know that sorting a list has no effect on some
    properties of it.


    Specifically, if an element was in a list before it was sorted, it is also
    in it after, and vice versa. Similarly, if a list has no duplicates before
    being sorted, it also has no duplicates after. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.In sorted}{In\_sorted}{\coqdoclemma{In\_sorted}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} (\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{l}. \coqdoctac{pose} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{MonoSort.Permuted\_sort}} \coqdocvar{l}). \coqdoctac{split}; \coqdoctac{intros} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} (\coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdocvar{\_} \coqdocvar{p} \coqdocvar{Hin}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} (\coqexternalref{Permutation in'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinstance{Permutation\_in'}} (\coqexternalref{eq refl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocconstructor{Logic.eq\_refl}} \coqdocvar{a}) \coqdocvar{p}). \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.NoDup VarSort}{NoDup\_VarSort}{\coqdoclemma{NoDup\_VarSort}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{m} : \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hdup}. \coqdoctac{pose} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{VarSort.Permuted\_sort}} \coqdocvar{m}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqexternalref{Permutation NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_NoDup}} \coqdocvar{p} \coqdocvar{Hdup}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.NoDup MonoSort}{NoDup\_MonoSort}{\coqdoclemma{NoDup\_MonoSort}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqref{B Unification.poly.sort}{\coqdocdefinition{MonoSort.sort}} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{Hdup}. \coqdoctac{pose} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{MonoSort.Permuted\_sort}} \coqdocvar{p}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqexternalref{Permutation NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_NoDup}} \coqdocvar{p0} \coqdocvar{Hdup}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Defining the Repair Functions}



 Now time for our definitions. To convert a list of variables into a
    monomial, we first apply \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}}, which removes all duplicates. We use
    \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} rather than \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} because $x \ast x \approx_{B} x$, so we
    want one copy to remain. After applying \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}}, we use our \coqref{B Unification.poly.VarSort}{\coqdocmodule{VarSort}} module
    to sort the list from least to greatest. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.make mono}{make\_mono}{\coqdocdefinition{make\_mono}} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} (\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvariable{l}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The process of converting a list of list of variables into a polynomial is
    very similar. First we \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} across the list applying \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}, so that
    each sublist is properly formatted. Then we apply \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} to remove
    duplicates. In this case, we use \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} instead of \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} because
    \coqdocvariable{x}+\coqdocvariable{x} = 0, so we want pairs to cancel out. Lastly, we use our \coqref{B Unification.poly.MonoSort}{\coqdocmodule{MonoSort}}
    module to sort the list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.make poly}{make\_poly}{\coqdocdefinition{make\_poly}} (\coqdocvar{l}:\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.sort}{\coqdocdefinition{MonoSort.sort}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvariable{l})).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make poly refold}{make\_poly\_refold}{\coqdoclemma{make\_poly\_refold}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvariable{p})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now to prove the correctness of these lists - if you apply \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} to
    something, it is then guaranteed to satisfy the \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} proposition. This
    proof is relatively straightforward, as we have already done most of the
    work with \coqref{B Unification.poly.VarSort Sorted}{\coqdoclemma{VarSort\_Sorted}}; all that is left to do is show that
    \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvariable{m} is \coqdoclibrary{Sorted} and has no duplicates, which is obvious
    considering that is exactly what \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} does! \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make mono is mono}{make\_mono\_is\_mono}{\coqdoclemma{make\_mono\_is\_mono}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m}. \coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}}, \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}. \coqdoctac{apply} \coqref{B Unification.poly.VarSort Sorted}{\coqdoclemma{VarSort\_Sorted}}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{VarSort.LocallySorted\_sort}}.\coqdoceol
\coqdocindent{1.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSort}{\coqdoclemma{NoDup\_VarSort}}. \coqdoctac{apply} \coqexternalref{NoDup nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_nodup}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The proof for \coqref{B Unification.poly.make poly is poly}{\coqdoclemma{make\_poly\_is\_poly}} is almost identical, with the addition of
    one part. The \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} predicate still asks us to prove that the list is
    \coqdoclibrary{Sorted}, which follows from \coqref{B Unification.poly.MonoSort Sorted}{\coqdoclemma{MonoSort\_Sorted}} like above. The only
    difference is that \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} also asks us to show that each element in the
    list \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}}, which follows from the use of a few \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} lemmas and the
    \coqref{B Unification.poly.make mono is mono}{\coqdoclemma{make\_mono\_is\_mono}} we just proved thanks to the \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} in \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make poly is poly}{make\_poly\_is\_poly}{\coqdoclemma{make\_poly\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p}. \coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}}, \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.MonoSort Sorted}{\coqdoclemma{MonoSort\_Sorted}}. \coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{MonoSort.LocallySorted\_sort}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSort}{\coqdoclemma{NoDup\_MonoSort}}. \coqdoctac{apply} \coqref{B Unification.list util.NoDup nodup cancel}{\coqdoclemma{NoDup\_nodup\_cancel}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hm}. \coqdoctac{apply} \coqref{B Unification.poly.In sorted}{\coqdoclemma{In\_sorted}} \coqdoctac{in} \coqdocvar{Hm}. \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel in}{\coqdoclemma{nodup\_cancel\_in}} \coqdoctac{in} \coqdocvar{Hm}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{Hm}. \coqdoctac{destruct} \coqdocvar{Hm}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.make mono is mono}{\coqdoclemma{make\_mono\_is\_mono}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{make\_poly\_is\_poly} \coqdocvar{make\_mono\_is\_mono}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Facts about \texorpdfstring{\protect\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}}{make\_mono}}



 Before we dive into more complicated proofs involving these repair
    functions, there are a few simple lemmas we can prove about them.


    First is that if some variable \coqdocvariable{x} was in a list before \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} was
    applied, it must also be in it after, and vice-versa. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make mono In}{make\_mono\_In}{\coqdoclemma{make\_mono\_In}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvariable{m}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{m}. \coqdoctac{split}; \coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{pose} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{VarSort.Permuted\_sort}} (\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{m})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{p}. \coqdoctac{apply} (\coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdocvar{\_} \coqdocvar{p}) \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}. \coqdoctac{pose} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{VarSort.Permuted\_sort}} (\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{m})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdockw{with} (\coqdocvar{l}:=(\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{m})); \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In addition, if some list \coqdocvariable{m} is already a monomial, removing anything from
    it will not change that. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.remove is mono}{remove\_is\_mono}{\coqdoclemma{remove\_is\_mono}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvariable{x} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdoctac{in} *. \coqdoctac{apply} \coqexternalref{StronglySorted Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_Sorted}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.StronglySorted remove}{\coqdoclemma{StronglySorted\_remove}}. \coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.lt Transitive}{\coqdoclemma{lt\_Transitive}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If we know that some (l1 ++ x :: l2) is a mono, then clearly it is still a
    monomial if we remove the x from the middle, as this will not affect the
    sorting at all. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mono middle}{mono\_middle}{\coqdoclemma{mono\_middle}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{l1} \coqdocvar{l2},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} (\coqdocvariable{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l2}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} (\coqdocvariable{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{l2}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdoctac{in} *. \coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{StronglySorted Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_Sorted}}. \coqdoctac{induction} \coqdocvar{l1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqexternalref{app nil l}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_nil\_l}} \coqdoctac{in} *. \coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} []; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} *. \coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} []. \coqdoctac{apply} \coqexternalref{SSorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{SSorted\_cons}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}}. \coqdoctac{rewrite} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{intros} \coqdocvar{x0} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{Hin} \coqdockw{as} []; \coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.lt Transitive}{\coqdoclemma{lt\_Transitive}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Due to the nature of sorting, \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} is commutative across list
    concatenation. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make mono app comm}{make\_mono\_app\_comm}{\coqdoclemma{make\_mono\_app\_comm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{n}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{n} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{n}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort mono eq}{\coqdoclemma{Permutation\_sort\_mono\_eq}}. \coqdoctac{apply} \coqref{B Unification.list util.Permutation nodup}{\coqdoclemma{Permutation\_nodup}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Finally, if a list \coqdocvariable{m} is a member of the list resulting from
    \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}, then clearly it is a monomial. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mono in map make mono}{mono\_in\_map\_make\_mono}{\coqdoclemma{mono\_in\_map\_make\_mono}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvariable{p}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [\coqdocvar{x} []]. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Facts about \texorpdfstring{\protect\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}}{make\_poly}}



 If two lists are permutations of each other, then they will be equivalent
    after applying \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} to both. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make poly Permutation}{make\_poly\_Permutation}{\coqdoclemma{make\_poly\_Permutation}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}, \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}, \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Because we have shown that \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} and \coqdoclibrary{Permutation} are equivalent, we can
    easily show that \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} is commutative accross list concatenation. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make poly app comm}{make\_poly\_app\_comm}{\coqdoclemma{make\_poly\_app\_comm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqdocvariable{q} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
During \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}, we both \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} and call \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}. A lemma that is
    useful in some cases shows that it doesn't matter what order we do these
    in, as \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} will maintain the order of a list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.sort nodup cancel assoc}{sort\_nodup\_cancel\_assoc}{\coqdoclemma{sort\_nodup\_cancel\_assoc}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation Sorted eq}{\coqdoclemma{Permutation\_Sorted\_eq}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{pose} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} \coqdocvar{l})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{p}. \coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{p}). \coqdoctac{clear} \coqdocvar{p}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{NoDup Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{NoDup\_Permutation}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.NoDup nodup cancel}{\coqdoclemma{NoDup\_nodup\_cancel}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.NoDup nodup cancel}{\coqdoclemma{NoDup\_nodup\_cancel}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{intros} \coqdocvar{x}. \coqdoctac{split}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdockw{with} (\coqdocvar{l}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} \coqdocvar{l}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdockw{with} (\coqdocvar{l}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvar{l})).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{LocallySorted\_sort}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.list util.Sorted nodup cancel}{\coqdoclemma{Sorted\_nodup\_cancel}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.MonoOrder Transitive}{\coqdoclemma{MonoOrder\_Transitive}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{LocallySorted\_sort}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Another obvious but useful lemma is that if a monomial \coqdocvariable{m} is in a list
    resulting from applying \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}, is is clearly a monomial. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mono in make poly}{mono\_in\_make\_poly}{\coqdoclemma{mono\_in\_make\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.poly.In sorted}{\coqdoclemma{In\_sorted}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel in}{\coqdoclemma{nodup\_cancel\_in}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} (\coqref{B Unification.poly.mono in map make mono}{\coqdoclemma{mono\_in\_map\_make\_mono}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Proving Functions ``Pointless''}



 In the \coqdoclibrary{list\_util} file, we have two lemmas revolving around the idea that,
    in some cases, calling \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} is ``pointless''. The idea here is that,
    when comparing very complicated terms, it is sometimes beneficial to either
    add or remove an extra function call that has no effect on the final term.
    Until this point, we have only proven this about \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} and
    \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}}, but there are many other cases where this is true, which will make
    our more complex proofs much easier. This section serves to prove this true
    of most of our functions. 

\subsection{Working with \texorpdfstring{\protect\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}}}{sort} Functions}



 The next two lemmas very simply prove that, if a list is already \coqdoclibrary{Sorted},
    then calling either \coqref{B Unification.poly.VarSort}{\coqdocmodule{VarSort}} or \coqref{B Unification.poly.MonoSort}{\coqdocmodule{MonoSort}} on it will have no effect. This
    is relatively obvious, and is extremely easy to prove with our \coqdoclibrary{Permutation}
    / \coqdoclibrary{Sorted} lemmas from earlier. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.no sort VarSorted}{no\_sort\_VarSorted}{\coqdoclemma{no\_sort\_VarSorted}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqexternalref{Nat.lt}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocdefinition{lt}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.sort}{\coqdocdefinition{VarSort.sort}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation Sorted mono eq}{\coqdoclemma{Permutation\_Sorted\_mono\_eq}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{VarSort.Permuted\_sort}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{VarSort.LocallySorted\_sort}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.Sorted VarSorted}{\coqdoclemma{Sorted\_VarSorted}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.no sort MonoSorted}{no\_sort\_MonoSorted}{\coqdoclemma{no\_sort\_MonoSorted}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Sorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{Sorted}} \coqref{B Unification.poly.mono lt}{\coqdocdefinition{mono\_lt}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.sort}{\coqdocdefinition{MonoSort.sort}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation Sorted eq}{\coqdoclemma{Permutation\_Sorted\_eq}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{LocallySorted\_sort}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.Sorted MonoSorted}{\coqdoclemma{Sorted\_MonoSorted}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The following lemma more closely aligns with the format of the
    \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}} lemma from \coqdoclibrary{list\_util}. It states that if the
    result of appending two lists is already going to be sorted, there is no
    need to sort the intermediate lists.


    This also applies if the sort is wrapped around the right argument, thanks
    to the \coqdoclibrary{Permutation} lemmas we proved earlier. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.sort pointless}{sort\_pointless}{\coqdoclemma{sort\_pointless}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} (\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} \coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation app tail}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_tail}}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Working with \texorpdfstring{\protect\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}}{make\_mono}}



 There are a couple forms that the proof of \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} being pointless can
    take. Firstly, because we already know that \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} simply applies
    functions to get the list into a form that satisfies \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}}, it makes
    sense to prove that if some list is already a mono that \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} will
    have no effect. This is proved with the help of \coqref{B Unification.poly.no sort VarSorted}{\coqdoclemma{no\_sort\_VarSorted}} and
    \coqref{B Unification.list util.no nodup NoDup}{\coqdoclemma{no\_nodup\_NoDup}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.no make mono}{no\_make\_mono}{\coqdoclemma{no\_make\_mono}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}, \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}}. \coqdoctac{intros} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.poly.no sort VarSorted}{\coqdoclemma{no\_sort\_VarSorted}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.list util.no nodup NoDup}{\coqdoclemma{no\_nodup\_NoDup}}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.list util.Sorted nodup}{\coqdoclemma{Sorted\_nodup}}; \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.poly.lt Transitive}{\coqdoclemma{lt\_Transitive}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can also prove the more standard form of \coqref{B Unification.poly.make mono pointless}{\coqdoclemma{make\_mono\_pointless}}, which
    states that if there are nested calls to \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}, we can remove all
    except the outermost layer. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make mono pointless}{make\_mono\_pointless}{\coqdoclemma{make\_mono\_pointless}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{a},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvariable{a}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{a}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{a}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort mono eq}{\coqdoclemma{Permutation\_sort\_mono\_eq}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.list util.nodup pointless}{\coqdoclemma{nodup\_pointless}} \coqdocvar{\_} \coqdocvar{a}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.Permutation nodup}{\coqdoclemma{Permutation\_nodup}}. \coqdoctac{apply} \coqexternalref{Permutation app head}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_head}}. \coqdoctac{unfold} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation VarSort l}{\coqdoclemma{Permutation\_VarSort\_l}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly, if we already know that all of the elements in a list are
    monomials, then mapping \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} across the list will have no effect on
    the entire list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.no map make mono}{no\_map\_make\_mono}{\coqdoclemma{no\_map\_make\_mono}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.poly.no make mono}{\coqdoclemma{no\_make\_mono}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{f\_equal}. \coqdoctac{apply} \coqdocvar{IHp}. \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Lastly, the pointless proof that more closely aligns with what we have done
    so far - if \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} is already being applied to a list, there is no need
    to have a call to \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} on the inside. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.map make mono pointless}{map\_make\_mono\_pointless}{\coqdoclemma{map\_make\_mono\_pointless}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{destruct} \coqdocvar{p}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \coqdoctac{simpl} \coqdocvar{map}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.no make mono}{\coqdoclemma{no\_make\_mono}} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvar{l})); \coqdoctac{auto}. \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvar{\_} \coqdocvar{\_})). \coqdoctac{auto}. \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{Hin}. \coqdoctac{destruct} \coqdocvar{Hin} \coqdockw{as} [\coqdocvar{x}[]]. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Working with \texorpdfstring{\protect\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}}{make\_poly}}



 Finally, we work to prove some lemmas about \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} as a whole being
    pointless. These proofs are built upon the previous few lemmas, which prove
    that we can remove the components of \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} one by one.


    First up, we have a lemma that shows that if \coqdocvariable{p} already has no duplicates
    and everything in the list is a mono, then \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} and
    \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} will both have no effect. This lemma turns out to be very
    useful \textit{after} something like \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}} has been applied, as it
    can strip away the other two functions of \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.unsorted poly}{unsorted\_poly}{\coqdoclemma{unsorted\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvariable{p}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{Hdup} \coqdocvar{Hin}. \coqdoctac{rewrite} \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.no nodup cancel NoDup}{\coqdoclemma{no\_nodup\_cancel\_NoDup}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly to \coqref{B Unification.poly.no make mono}{\coqdoclemma{no\_make\_mono}}, it is very straightforward to prove that if
    some list \coqdocvariable{p} is already a polynomial, then \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} has no effect. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.no make poly}{no\_make\_poly}{\coqdoclemma{no\_make\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}, \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}}. \coqdoctac{intros} \coqdocvar{m} []. \coqdoctac{rewrite} \coqref{B Unification.poly.no sort MonoSorted}{\coqdoclemma{no\_sort\_MonoSorted}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqref{B Unification.list util.no nodup cancel NoDup}{\coqdoclemma{no\_nodup\_cancel\_NoDup}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}}. \coqdoctac{intros} \coqdocvar{m0} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.list util.Sorted nodup cancel}{\coqdoclemma{Sorted\_nodup\_cancel}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.mono lt Transitive}{\coqdoclemma{mono\_lt\_Transitive}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now onto the most important lemma. In many of the later proofs, there will
    be times where there are calls to \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} nested inside of each other,
    or long lists of arguments appended together inside of a \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. In
    either case, the ability to add and remove extra calls to \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} as we
    please proves to be very powerful.


    To prove \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}, we begin by proving a weaker version that
    insists that all of the arguments of \coqdocvariable{p} and \coqdocvariable{q} are all monomials. This
    addition makes the proof significantly easier. As one might expect, the
    proof is completed by using \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}} to remove the sort calls,
    \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}} to remove the \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} calls, and
    \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}} to get rid of the \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} calls. After this is
    done, the two sides are identical. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make poly pointless weak}{make\_poly\_pointless\_weak}{\coqdoclemma{make\_poly\_pointless\_weak}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q} \coqdocvar{Hmp} \coqdocvar{Hmq}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}}; \coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{rewrite} \coqref{B Unification.poly.sort nodup cancel assoc}{\coqdoclemma{sort\_nodup\_cancel\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}}. \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqexternalref{Permutation app tail}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_tail}}. \coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}; \coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}; \coqdoctac{intuition}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.In sorted}{\coqdoclemma{In\_sorted}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel in}{\coqdoclemma{nodup\_cancel\_in}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now, to make the stronger and easier to use version, we simply rewrite in
    the opposite direction with \coqref{B Unification.poly.map make mono pointless}{\coqdoclemma{map\_make\_mono\_pointless}} to add extra calls of
    \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} in! Ironically, this proof \textit{of} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}
    is a great example of why these ``pointless'' lemmas are so useful. While we
    can clearly tell that adding the extra call to \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} makes no
    difference, it makes proving things in a way that Coq understands
    dramatically easier at times.


    After rewriting with \coqref{B Unification.poly.map make mono pointless}{\coqdoclemma{map\_make\_mono\_pointless}}, clearly both areguments
    contain all monomials, and we can use \coqref{B Unification.poly.make poly pointless weak}{\coqdoclemma{make\_poly\_pointless\_weak}} to prove
    the stronger version. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make poly pointless}{make\_poly\_pointless}{\coqdoclemma{make\_poly\_pointless}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.map make mono pointless}{\coqdoclemma{map\_make\_mono\_pointless}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.poly.map make mono pointless}{\coqdoclemma{map\_make\_mono\_pointless}} \coqdocvar{p}). \coqdoctac{rewrite} (\coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}} \coqdocvar{\_} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.poly.map make mono pointless}{\coqdoclemma{map\_make\_mono\_pointless}} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}} \coqdocvar{\_} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvar{p})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.poly.make poly pointless weak}{\coqdoclemma{make\_poly\_pointless\_weak}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvar{p})). \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvar{p})). \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.mono in map make mono}{\coqdoclemma{mono\_in\_map\_make\_mono}}. \coqdoctac{apply} \coqref{B Unification.poly.mono in map make mono}{\coqdoclemma{mono\_in\_map\_make\_mono}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.mono in map make mono}{\coqdoclemma{mono\_in\_map\_make\_mono}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For convenience, we also prove that it applies on the right side by using
    \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}} twice. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make poly pointless r}{make\_poly\_pointless\_r}{\coqdoclemma{make\_poly\_pointless\_r}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Polynomial Arithmetic}



 Now, the foundation for operations on polynomails has been put in place, and
    we can begin to get into the real meat - our arithmetic operators. First up
    is addition. Because we have so cleverly defined our \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} function,
    addition over our data structures is as simple as appending the two
    polynomials and repairing the result back into a proper polynomial.


    We also include a simple refold lemma for convenience, and a quick proof
    that the result of \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} is always a polynomial. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.addPP}{addPP}{\coqdocdefinition{addPP}} (\coqdocvar{p} \coqdocvar{q} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.addPP refold}{addPP\_refold}{\coqdoclemma{addPP\_refold}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.addPP is poly}{addPP\_is\_poly}{\coqdoclemma{addPP\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{apply} \coqref{B Unification.poly.make poly is poly}{\coqdoclemma{make\_poly\_is\_poly}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly, the definition for multiplication becomes much easier with the
    creation of \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. All we need to do is use our \coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}} function
    defined earlier to form all combinations of one monomial from each list, and
    call \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} on the result. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.mulPP}{mulPP}{\coqdocdefinition{mulPP}} (\coqdocvar{p} \coqdocvar{q} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}} \coqdocvariable{p} \coqdocvariable{q}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP is poly}{mulPP\_is\_poly}{\coqdoclemma{mulPP\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{apply} \coqref{B Unification.poly.make poly is poly}{\coqdoclemma{make\_poly\_is\_poly}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{addPP\_is\_poly} \coqdocvar{mulPP\_is\_poly}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
While this definition is elegant, sometimes it is hard to work with. This
    has led us to also create a few more definitions of multiplication. Each is
    just slightly different from the last, which allows us to choose the level
    of completeness we need for any given multiplication proof while knowing
    that at the end of the day, they are all equivalent.


    Each of these new definitions breaks down multiplication into two steps -
    mutliplying a monomial times a polynomial, and multiplying a polynomial
    times a polynomial. Multiplying a monomial times a polynomial is simply
    appending the monomial to each monomial in the polynomial, and multiplying
    two polynomials is just multiplying each monomial in one polynomial times
    the other polynomial.


    The difference in each of the following definitions comes from the
    intermediate step. Because we know that \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} will call \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}, there
    is no need to call \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} on the result of \coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}}, as shown in the
    first definition. However, some proofs are made easier if the result of
    \coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}} is wrapped in \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}, and some are made easier if the
    result is wrapped in a full \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. As a result, we have created each
    of these definitions, and choose between them to help make our proofs
    easier.


    We also include a refolding method for each, for convenience, and a proof
    that each new version is equivalent to the last. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.mulMP}{mulMP}{\coqdocdefinition{mulMP}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) (\coqdocvar{m} : \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} := \coqdoceol
\coqdocindent{1.00em}
\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvariable{m}) \coqdocvariable{p}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.mulPP'}{mulPP'}{\coqdocdefinition{mulPP'}} (\coqdocvar{p} \coqdocvar{q} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}} \coqdocvariable{p}) \coqdocvariable{q})).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP' refold}{mulPP'\_refold}{\coqdoclemma{mulPP'\_refold}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}} \coqdocvariable{p}) \coqdocvariable{q})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP'}{\coqdocdefinition{mulPP'}} \coqdocvariable{p} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP mulPP'}{mulPP\_mulPP'}{\coqdoclemma{mulPP\_mulPP'}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} \coqdocvar{q} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.mulPP'}{\coqdocdefinition{mulPP'}} \coqdocvariable{p} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}, \coqref{B Unification.poly.mulPP'}{\coqdocdefinition{mulPP'}}. \coqdoctac{induction} \coqdocvar{q}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Next, the version including a \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.mulMP'}{mulMP'}{\coqdocdefinition{mulMP'}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) (\coqdocvar{m} : \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvariable{m}) \coqdocvariable{p}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.mulPP''}{mulPP'{}'}{\coqdocdefinition{mulPP'{}'}} (\coqdocvar{p} \coqdocvar{q} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvariable{p}) \coqdocvariable{q})).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP'' refold}{mulPP'{}'\_refold}{\coqdoclemma{mulPP'{}'\_refold}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvariable{p}) \coqdocvariable{q})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvariable{p} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP' mulPP''}{mulPP'\_mulPP'{}'}{\coqdoclemma{mulPP'\_mulPP'{}'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP'}{\coqdocdefinition{mulPP'}} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvariable{p} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP'}{\coqdocdefinition{mulPP'}}, \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}, \coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}}, \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}}, \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.concat map map}{\coqdoclemma{concat\_map\_map}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvar{\_} \coqdocvar{\_})); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [\coqdocvar{n} []].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And finally, the version including a full \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.mulMP''}{mulMP'{}'}{\coqdocdefinition{mulMP'{}'}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) (\coqdocvar{m} : \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvariable{m}) \coqdocvariable{p}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly.mulPP'''}{mulPP'{}'{}'}{\coqdocdefinition{mulPP'{}'{}'}} (\coqdocvar{p} \coqdocvar{q} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvariable{p}) \coqdocvariable{q})).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP''' refold}{mulPP'{}'{}'\_refold}{\coqdoclemma{mulPP'{}'{}'\_refold}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvariable{p}) \coqdocvariable{q})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP'''}{\coqdocdefinition{mulPP'{}'{}'}} \coqdocvariable{p} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In order to make the proof of going from \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} to \coqref{B Unification.poly.mulPP'''}{\coqdocdefinition{mulPP'{}'{}'}} easier, we
    begin by proving that we can go from their corresponding \coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}}s if they
    are wrapped in a \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulMP' mulMP''}{mulMP'\_mulMP'{}'}{\coqdoclemma{mulMP'\_mulMP'{}'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvariable{p} \coqdocvariable{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvariable{p} \coqdocvariable{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{unfold} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}}, \coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.map make mono pointless}{\coqdoclemma{map\_make\_mono\_pointless}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdoctac{at} 2.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvar{\_})). \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdoctac{at} 3.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}} \coqdocvar{\_} \coqdocvar{q}). \coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.poly.map make mono pointless}{\coqdoclemma{map\_make\_mono\_pointless}} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}. \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.poly.mono in map make mono}{\coqdoclemma{mono\_in\_map\_make\_mono}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP'' mulPP'''}{mulPP'{}'\_mulPP'{}'{}'}{\coqdoclemma{mulPP'{}'\_mulPP'{}'{}'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.mulPP'''}{\coqdocdefinition{mulPP'{}'{}'}} \coqdocvariable{p} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{induction} \coqdocvar{q}. \coqdoctac{auto}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}, \coqref{B Unification.poly.mulPP'''}{\coqdocdefinition{mulPP'{}'{}'}}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulMP' mulMP''}{\coqdoclemma{mulMP'\_mulMP'{}'}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}} \coqdocvar{\_} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqdocvar{\_})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{f\_equal}. \coqdoctac{f\_equal}. \coqdoctac{apply} \coqdocvar{IHq}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Again, for convenience, we add lemmas to skip from \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} to any of the
    other varieties. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP mulPP''}{mulPP\_mulPP'{}'}{\coqdoclemma{mulPP\_mulPP'{}'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvariable{p} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP'}{\coqdoclemma{mulPP\_mulPP'}}, \coqref{B Unification.poly.mulPP' mulPP''}{\coqdoclemma{mulPP'\_mulPP'{}'}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP mulPP'''}{mulPP\_mulPP'{}'{}'}{\coqdoclemma{mulPP\_mulPP'{}'{}'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.mulPP'''}{\coqdocdefinition{mulPP'{}'{}'}} \coqdocvariable{p} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP''}{\coqdoclemma{mulPP\_mulPP'{}'}}, \coqref{B Unification.poly.mulPP'' mulPP'''}{\coqdoclemma{mulPP'{}'\_mulPP'{}'{}'}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqref{B Unification.poly.mulPP'}{\coqdocdefinition{mulPP'}} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqref{B Unification.poly.mulPP'''}{\coqdocdefinition{mulPP'{}'{}'}} \coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Proving the 10 \texorpdfstring{\protect\coqdocvariable{B}}{B}-unification Axioms}



 Now that we have defined our operations so carefully, we want to prove that
    the 10 standard \coqdocvariable{B}-unification axioms all apply. This is extremely
    important, as they will both be needed in the higher-level proofs of our
    unification algorithm, and they show that our list-of-list setup is actually
    correct and equivalent to any other representation of a term. 

\subsection{Axiom 1: Additive Inverse}



 We begin with the inverse and identity for each addition and multiplication.
    First is the additive inverse, which states that forall terms \coqdocvariable{x},
    $(x + x)\downarrow_{P} 0$.


    Thanks to the definition of \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} and the previously proven
    \coqref{B Unification.list util.nodup cancel self}{\coqdoclemma{nodup\_cancel\_self}}, this proof is extremely simple. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.addPP p p}{addPP\_p\_p}{\coqdoclemma{addPP\_p\_p}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p}. \coqdoctac{unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel self}{\coqdoclemma{nodup\_cancel\_self}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Axiom 2: Additive Identity}



 Next, we prove the additive identity: for all terms \coqdocvariable{x},
    $(0 + x)\downarrow_{P} = x\downarrow_{P}$. This also applies in the right
    direction, and is extremely easy to prove since we already know that
    appending \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} to a list results in that list.


    Something to note is that, unlike some of the other of the ten axioms, this
    one is \textit{only} true if \coqdocvariable{p} is already a polynomial. Clearly, if it wasn't,
    \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} would not return the same \coqdocvariable{p}, but rather \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p}, since
    \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} will only return proper polynomials. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.addPP 0}{addPP\_0}{\coqdoclemma{addPP\_0}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{Hpoly}. \coqdoctac{unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}. \coqdoctac{simpl}. \coqdoctac{apply} \coqref{B Unification.poly.no make poly}{\coqdoclemma{no\_make\_poly}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.addPP 0r}{addPP\_0r}{\coqdoclemma{addPP\_0r}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{Hpoly}. \coqdoctac{unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}. \coqdoctac{rewrite} \coqexternalref{app nil r}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_nil\_r}}. \coqdoctac{apply} \coqref{B Unification.poly.no make poly}{\coqdoclemma{no\_make\_poly}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Axiom 3: Multiplicative Identity - 1}



 Now onto multiplication. In \coqdocvariable{B}-unification, there are \textit{two} multiplicative
    identities. We begin with the easier to prove of the two, which is 1. In
    other words, for any term \coqdocvariable{x}, $(x \ast 1)\downarrow_{P} = x\downarrow_{P}$.


    This proof is also very simply proved because of how appending \coqexternalref{nil}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} works.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP 1r}{mulPP\_1r}{\coqdoclemma{mulPP\_1r}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}, \coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqexternalref{app nil r}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_nil\_r}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqexternalref{map id}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_id}}. \coqdoctac{apply} \coqref{B Unification.poly.no make poly}{\coqdoclemma{no\_make\_poly}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Axiom 4: Multiplicative Inverse}



 Next is the multiplicative inverse, which states that for any term \coqdocvariable{x},
    $(0 \ast x)\downarrow_{P} = 0$.


    This is proven immediately by the \coqref{B Unification.list util.distribute nil}{\coqdoclemma{distribute\_nil}} lemmas we proved in
    \coqdoclibrary{list\_util}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP 0}{mulPP\_0}{\coqdoclemma{mulPP\_0}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}. \coqdoctac{rewrite} (@\coqref{B Unification.list util.distribute nil}{\coqdoclemma{distribute\_nil}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}}). \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP 0r}{mulPP\_0r}{\coqdoclemma{mulPP\_0r}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}. \coqdoctac{rewrite} (@\coqref{B Unification.list util.distribute nil r}{\coqdoclemma{distribute\_nil\_r}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}}). \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Axiom 5: Commutativity of Addition}



 The next of the ten axioms states that, for all terms \coqdocvariable{x} and \coqdocvariable{y},
    $(x + y)\downarrow_{P} = (y + x)\downarrow_{P}$.


    This axiom is also rather easy, and follows entirely from the
    \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}} lemma we proved earlier due to our clever addition
    definition. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.addPP comm}{addPP\_comm}{\coqdoclemma{addPP\_comm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{q} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}. \coqdoctac{apply} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Axiom 6: Associativity of Addition}



 The next axiom states that, for all terms \coqdocvariable{x}, \coqdocvariable{y}, and \coqdocvariable{z},
    $(x + (y + z))\downarrow_{P} = ((x + y) + z)\downarrow_{P}$.


    Thanks to \coqref{B Unification.poly.addPP comm}{\coqdoclemma{addPP\_comm}} and all of the ``pointless'' lemmas we proved earlier,
    this proof is much easier than it might have been otherwise. These lemmas
    allow us to easily manipulate the operations until we end by proving that
    \coqdocvariable{p} ++ \coqdocvariable{q} ++ \coqdocvariable{r} is a permutation of \coqdocvariable{q} ++ \coqdocvariable{r} ++ \coqdocvariable{p}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.addPP assoc}{addPP\_assoc}{\coqdoclemma{addPP\_assoc}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} \coqdocvariable{q}) \coqdocvariable{r} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{q} \coqdocvariable{r}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r}. \coqdoctac{rewrite} (\coqref{B Unification.poly.addPP comm}{\coqdoclemma{addPP\_comm}} \coqdocvar{\_} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvar{\_} \coqdocvar{\_})). \coqdoctac{unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}. \coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}. \coqdoctac{rewrite} (\coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}} \coqdockw{with} (\coqdocvar{l'}:=\coqdocvar{q} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{r}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Axiom 7: Commutativity of Multiplication}



 Now onto the harder half of the axioms. This next one states that for all
    terms \coqdocvariable{x} and \coqdocvariable{y}, $(x \ast y)\downarrow_{P} = (y \ast x)\downarrow_{P}$. In
    order to prove this, we have opted to use the second version of \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}},
    which wraps the monomial multiplication in a \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}.


    The proof begins with double induction, and the first three cases are rather
    simple. The fourth case is slightly more complicated, but the
    \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}} lemma we proved earlier plays a huge role in making it
    simpler. We begin by simplifying, so that the \coqdocvariable{m} created by induction on
    \coqdocvariable{q} is distributed across the list on the left side, and the \coqdocvariable{a} created by
    induction on \coqdocvariable{p} is distributed accross the list on the right side. Then, we
    use \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}} to surround the rightmost term - which now has \coqdocvariable{a}
    but not \coqdocvariable{m} on the left and \coqdocvariable{m} but not \coqdocvariable{a} on the right - with \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.
    This additional \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} allows us to refold the mess of \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}s and
    \coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}}s into \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}, like they used to be. From there, we use the two
    induction hypotheses to apply commutativity, remove the redundant
    \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}s we added, and simplify again.


    In this way, we are able to cause both \coqdocvariable{a} and \coqdocvariable{m} to be distributed across
    the whole list on both the left and right sides of the equation. At this
    point, it simply requires some rearranging of \coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} with the help of
    \coqdoclibrary{Permutation}, and our left and right sides are equal.


    Without the help of \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}, we would not have been able to
    use the induction hypotheses until much later in the proof, and the proof
    would have been dramatically longer. This also makes it more readable as
    you step through the proof, as we can seamlessly move between the original
    form including \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} and the more functional form consisting of \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}
    and \coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP comm}{mulPP\_comm}{\coqdoclemma{mulPP\_comm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqdocvariable{q} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{q} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP''}{\coqdoclemma{mulPP\_mulPP'{}'}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{q}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{induction} \coqdocvar{q} \coqdockw{as} [|\coqdocvar{m}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}, \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}}. \coqdoctac{simpl}. \coqdoctac{rewrite} (@\coqref{B Unification.list util.concat map nil}{\coqdoclemma{concat\_map\_nil}} \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}). \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}, \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}}. \coqdoctac{simpl}. \coqdoctac{rewrite} (@\coqref{B Unification.list util.concat map nil}{\coqdoclemma{concat\_map\_nil}} \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}). \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}. \coqdoctac{simpl}. \coqdoctac{rewrite} (\coqexternalref{app comm cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_comm\_cons}} \coqdocvar{\_} \coqdocvar{\_} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvar{a}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}}\coqdocvar{m}))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP'' refold}{\coqdoclemma{mulPP'{}'\_refold}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}}. \coqdoctac{simpl}. \coqdoctac{unfold} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdoctac{at} 2.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqexternalref{app comm cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_comm\_cons}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP'' refold}{\coqdoclemma{mulPP'{}'\_refold}}. \coqdoctac{rewrite} \coqdocvar{IHq}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}}. \coqdoctac{simpl}. \coqdoctac{unfold} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdoctac{at} 1.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqexternalref{app comm cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_comm\_cons}}. \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP'' refold}{\coqdoclemma{mulPP'{}'\_refold}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHp}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}}. \coqdoctac{simpl}. \coqdoctac{rewrite} (\coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvar{\_} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvar{\_} \coqdocvar{q}))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make mono app comm}{\coqdoclemma{make\_mono\_app\_comm}}. \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation app tail}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_tail}}. \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Axiom 8: Associativity of Multiplication}



 The eigth axiom states that, for all terms \coqdocvariable{x}, \coqdocvariable{y}, and \coqdocvariable{z},
    $(x \ast (y \ast z))\downarrow_{P} = ((x \ast y) \ast z)\downarrow_{P}$.


    This one is also fairly complicated, so we will start small and build up to
    it. First, we prove a convenient side effect of \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}, which
    allows us to simplify \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} into a \coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}} and a \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}. Unlike
    commutativity, for this proof we opt to use the version of \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} that
    includes a \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} in its \coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}}, in addition to the \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}
    version used previously. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP'' cons}{mulPP'{}'\_cons}{\coqdoclemma{mulPP'{}'\_cons}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{q} \coqdocvar{a} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvariable{q} \coqdocvariable{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvariable{q} \coqdocvariable{p}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvariable{q} (\coqdocvariable{a}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{q} \coqdocvar{a} \coqdocvar{p}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Next is a deceptively easy lemma \coqref{B Unification.poly.map app make poly}{\coqdoclemma{map\_app\_make\_poly}}, which is the primary
    application of \coqref{B Unification.list util.nodup cancel map}{\coqdoclemma{nodup\_cancel\_map}}, proven in \coqdoclibrary{list\_util}. It states that if
    we are applying \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} twice, we can remove the second application,
    even if there is a \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} in between them. Clearly, here, the \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}}
    is in reference to \coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.map app make poly}{map\_app\_make\_poly}{\coqdoclemma{map\_app\_make\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{a}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{a}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvariable{m}) (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvariable{m}) \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{p} \coqdocvar{Hm}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvar{m}) (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvar{p})))))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{repeat} \coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort l}{\coqdoclemma{Permutation\_MonoSort\_l}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}} \coqdocvar{p}); \coqdoctac{auto}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel map}{\coqdoclemma{nodup\_cancel\_map}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqref{B Unification.poly.map app make poly}{\coqdoclemma{map\_app\_make\_poly}} lemma is then immediately applied here, to state
    that since \coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} already applies \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} to its result, we can
    remove any \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} calls inside. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulMP'' make poly}{mulMP'{}'\_make\_poly}{\coqdoclemma{mulMP'{}'\_make\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{a}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{a}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p}) \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvariable{p} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{m}. \coqdoctac{unfold} \coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}}. \coqdoctac{apply} \coqref{B Unification.poly.map app make poly}{\coqdoclemma{map\_app\_make\_poly}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This very simple lemma states that since \coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}} is effectively just a
    \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}, it distributes over \coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulMP' app}{mulMP'\_app}{\coqdoclemma{mulMP'\_app}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} (\coqdocvariable{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{q}) \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvariable{p} \coqdocvariable{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvariable{q} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q} \coqdocvar{m}. \coqdoctac{unfold} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now into the meat of the associativity proof. We begin by proving that
    \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} is associative. This proof is straightforward, and is proven by
    induction with the use of \coqref{B Unification.poly.make mono pointless}{\coqdoclemma{make\_mono\_pointless}} and
    \coqref{B Unification.poly.Permutation sort mono eq}{\coqdoclemma{Permutation\_sort\_mono\_eq}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulMP' assoc}{mulMP'\_assoc}{\coqdoclemma{mulMP'\_assoc}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{q} \coqdocvar{a} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvariable{q} \coqdocvariable{a}) \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvariable{q} \coqdocvariable{m}) \coqdocvariable{a}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{q} \coqdocvar{a} \coqdocvar{m}. \coqdoctac{unfold} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}}. \coqdoctac{induction} \coqdocvar{q}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.make mono pointless}{\coqdoclemma{make\_mono\_pointless}}. \coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort mono eq}{\coqdoclemma{Permutation\_sort\_mono\_eq}}. \coqdoctac{apply} \coqref{B Unification.list util.Permutation nodup}{\coqdoclemma{Permutation\_nodup}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}. \coqdoctac{apply} \coqexternalref{Permutation app tail}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_tail}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{IHq}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For the final associativity proof, we begin by using the commutativity lemma
    to make it so that \coqdocvariable{q} is on the leftmost side of the multiplications. This
    means that it will never be the polynomial being mapped across, and allows
    us to do induction on just \coqdocvariable{p} and \coqdocvariable{r} instead of all three. Thus \coqdocvariable{p}
    becomes \coqdocvariable{a} :: \coqdocvariable{p}, and \coqdocvariable{r} becomes \coqdocvariable{m} :: \coqdocvariable{r}.


    The first three cases are easily solved with some rewrites and a call to
    auto, so we move on to the fourth. Similarly to the commutativity proof, the
    main struggle here is forcing \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} to map across the same term on both
    sides of the equation. This is accomplished in a very similar way - by
    simplifying, using \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}} to get \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} back in the goal,
    and then applying the two induction hypotheses to reorder the terms.


    The crucial point is when we rewrite with \coqref{B Unification.poly.mulMP' mulMP''}{\coqdoclemma{mulMP'\_mulMP'{}'}}, allowing us to
    wrap our \coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}}s in \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} and make use of the lemmas we proved
    earlier in this section. This technique enables us to reorder the
    multiplications in a way that is convenient for us;
    $((q \ast [a :: p]) \ast m)\downarrow_{P}$ becomes
    $((q \ast a) \ast m)\downarrow_{P} ++ ((q \ast p) \ast m)\downarrow_{P}$. At
    the end of all of this rewriting, we are left with the original
    $(p \ast q \ast r)\downarrow_{P}$ as the last term of both sides, and
    $(q \ast p \ast m)\downarrow_{P}$ and $(q \ast r \ast a)\downarrow_{P}$ as
    the middle terms of both. These three terms are easily eliminated with the
    standard \coqdoclibrary{Permutation} lemmas, because they are on both sides.


    The only remaining challenge comes from the first term on each side; on the
    left, we have $((q \ast a) \ast m)\downarrow_{P}$, and on the right we have
    $((q \ast m) \ast a)\downarrow_{P}$. This is where the above \coqref{B Unification.poly.mulMP' assoc}{\coqdoclemma{mulMP'\_assoc}}
    lemma comes into play, solving the last piece of the associativity lemma. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP assoc}{mulPP\_assoc}{\coqdoclemma{mulPP\_assoc}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqdocvariable{q}) \coqdocvariable{r} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{q} \coqdocvariable{r}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r}. \coqdoctac{rewrite} (\coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}} \coqdocvar{\_} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvar{q} \coqdocvar{\_})). \coqdoctac{rewrite} (\coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}} \coqdocvar{p} \coqdocvar{\_}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{r}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{induction} \coqdocvar{r} \coqdockw{as} [|\coqdocvar{m}];\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP 0}{\coqdoclemma{mulPP\_0}}; \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP 0r}{\coqdoclemma{mulPP\_0r}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP''}{\coqdoclemma{mulPP\_mulPP'{}'}} \coqdoctac{in} *. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}} \coqdocvar{\_} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqdocvar{\_})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP'' refold}{\coqdoclemma{mulPP'{}'\_refold}}. \coqdoctac{repeat} \coqdoctac{rewrite} (\coqref{B Unification.poly.mulPP'' cons}{\coqdoclemma{mulPP'{}'\_cons}} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} (\coqdocvar{IHp} (\coqdocvar{m}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{r})). \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP''}{\coqdoclemma{mulPP\_mulPP'{}'}} \coqdoctac{in} \coqdocvar{e}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{IHr}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdoctac{at} 2, \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdoctac{at} 4. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}} \coqdocvar{\_} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqdocvar{\_})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP'' refold}{\coqdoclemma{mulPP'{}'\_refold}}. \coqdoctac{pose} (\coqdocvar{IHp} \coqdocvar{r}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP''}{\coqdoclemma{mulPP\_mulPP'{}'}} \coqdoctac{in} \coqdocvar{e0}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulMP' mulMP''}{\coqdoclemma{mulMP'\_mulMP'{}'}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.mulPP'' cons}{\coqdoclemma{mulPP'{}'\_cons}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulMP'' make poly}{\coqdoclemma{mulMP'{}'\_make\_poly}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.mulMP' mulMP''}{\coqdoclemma{mulMP'\_mulMP'{}'}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}. \coqdoctac{apply} \coqexternalref{Permutation app tail}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_tail}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulMP' app}{\coqdoclemma{mulMP'\_app}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulMP' assoc}{\coqdoclemma{mulMP'\_assoc}}. \coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}. \coqdoctac{apply} \coqexternalref{Permutation app head}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_head}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}. \coqdoctac{intros} \coqdocvar{a0} \coqdocvar{Hin}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{Hin} \coqdockw{as} [].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [\coqdocvar{x}[]]. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{B Unification.poly.make poly is poly}{\coqdoclemma{make\_poly\_is\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{q}) \coqdocvar{r}))). \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a0} \coqdocvar{Hin}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{Hin} \coqdockw{as} []. \coqdoctac{unfold} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [\coqdocvar{x}[]]. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{B Unification.poly.make poly is poly}{\coqdoclemma{make\_poly\_is\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{q}) \coqdocvar{p}))). \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Axiom 9: Multiplicative Identity - Self}



 Next comes the other multiplicative identity mentioned earlier. This axiom
    states that for all terms \coqdocvariable{x}, $(x * x)\downarrow_{P} = x\downarrow_{P}$.


    To begin, we prove that this holds for monomials;
    $(m \ast m)\downarrow_{P} = m\downarrow_{P}$. This proof uses a combination
    of \coqref{B Unification.poly.Permutation Sorted mono eq}{\coqdoclemma{Permutation\_Sorted\_mono\_eq}} and induction. We then use the standard
    \coqdoclibrary{Permutation} lemmas to move the induction variable \coqdocvariable{a} out to the front,
    and show that \coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} removes one of the two \coqdocvariable{a}s. After that, \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}
    and the induction hypothesis solve the lemma. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make mono self}{make\_mono\_self}{\coqdoclemma{make\_mono\_self}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{m}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation Sorted mono eq}{\coqdoclemma{Permutation\_Sorted\_mono\_eq}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{m}; \coqdoctac{auto}. \coqdoctac{unfold} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation VarSort l}{\coqdoclemma{Permutation\_VarSort\_l}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{assert} (\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvar{a} (\coqdocvar{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{m})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intuition}. \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}; \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{m})).\coqdoceol
\coqdocindent{3.50em}
\coqdoctac{apply} \coqref{B Unification.list util.Permutation nodup}{\coqdoclemma{Permutation\_nodup}}. \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{assert} (\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvar{a} (\coqdocvar{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{m})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} \coqdocvar{H1}. \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro}. \coqdoctac{apply} \coqdocvar{H1}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{H2}; \coqdoctac{intuition}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}; \coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation VarSort l}{\coqdoclemma{Permutation\_VarSort\_l}} \coqdoctac{in} \coqdocvar{IHm}. \coqdoctac{auto}. \coqdoctac{apply} (\coqref{B Unification.poly.mono cons}{\coqdoclemma{mono\_cons}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{VarSort.LocallySorted\_sort}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.Sorted VarSorted}{\coqdoclemma{Sorted\_VarSorted}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The full proof of the self multiplicative identity is much longer, but in a
    way very similar to the proof of commutativity. We begin by doing induction
    and simplifying, which distributes \textit{one} of the induction variables across
    the list on the left side. This leaves us with $a \ast a$ as the leftmost
    term, which is easily replaced with \coqdocvariable{a} with the above lemma and then
    removed from both sides with \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}.


    At this point we are left with a goal of the form
    $(a \ast [a :: p])\downarrow_{P} ++ ([a :: p] \ast p)\downarrow_{P} =
    p\downarrow_{P}$ which is not particularly easy to deal with. However, by
    rewriting with \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}, we can force the second term on the left to
    simplify futher.


    This leaves us with something along the lines of
    $(a \ast [a :: p])\downarrow_{P} ++ (a \ast [a :: p])\downarrow_{P} ++
    (p \ast p)\downarrow_{P} = p\downarrow_{P}$ which is much more workable! We
    know that $(p \ast p)\downarrow_{P} = p\downarrow_{P}$ from the induction
    hypothesis, so this is then removed from both sides and all that is left is
    to prove that the same term added together twice is equal to an empty list.
    This follows from the \coqref{B Unification.list util.nodup cancel self}{\coqdoclemma{nodup\_cancel\_self}} lemma used to prove \coqref{B Unification.poly.addPP p p}{\coqdoclemma{addPP\_p\_p}},
    and finished the proof of this lemma. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP p p}{mulPP\_p\_p}{\coqdoclemma{mulPP\_p\_p}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP'}{\coqdoclemma{mulPP\_mulPP'}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP' mulPP''}{\coqdoclemma{mulPP'\_mulPP'{}'}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation Sorted eq}{\coqdoclemma{Permutation\_Sorted\_eq}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}, \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort l}{\coqdoclemma{Permutation\_MonoSort\_l}}. \coqdoctac{simpl} \coqdocvar{map} \coqdoctac{at} 1.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{H1}. \coqdoctac{rewrite} \coqref{B Unification.poly.make mono self}{\coqdoclemma{make\_mono\_self}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.no make mono}{\coqdoclemma{no\_make\_mono}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{p})) \coqdocvar{p})) \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvar{a}) \coqdocvar{p})))).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{rewrite} \coqexternalref{app comm cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_comm\_cons}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{3.00em}
(\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{p}) (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{p}))))\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{3.00em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvar{a}) \coqdocvar{p}))\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}})). \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation app tail}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_tail}}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.make poly refold}{\coqdoclemma{make\_poly\_refold}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP'' refold}{\coqdoclemma{mulPP'{}'\_refold}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.mulPP' mulPP''}{\coqdoclemma{mulPP'\_mulPP'{}'}}. \coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.mulPP mulPP'}{\coqdoclemma{mulPP\_mulPP'}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{3.00em}
(\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvar{a}) \coqdocvar{p})) \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{p}) (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{p})))\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl} \coqdocvar{map}. \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{unfold} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdoctac{at} 1.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} (\coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvar{\_}));\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{try} \coqdoctac{apply} \coqref{B Unification.poly.mono in map make mono}{\coqdoclemma{mono\_in\_map\_make\_mono}}. \coqdoctac{rewrite} (\coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvar{\_} \coqdocvar{\_})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{3.00em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvar{a}) \coqdocvar{p}) \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvar{a}) \coqdocvar{p})\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{3.00em}
(\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{p}) \coqdocvar{p})))). \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation middle}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_middle}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel self}{\coqdoclemma{nodup\_cancel\_self}}. \coqdoctac{simpl} \coqdocvar{app}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{3.00em}
(\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{p}) \coqdocvar{p})) \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{a}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}})). \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{replace} (\coqdocvar{a}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{p}) \coqdocvar{p}))) \coqdockw{with} (\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{a}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{3.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{p}) \coqdocvar{p}))); \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqdocvar{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{a}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}})). \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation app tail}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_tail}}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}, \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdoctac{in} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort l}{\coqdoclemma{Permutation\_MonoSort\_l}} \coqdoctac{in} \coqdocvar{IHp}. \coqdoctac{apply} \coqdocvar{IHp}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{replace} (\coqdocvar{a}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{p}) \coqdockw{with} (\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{a}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}}\coqdocvar{p}); \coqdoctac{auto}. \coqdoctac{rewrite} \coqref{B Unification.list util.no nodup cancel NoDup}{\coqdoclemma{no\_nodup\_cancel\_NoDup}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}. \coqdoctac{apply} \coqexternalref{Permutation NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_NoDup}} \coqdockw{with} (\coqdocvar{l}:=\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{p}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{replace} (\coqdocvar{a}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{p}) \coqdockw{with} (\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{a}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}}\coqdocvar{p}); \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \coqdoctac{apply} \coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{LocallySorted\_sort}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.Sorted MonoSorted}{\coqdoclemma{Sorted\_MonoSorted}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Axiom 10: Distribution}



 Finally, we are left with the most intimidating of the axioms -
    distribution. This states, as one would expect, that for all terms \coqdocvariable{x}, \coqdocvariable{y},
    and \coqdocvariable{z},
    $(x \ast (y + z))\downarrow_{P} = ((x * y) + (x * z)\downarrow_{P}$.


    In a similar approach to what we have done for some of the other lemmas, we
    begin by proving this on a smaller scale, working with just \coqref{B Unification.poly.mulMP}{\coqdocdefinition{mulMP}} and
    \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}. This lemma is once again solved easily by the \coqref{B Unification.poly.map app make poly}{\coqdoclemma{map\_app\_make\_poly}}
    we proved while working on multiplication associativity, combined with
    \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulMP'' distr addPP}{mulMP'{}'\_distr\_addPP}{\coqdoclemma{mulMP'{}'\_distr\_addPP}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} \coqdocvariable{q}) \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvariable{p} \coqdocvariable{m}) (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvariable{q} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q} \coqdocvar{Hp} \coqdocvar{Hq}. \coqdoctac{unfold} \coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}}, \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}. \coqdoctac{rewrite} \coqref{B Unification.poly.map app make poly}{\coqdoclemma{map\_app\_make\_poly}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{auto}. \coqdoctac{intros} \coqdocvar{a} \coqdocvar{Hin}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{Hin} \coqdockw{as} [].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{Hp}. \coqdoctac{auto}. \coqdoctac{apply} \coqdocvar{Hq}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For the distribution proof itself, we begin by performing induction on \coqdocvariable{r},
    the element outside of the \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} call initially. We begin by simplifying,
    and using the usual combination of \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}} and refolding to
    convert our goal to a form of
    $((p + q) \ast a)\downarrow_{P} ++ ((p + q) \ast r)\downarrow_{P}$.


    We then apply similar tactics on the right side, to convert our goal to a
    form similar to $(p \ast a + q \ast a + p \ast r + q \ast r)\downarrow_{P}$.
    The two terms containing \coqdocvariable{r} are easy to deal with, since we know they are
    equal to the $((p + q) \ast r)\downarrow_{P}$ we have on the left side due
    to the induction hypothesis. Similarly, the first two terms are known to be
    equal to $((p + q) \ast a)\downarrow_{P}$ from the \coqdocvar{mulMP\_distr\_addPP} lemma
    we just proved. This results in us having the same thing on both sides, thus
    solving the final of the ten \coqdocvariable{B}-unification axioms. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP distr addPP}{mulPP\_distr\_addPP}{\coqdoclemma{mulPP\_distr\_addPP}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} \coqdocvariable{q}) \coqdocvariable{r} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqdocvariable{r}) (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{q} \coqdocvariable{r}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{Hp} \coqdocvar{Hq}. \coqdoctac{induction} \coqdocvar{r}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP''}{\coqdoclemma{mulPP\_mulPP'{}'}}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP''}{\coqdoclemma{mulPP\_mulPP'{}'}}, (\coqref{B Unification.poly.mulPP mulPP''}{\coqdoclemma{mulPP\_mulPP'{}'}} \coqdocvar{q}), \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP'' refold}{\coqdoclemma{mulPP'{}'\_refold}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.addPP refold}{\coqdoclemma{addPP\_refold}}. \coqdoctac{repeat} \coqdoctac{unfold} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdoctac{at} 2. \coqdoctac{simpl}. \coqdoctac{unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdoctac{at} 4.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}. \coqdoctac{rewrite} \coqref{B Unification.poly.addPP refold}{\coqdoclemma{addPP\_refold}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.addPP comm}{\coqdoclemma{addPP\_comm}} \coqdocvar{\_} (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvar{\_})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdoctac{at} 4. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP'' refold}{\coqdoclemma{mulPP'{}'\_refold}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}. \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP'' refold}{\coqdoclemma{mulPP'{}'\_refold}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{replace} (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvar{p} \coqdocvar{r} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{q} \coqdocvar{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvar{q} \coqdocvar{r} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{p} \coqdocvar{a}))\coqdoceol
\coqdocindent{2.00em}
\coqdockw{with} (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvar{p} \coqdocvar{r} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvar{q} \coqdocvar{r}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{p} \coqdocvar{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{q} \coqdocvar{a})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}. \coqdoctac{rewrite} (\coqref{B Unification.poly.addPP refold}{\coqdoclemma{addPP\_refold}} (\coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvar{\_} \coqdocvar{\_})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.poly.addPP refold}{\coqdoclemma{addPP\_refold}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP''}{\coqdoclemma{mulPP\_mulPP'{}'}}, (\coqref{B Unification.poly.mulPP mulPP''}{\coqdoclemma{mulPP\_mulPP'{}'}} \coqdocvar{p}), (\coqref{B Unification.poly.mulPP mulPP''}{\coqdoclemma{mulPP\_mulPP'{}'}} \coqdocvar{q}) \coqdoctac{in} \coqdocvar{IHr}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHr}. \coqdoctac{unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdoctac{at} 4.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless}{\coqdoclemma{make\_poly\_pointless}}. \coqdoctac{unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulMP' mulMP''}{\coqdoclemma{mulMP'\_mulMP'{}'}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvar{\_} \coqdocvar{\_}) (\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{\_} \coqdocvar{\_})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulMP' mulMP''}{\coqdoclemma{mulMP'\_mulMP'{}'}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.make poly app comm}{\coqdoclemma{make\_poly\_app\_comm}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvar{\_} \coqdocvar{\_}) (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvar{\_} \coqdocvar{\_})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.addPP refold}{\coqdoclemma{addPP\_refold}}. \coqdoctac{f\_equal}. \coqdoctac{apply} \coqref{B Unification.poly.mulMP'' distr addPP}{\coqdoclemma{mulMP'{}'\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.make poly Permutation}{\coqdoclemma{make\_poly\_Permutation}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation app head}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_head}}. \coqdoctac{rewrite} \coqexternalref{app assoc}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{l'}:=\coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{q} \coqdocvar{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.mulPP''}{\coqdocdefinition{mulPP'{}'}} \coqdocvar{q} \coqdocvar{r} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqref{B Unification.poly.mulMP'}{\coqdocdefinition{mulMP'}} \coqdocvar{p} \coqdocvar{a}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For convenience, we also prove that distribution can be applied from the
    right, which follows from \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}} and the distribution lemma we just
    proved. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP distr addPPr}{mulPP\_distr\_addPPr}{\coqdoclemma{mulPP\_distr\_addPPr}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{r} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{r} \coqdocvariable{p}) (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{r} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{Hp} \coqdocvar{Hq}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}. \coqdoctac{rewrite} (\coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}} \coqdocvar{r} \coqdocvar{p}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}} \coqdocvar{r} \coqdocvar{q}). \coqdoctac{apply} \coqref{B Unification.poly.mulPP distr addPP}{\coqdoclemma{mulPP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Other Facts About Polynomials}



 Now that we have proven the core ten axioms proven, there are a few more
    useful lemmas that we will prove to assist us in future parts of the
    development. 

\subsection{More Arithmetic}



 Occasionally, when dealing with multiplication, we already know that one of
    the variables being multiplied in is less than the rest, meaning it would
    end up at the front of the list after sorting. For convenience and to bypass
    the work of dealing with the calls to \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} and \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}, the below
    lemma allows us to rewrite with this concept. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP mono cons}{mulPP\_mono\_cons}{\coqdoclemma{mulPP\_mono\_cons}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} (\coqdocvariable{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{m}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{m}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{m}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}, \coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}}. \coqdoctac{simpl}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation Sorted eq}{\coqdoclemma{Permutation\_Sorted\_eq}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{l'}:=\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{Permuted\_sort}}. \coqdoctac{rewrite} \coqref{B Unification.list util.no nodup cancel NoDup}{\coqdoclemma{no\_nodup\_cancel\_NoDup}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{assert} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvar{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{m}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.no make mono}{\coqdoclemma{no\_make\_mono}}; \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort mono eq}{\coqdoclemma{Permutation\_sort\_mono\_eq}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.list util.no nodup NoDup}{\coqdoclemma{no\_nodup\_NoDup}}. \coqdoctac{replace} (\coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{m}) \coqdockw{with} (\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{m}); \coqdoctac{auto};\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}}; \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_NoDup}} \coqdockw{with} (\coqdocvar{l}:=\coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{m}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{replace} (\coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{m}) \coqdockw{with} (\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{m}); \coqdoctac{auto}; \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}}; \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{NoDup cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocconstructor{NoDup\_cons}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{LocallySorted\_sort}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{Sorted cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocconstructor{Sorted\_cons}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly, if we already know some monomial is less than the polynomials it
    is being added to, then the monomial will clearly end up at the front of the
    list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.addPP poly cons}{addPP\_poly\_cons}{\coqdoclemma{addPP\_poly\_cons}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqdocvariable{m} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{p}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{m}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{p} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.poly.no make poly}{\coqdoclemma{no\_make\_poly}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
An interesting arithmetic fact is that if we multiply the term
    $((p \ast q) + r)\downarrow_{P}$ by $(1 + q)\downarrow_{P}$, we
    effectively eliminate the $(p \ast q)\downarrow_{P}$ term and are left with
    $((1 + q) \ast r)\downarrow_{P}$. This will come into play later in the
    development, as we look to begin building unifiers. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP addPP 1}{mulPP\_addPP\_1}{\coqdoclemma{mulPP\_addPP\_1}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{r} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqdocvariable{q}) \coqdocvariable{r}) (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvariable{q}) \coqdocvariable{r}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{Hp} \coqdocvar{Hq} \coqdocvar{Hr}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP distr addPP}{\coqdoclemma{mulPP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP distr addPPr}{\coqdoclemma{mulPP\_distr\_addPPr}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP 1r}{\coqdoclemma{mulPP\_1r}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP assoc}{\coqdoclemma{mulPP\_assoc}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP p p}{\coqdoclemma{mulPP\_p\_p}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqref{B Unification.poly.addPP p p}{\coqdoclemma{addPP\_p\_p}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.addPP 0}{\coqdoclemma{addPP\_0}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Reasoning about Variables}



 To more easily deal with the \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} definition, we have defined a few
    definitions about it. First, if some \coqdocvariable{x} is in the variables of
    \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p}, then it must have been in the vars of \coqdocvariable{p} originally. Note
    that this is not true in the other direction, as \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} may remove
    some variables. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.make poly rem vars}{make\_poly\_rem\_vars}{\coqdoclemma{make\_poly\_rem\_vars}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdocvariable{p})) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{x} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}}. \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}}, \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.In concat exists}{\coqdoclemma{In\_concat\_exists}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [\coqdocvar{m} []].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.In sorted}{\coqdoclemma{In\_sorted}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel in}{\coqdoclemma{nodup\_cancel\_in}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [\coqdocvar{n} []]. \coqdoctac{destruct} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{left}. \coqdoctac{apply} \coqref{B Unification.poly.make mono In}{\coqdoclemma{make\_mono\_In}}. \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{right}. \coqdoctac{apply} \coqref{B Unification.list util.In concat exists}{\coqdoclemma{In\_concat\_exists}}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{n}. \coqdoctac{split}; \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.poly.make mono In}{\coqdoclemma{make\_mono\_In}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
An interesting observation about \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} and our \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} function is that
    clearly, the variables of some $(p + q)\downarrow_{P}$ is a subset of the
    variables of \coqdocvariable{p} combined with the variables of \coqdocvariable{q}. The next lemma is a
    more convenient formulation of that fact, using a list of variables \coqdocvariable{xs}
    rather than comparing them directly. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.incl vars addPP}{incl\_vars\_addPP}{\coqdoclemma{incl\_vars\_addPP}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q} \coqdocvar{xs},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}) \coqdocvariable{xs} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{q}) \coqdocvariable{xs} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} \coqdocvariable{q})) \coqdocvariable{xs}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}, \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q} \coqdocvar{xs} [\coqdocvar{HinP} \coqdocvar{HinQ}] \coqdocvar{x} \coqdocvar{HinPQ}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.make poly rem vars}{\coqdoclemma{make\_poly\_rem\_vars}} \coqdoctac{in} \coqdocvar{HinPQ}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdoctac{in} \coqdocvar{HinPQ}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}} \coqdoctac{in} \coqdocvar{HinPQ}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqexternalref{concat app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{concat\_app}} \coqdoctac{in} \coqdocvar{HinPQ}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{in app or}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_or}} \coqdoctac{in} \coqdocvar{HinPQ} \coqdockw{as} [\coqdocvar{Hin} \ensuremath{|} \coqdocvar{Hin}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{HinP}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{HinQ}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We would like to be able to prove a similar fact about \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}, but before
    we can do so, we need to know more about the \coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}} function. This
    lemma states that if some \coqdocvariable{a} is in the variables of \coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}} \coqdocvariable{l} \coqdocvariable{m},
    then it must have been in either \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{l} or \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{m} originally. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.In distribute}{In\_distribute}{\coqdoclemma{In\_distribute}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l} \coqdocvar{m}:\coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) \coqdocvar{a},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} (\coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}} \coqdocvariable{l} \coqdocvariable{m})) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{l}) \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{a} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{m} \coqdocvar{a} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}}, \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.In concat exists}{\coqdoclemma{In\_concat\_exists}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{ll}[]].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.In concat exists}{\coqdoclemma{In\_concat\_exists}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{ll1}[]].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{x}[]]. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{H1} \coqdockw{as} [\coqdocvar{x0}[]]. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H1} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{right}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}}. \coqdoctac{apply} \coqref{B Unification.list util.In concat exists}{\coqdoclemma{In\_concat\_exists}}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{x}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{left}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}}. \coqdoctac{apply} \coqref{B Unification.list util.In concat exists}{\coqdoclemma{In\_concat\_exists}}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{x0}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can then use this fact to prove our desired fact about \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}; the
    variables of $(p \ast q)\downarrow_{P}$ are a subset of the variables of \coqdocvariable{p}
    and the variables of \coqdocvariable{q}. Once again, this is formalized in a way that is
    more convenient in later proofs, with an extra list \coqdocvariable{xs}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.incl vars mulPP}{incl\_vars\_mulPP}{\coqdoclemma{incl\_vars\_mulPP}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q} \coqdocvar{xs},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}) \coqdocvariable{xs} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{q}) \coqdocvariable{xs} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqdocvariable{q})) \coqdocvariable{xs}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}, \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q} \coqdocvar{xs} [\coqdocvar{HinP} \coqdocvar{HinQ}] \coqdocvar{x} \coqdocvar{HinPQ}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.make poly rem vars}{\coqdoclemma{make\_poly\_rem\_vars}} \coqdoctac{in} \coqdocvar{HinPQ}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.In distribute}{\coqdoclemma{In\_distribute}} \coqdoctac{in} \coqdocvar{HinPQ}. \coqdoctac{destruct} \coqdocvar{HinPQ}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{HinP}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{HinQ}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Partition with Polynomials}



 When it comes to actually performing successive variable elimination later
    in the development, the \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} function will play a big role, so we
    have opted to prove a few useful facts about its relation to polynomials
    now.


    First is that if you separate a polynomial with any function \coqdocvariable{f}, you can
    get the original polynomial back by adding together the two lists returned
    by \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}}. This is relatively easy to prove thanks to the lemma
    \coqref{B Unification.list util.partition Permutation}{\coqdoclemma{partition\_Permutation}} we proved during \coqdoclibrary{list\_util}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.part add eq}{part\_add\_eq}{\coqdoclemma{part\_add\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{f} \coqdocvar{p} \coqdocvar{l} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvariable{f} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{l}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{l} \coqdocvariable{r}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{f} \coqdocvar{p} \coqdocvar{l} \coqdocvar{r} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation Sorted eq}{\coqdoclemma{Permutation\_Sorted\_eq}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{l}; \coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{r}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{inversion} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{assert} (\coqdocvar{H1}:=\coqdocvar{H0}); \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.list util.partition Permutation}{\coqdoclemma{partition\_Permutation}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvar{f} \coqdocvar{p}) \coqdockw{as} [\coqdocvar{g} \coqdocvar{d}]. \coqdoctac{unfold} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}, \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort r}{\coqdoclemma{Permutation\_MonoSort\_r}}. \coqdoctac{rewrite} \coqref{B Unification.poly.unsorted poly}{\coqdoclemma{unsorted\_poly}}. \coqdoctac{destruct} (\coqdocvar{f} \coqdocvar{a});\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H3} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H4} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} (\coqexternalref{Permutation NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_NoDup}} \coqdocvar{H1} \coqdocvar{H}).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (\coqexternalref{Permutation in}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_in}} \coqdocvar{\_} \coqdocvar{H1} \coqdocvar{Hin}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.Sorted MonoSorted}{\coqdoclemma{Sorted\_MonoSorted}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.Sorted MonoSorted}{\coqdoclemma{Sorted\_MonoSorted}}. \coqdoctac{apply} \coqref{B Unification.poly.make poly is poly}{\coqdoclemma{make\_poly\_is\_poly}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In addition, if you \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} some polynomial \coqdocvariable{p} with any function \coqdocvariable{f},
    the resulting two lists will both be proper polynomials, since \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}}
    does not affect the order. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.part is poly}{part\_is\_poly}{\coqdoclemma{part\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{f} \coqdocvar{p} \coqdocvar{l} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdocvariable{f} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{l}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{l} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{r}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{f} \coqdocvar{p} \coqdocvar{l} \coqdocvar{r} \coqdocvar{Hpoly} \coqdocvar{Hpart}. \coqdoctac{destruct} \coqdocvar{Hpoly}. \coqdoctac{split}; \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} (\coqref{B Unification.list util.part Sorted}{\coqdoclemma{part\_Sorted}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqref{B Unification.poly.mono lt Transitive}{\coqdoclemma{mono\_lt\_Transitive}} \coqdocvar{H} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{Hpart}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{elements in partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{elements\_in\_partition}} \coqdockw{with} (\coqdocvar{x}:=\coqdocvar{m}) \coqdoctac{in} \coqdocvar{Hpart}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{Hpart}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} (\coqref{B Unification.list util.part Sorted}{\coqdoclemma{part\_Sorted}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqref{B Unification.poly.mono lt Transitive}{\coqdoclemma{mono\_lt\_Transitive}} \coqdocvar{H} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{Hpart}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{elements in partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{elements\_in\_partition}} \coqdockw{with} (\coqdocvar{x}:=\coqdocvar{m}) \coqdoctac{in} \coqdocvar{Hpart}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{Hpart}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Multiplication and Remove}



 Lastly are some rather complex lemmas relating \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} and multiplication.
    Similarly to the \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} lemmas, these will come to play a large roll in
    performing successive variable elimination later in the development.


    First is an interesting fact about removing from monomials. If there are two
    monomials which are equal after removing some \coqdocvariable{x}, and either both contain
    \coqdocvariable{x} or both do not contain \coqdocvariable{x}, then they must have been equal originally.
    This proof begins by performing double induction, and quickly solving the
    first three cases.


    The fourth case is rather long, and begins by comparing if the \coqdocvariable{a} and \coqdocvariable{a0}
    at the head of each list are equal. The case where they are equal is
    relatively straightforward; we must also destruct if \coqdocvariable{x} = \coqdocvariable{a} = \coqdocvariable{a0}, but
    regardless of whether they are equal or not, we can easily prove this with
    the use of the induction hypothesis.


    The case where $a \neq a0$ should be a contradiction, as that element is at
    the head of both lists, and we know the lists are equal after removing \coqdocvariable{x}.
    We begin by destructing whether or not \coqdocvariable{x} is in the two lists. In the case
    where it is not in either, we can quickly solve this, as we know the call to
    remove will do nothing, which immediately gives us the contradiction.


    In the case where \coqdocvariable{x} is in both, we begin by using \coqexternalref{in split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_split}} to rewrite
    both lists to contain \coqdocvariable{x}. We then use the fact that there are no duplicates
    in either list to show that \coqdocvariable{x} is not in \coqdocvariable{l1}, \coqdocvariable{l2}, \coqdocvar{l1'}, or \coqdocvar{l2'}, and
    therefore the calls to remove will do nothing. This leaves us with a
    hypothesis that \coqdocvariable{l1} ++ \coqdocvariable{l2} = \coqdocvar{l1'} ++ \coqdocvar{l2'}. To finish the proof, we destruct
    \coqdocvariable{l1} and \coqdocvar{l1'} to further compare the head of each list.


    In the case where they are both empty, we arrive at a contradiction
    immediately, as this implies the head of both lists is \coqdocvariable{x} and therefore
    contradicts that $a \neq a0$. In the case where they are both lists, doing
    inversion on our remove hypothesis gives us that the head of each list is
    equal again, also contradicting that $a \neq a0$.


    In the other two cases, we rewrite with the \coqexternalref{in split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_split}} hypotheses into the
    \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} hypotheses. In both cases, we result in one statement that \coqdocvariable{a}
    comes before \coqdocvariable{a0} in the monomial, and one statement that \coqdocvariable{a0} comes before
    \coqdocvariable{a} in the monomial. With the help of \coqexternalref{StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdocinductive{StronglySorted}}, we are able to turn
    these into \coqdocvariable{a} < \coqdocvariable{a0} and \coqdocvariable{a0} < \coqdocvariable{a}, which contradict each other to finish the
    proof. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.remove Sorted eq}{remove\_Sorted\_eq}{\coqdoclemma{remove\_Sorted\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} (\coqdocvar{l} \coqdocvar{l'}:\coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{l'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvariable{x} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvariable{x} \coqdocvariable{l'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{l} \coqdocvar{l'} \coqdocvar{Hl} \coqdocvar{Hl'} \coqdocvar{Hx} \coqdocvar{Hrem}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{l'}; \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{induction} \coqdocvar{l'}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{x} \coqdocvar{a}) \coqdocvar{eqn}:\coqdocvar{Heq}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{Hx}. \coqdocvar{exfalso}. \coqdoctac{apply} \coqdocvar{Hx}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hrem}. \coqdoctac{rewrite} \coqdocvar{Heq} \coqdoctac{in} \coqdocvar{Hrem}. \coqdoctac{inversion} \coqdocvar{Hrem}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{x} \coqdocvar{a}) \coqdocvar{eqn}:\coqdocvar{Heq}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{Hx}. \coqdocvar{exfalso}. \coqdoctac{apply} \coqdocvar{Hx}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hrem}. \coqdoctac{rewrite} \coqdocvar{Heq} \coqdoctac{in} \coqdocvar{Hrem}. \coqdoctac{inversion} \coqdocvar{Hrem}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{clear} \coqdocvar{IHl'}. \coqdoctac{destruct} (\coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{a} \coqdocvar{a0}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{f\_equal}. \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{Hrem}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hrem}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.poly.mono cons}{\coqdoclemma{mono\_cons}} \coqdoctac{in} \coqdocvar{Hl} \coqdockw{as} \coqdocvar{Hl1}. \coqdoctac{apply} \coqref{B Unification.poly.mono cons}{\coqdoclemma{mono\_cons}} \coqdoctac{in} \coqdocvar{Hl'} \coqdockw{as} \coqdocvar{Hl'1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{x} \coqdocvar{a0}).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IHl}; \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}} \coqdoctac{in} \coqdocvar{Hl}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{Hl}. \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{Hl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e0} \coqdoctac{in} \coqdocvar{Hl}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{destruct} \coqdocvar{Hl}. \coqdoctac{split}; \coqdoctac{intro}. \coqdocvar{contradiction}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}} \coqdoctac{in} \coqdocvar{Hl'}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{Hl'}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e0} \coqdoctac{in} \coqdocvar{Hl'}. \coqdoctac{destruct} \coqdocvar{Hl'}.\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{Hrem}. \coqdoctac{apply} \coqdocvar{IHl}; \coqdoctac{auto}. \coqdoctac{destruct} \coqdocvar{Hx}. \coqdoctac{split}; \coqdoctac{intro}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{n}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{H1}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqdocvar{H1} \coqdoctac{in} \coqdocvar{n}.\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{contradiction}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} (\coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{x} (\coqdocvar{a}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{l})).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{Hx} \coqdoctac{in} \coqdocvar{i} \coqdockw{as} \coqdocvar{i'}. \coqdoctac{apply} \coqexternalref{in split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_split}} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{apply} \coqexternalref{in split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_split}} \coqdoctac{in} \coqdocvar{i'}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{destruct} \coqdocvar{i} \coqdockw{as} [\coqdocvar{l1}[\coqdocvar{l2} \coqdocvar{i}]]. \coqdoctac{destruct} \coqdocvar{i'} \coqdockw{as} [\coqdocvar{l1'}[\coqdocvar{l2'} \coqdocvar{i'}]].\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{pose} (\coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}} \coqdocvar{\_} \coqdocvar{Hl}). \coqdoctac{pose} (\coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}} \coqdocvar{\_} \coqdocvar{Hl'}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (\coqref{B Unification.list util.NoDup In split}{\coqdoclemma{NoDup\_In\_split}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{i}) \coqdoctac{in} \coqdocvar{n0} \coqdockw{as} [].\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (\coqref{B Unification.list util.NoDup In split}{\coqdoclemma{NoDup\_In\_split}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{i'}) \coqdoctac{in} \coqdocvar{n1} \coqdockw{as} [].\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqdocvar{i} \coqdoctac{in} \coqdocvar{Hrem}. \coqdoctac{rewrite} \coqdocvar{i'} \coqdoctac{in} \coqdocvar{Hrem}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.list util.remove distr app}{\coqdoclemma{remove\_distr\_app}} \coqdoctac{in} \coqdocvar{Hrem}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hrem}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{destruct} (\coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{x} \coqdocvar{x}); \coqdoctac{try} \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{repeat} (\coqdoctac{rewrite} \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}} \coqdoctac{in} \coqdocvar{Hrem}; \coqdoctac{auto}). \coqdoctac{destruct} \coqdocvar{l1}; \coqdoctac{destruct} \coqdocvar{l1'};\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{i}; \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{i'}; \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hrem}; \coqdoctac{inversion} \coqdocvar{i}; \coqdoctac{inversion} \coqdocvar{i'}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{rewrite} \coqdocvar{H4} \coqdoctac{in} \coqdocvar{n}. \coqdoctac{rewrite} \coqdocvar{H6} \coqdoctac{in} \coqdocvar{n}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{rewrite} \coqdocvar{H7} \coqdoctac{in} \coqdocvar{Hl'}. \coqdoctac{rewrite} \coqdocvar{i} \coqdoctac{in} \coqdocvar{Hl}. \coqdoctac{rewrite} \coqdocvar{Hrem} \coqdoctac{in} \coqdocvar{Hl}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{rewrite} \coqdocvar{H6} \coqdoctac{in} \coqdocvar{Hl'}. \coqdoctac{assert} (\coqdocvar{x} \coqexternalref{::nat scope:x '<' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{<}} \coqdocvar{v}). \coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{Hl} \coqdockw{as} [].\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{HdRel inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{HdRel\_inv}} \coqdoctac{in} \coqdocvar{H8}. \coqdoctac{auto}. \coqdoctac{assert} (\coqdocvar{v} \coqexternalref{::nat scope:x '<' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{<}} \coqdocvar{x}).\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{Hl'}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{Hl'} \coqdockw{as} []. \coqdoctac{rewrite} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}} \coqdoctac{in} \coqdocvar{H9}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqdocvar{H9}. \coqdoctac{intuition}. \coqdoctac{apply} \coqref{B Unification.poly.lt Transitive}{\coqdoclemma{lt\_Transitive}}. \coqdoctac{apply} \coqexternalref{Nat.lt asymm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{lt\_asymm}} \coqdoctac{in} \coqdocvar{H8}.\coqdoceol
\coqdocindent{5.50em}
\coqdocvar{contradiction}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{rewrite} \coqdocvar{H7} \coqdoctac{in} \coqdocvar{Hl'}. \coqdoctac{rewrite} \coqdocvar{i} \coqdoctac{in} \coqdocvar{Hl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hrem} \coqdoctac{in} \coqdocvar{Hl'}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{rewrite} \coqdocvar{H6} \coqdoctac{in} \coqdocvar{Hl'}. \coqdoctac{assert} (\coqdocvar{n0} \coqexternalref{::nat scope:x '<' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{<}} \coqdocvar{x}).\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{Sorted StronglySorted}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_StronglySorted}} \coqdoctac{in} \coqdocvar{Hl}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{StronglySorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{StronglySorted\_inv}} \coqdoctac{in} \coqdocvar{Hl} \coqdockw{as} []. \coqdoctac{rewrite} \coqexternalref{Forall forall}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{Forall\_forall}} \coqdoctac{in} \coqdocvar{H8}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqdocvar{H8}. \coqdoctac{intuition}. \coqdoctac{apply} \coqref{B Unification.poly.lt Transitive}{\coqdoclemma{lt\_Transitive}}. \coqdoctac{assert} (\coqdocvar{x} \coqexternalref{::nat scope:x '<' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Peano}{\coqdocnotation{<}} \coqdocvar{n0}).\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{Sorted inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{Sorted\_inv}} \coqdoctac{in} \coqdocvar{Hl'} \coqdockw{as} []. \coqdoctac{apply} \coqexternalref{HdRel inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Sorted}{\coqdoclemma{HdRel\_inv}} \coqdoctac{in} \coqdocvar{H9}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqexternalref{Nat.lt asymm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{lt\_asymm}} \coqdoctac{in} \coqdocvar{H8}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{inversion} \coqdocvar{Hrem}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H4} \coqdoctac{in} \coqdocvar{H8}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H6} \coqdoctac{in} \coqdocvar{H8}.\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{contradiction}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{assert} (\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvar{x} (\coqdocvar{a0}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{l'})). \coqdoctac{intro}. \coqdoctac{apply} \coqdocvar{n0}. \coqdoctac{apply} \coqdocvar{Hx}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{repeat} (\coqdoctac{rewrite} \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}} \coqdoctac{in} \coqdocvar{Hrem}; \coqdoctac{auto}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Next is that if we \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} across a polynomial where every monomial
    contains \coqdocvariable{x}, there will still be no duplicates at the end. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.NoDup map remove}{NoDup\_map\_remove}{\coqdoclemma{NoDup\_map\_remove}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvariable{x}) \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{p} \coqdocvar{Hp} \coqdocvar{Hx}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{simpl}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{NoDup cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocconstructor{NoDup\_cons}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intro}. \coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{y} []]. \coqdoctac{assert} (\coqdocvar{y} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{a}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{destruct} \coqdocvar{Hp}. \coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{H3} \coqdoctac{in} \coqdocvar{H0} \coqdockw{as} \coqdocvar{H4}. \coqdoctac{apply} (\coqref{B Unification.poly.remove Sorted eq}{\coqdoclemma{remove\_Sorted\_eq}} \coqdocvar{x}); \coqdoctac{auto}. \coqdoctac{split}; \coqdoctac{intro}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{Hx}. \coqdoctac{intuition}. \coqdoctac{apply} \coqdocvar{Hx}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{H1} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{destruct} \coqdocvar{Hp}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}} \coqdoctac{in} \coqdocvar{H2} \coqdockw{as} \coqdocvar{H4}. \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{H4} \coqdockw{as} [].\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{contradiction}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{apply} \coqdocvar{Hp}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{intros} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{Hx}. \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Building off that, if every monomial in a list \textit{does not} contain some \coqdocvariable{x},
    then appending \coqdocvariable{x} to every monomial and calling \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} still will not
    create any duplicates. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.NoDup map app}{NoDup\_map\_app}{\coqdoclemma{NoDup\_map\_app}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a} \ensuremath{\Rightarrow} \coqdocvariable{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}) \coqdocvariable{l})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{l} \coqdocvar{Hp} \coqdocvar{Hin}. \coqdoctac{induction} \coqdocvar{l}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{NoDup cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocconstructor{NoDup\_cons}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{rewrite} \coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [\coqdocvar{m} []].\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{assert} (\coqdocvar{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{m}).\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{Hp} \coqdockw{as} []. \coqdoctac{apply} \coqref{B Unification.poly.Permutation Sorted mono eq}{\coqdoclemma{Permutation\_Sorted\_mono\_eq}}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort mono eq}{\coqdoclemma{Permutation\_sort\_mono\_eq}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{B Unification.list util.no nodup NoDup}{\coqdoclemma{no\_nodup\_NoDup}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{rewrite} \coqref{B Unification.list util.no nodup NoDup}{\coqdoclemma{no\_nodup\_NoDup}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{5.50em}
++ \coqdoctac{pose} (\coqexternalref{Permutation cons append}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_append}} \coqdocvar{m} \coqdocvar{x}).\coqdoceol
\coqdocindent{7.00em}
\coqdoctac{pose} (\coqexternalref{Permutation cons append}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_append}} \coqdocvar{a} \coqdocvar{x}).\coqdoceol
\coqdocindent{7.00em}
\coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{p}) \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{p0}.\coqdoceol
\coqdocindent{7.00em}
\coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{H}) \coqdoctac{in} \coqdocvar{p0}.\coqdoceol
\coqdocindent{7.00em}
\coqdoctac{apply} \coqexternalref{Permutation cons inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_inv}} \coqdoctac{in} \coqdocvar{p0}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{5.50em}
++ \coqdoctac{apply} \coqexternalref{Permutation NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_NoDup}} \coqdockw{with} (\coqdocvar{l}:=\coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{a}).\coqdoceol
\coqdocindent{7.00em}
\coqdoctac{apply} \coqexternalref{Permutation cons append}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_append}}.\coqdoceol
\coqdocindent{7.00em}
\coqdoctac{apply} \coqexternalref{NoDup cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocconstructor{NoDup\_cons}}. \coqdoctac{apply} \coqdocvar{Hin}. \coqdoctac{intuition}. \coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdoctac{in} \coqdocvar{H2}.\coqdoceol
\coqdocindent{7.00em}
\coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{5.50em}
++ \coqdoctac{apply} \coqexternalref{Permutation NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_NoDup}} \coqdockw{with} (\coqdocvar{l}:=\coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{m}).\coqdoceol
\coqdocindent{7.00em}
\coqdoctac{apply} \coqexternalref{Permutation cons append}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_append}}. \coqdoctac{apply} \coqexternalref{NoDup cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocconstructor{NoDup\_cons}}. \coqdoctac{apply} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{7.00em}
\coqdoctac{intuition}. \coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{H1}. \coqdoctac{apply} \coqdocvar{H3} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{7.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{apply} \coqref{B Unification.poly.Sorted VarSorted}{\coqdoclemma{Sorted\_VarSorted}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{4.00em}
-- \coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{H1}. \coqdoctac{apply} \coqdocvar{H3} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{6.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Sorted VarSorted}{\coqdoclemma{Sorted\_VarSorted}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H1} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{destruct} \coqdocvar{Hp}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{H2} \coqdockw{as} [].\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{contradiction}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHl}. \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{apply} \coqdocvar{Hp}. \coqdoctac{intros} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This next lemma is relatively straightforward, and really just served to
    remove the calls to \coqref{B Unification.poly.sort}{\coqdocdefinition{sort}} and \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} for convenience when
    simplifying a \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP Permutation}{mulPP\_Permutation}{\coqdoclemma{mulPP\_Permutation}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{a0} \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqdocvariable{a0} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} (\coqdocvariable{a0} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} (\coqdocvariable{a0} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{l}))\coqdoceol
\coqdocindent{7.00em}
(\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{a0} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}})\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} \coqdocvariable{l}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{a0} \coqdocvar{l} \coqdocvar{Hp} \coqdocvar{Hx}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}, \coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}}. \coqdoctac{simpl}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} (\coqref{B Unification.poly.Permuted sort}{\coqdoclemma{MonoSort.Permuted\_sort}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}}\coqdoceol
\coqdocindent{4.00em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{a0} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}) \coqdocvar{l}))))).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{p}. \coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{p}). \coqdoctac{simpl} \coqdocvar{map}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.no nodup cancel NoDup}{\coqdoclemma{no\_nodup\_cancel\_NoDup}}; \coqdoctac{clear} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort r}{\coqdoclemma{Permutation\_MonoSort\_r}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.no nodup cancel NoDup}{\coqdoclemma{no\_nodup\_cancel\_NoDup}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqref{B Unification.list util.concat map}{\coqdoclemma{concat\_map}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.NoDup map app}{\coqdoclemma{NoDup\_map\_app}}. \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{apply} \coqdocvar{Hp}. \coqdoctac{intros} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{Hx}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{map cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_cons}}. \coqdoctac{rewrite} \coqref{B Unification.list util.concat map}{\coqdoclemma{concat\_map}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{map cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_cons}} \coqdockw{with} (\coqdocvar{f}:=\coqdockw{fun} \coqdocvar{a} \ensuremath{\Rightarrow} \coqdocvariable{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.NoDup map app}{\coqdoclemma{NoDup\_map\_app}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Building off of the previous lemma, this one serves to remove the calls to
    \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} entirely, and instead replace \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} with just the \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}}.
    We can do this because we know that \coqdocvariable{x} is not in any of the monomials, so
    \coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} will have no effect as we proved earlier. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.mulPP map app permutation}{mulPP\_map\_app\_permutation}{\coqdoclemma{mulPP\_map\_app\_permutation}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{x}:\coqref{B Unification.poly.var}{\coqdocdefinition{var}}) (\coqdocvar{l} \coqdocvar{l'} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{l} \coqdocvariable{l'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} \coqdocvariable{l}) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a} \ensuremath{\Rightarrow} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}))) \coqdocvariable{l'}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{l} \coqdocvar{l'} \coqdocvar{Hp} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{l'}. \coqdoctac{induction} \coqdocvar{l}; \coqdoctac{induction} \coqdocvar{l'}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}}, \coqref{B Unification.list util.distribute}{\coqdocdefinition{distribute}}, \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}, \coqref{B Unification.poly.sort}{\coqdocdefinition{MonoSort.sort}}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{apply} \coqexternalref{Permutation nil cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_nil\_cons}} \coqdoctac{in} \coqdocvar{H0}. \coqdocvar{contradiction}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{Permutation nil cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_nil\_cons}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{contradiction}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{clear} \coqdocvar{IHl'}. \coqdoctac{destruct} (\coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} \coqdocvar{a} \coqdocvar{a0}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} *. \coqdoctac{pose} (\coqref{B Unification.poly.mulPP Permutation}{\coqdoclemma{mulPP\_Permutation}} \coqdocvar{x} \coqdocvar{a0} \coqdocvar{l} \coqdocvar{Hp} \coqdocvar{H}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{p}). \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}. \coqdoctac{apply} \coqdocvar{IHl}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{clear} \coqdocvar{p}. \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{apply} \coqdocvar{Hp}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Permutation cons inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_inv}} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.list util.Permutation incl}{\coqdoclemma{Permutation\_incl}} \coqdoctac{in} \coqdocvar{H0} \coqdockw{as} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.list util.incl cons inv}{\coqdoclemma{incl\_cons\_inv}} \coqdoctac{in} \coqdocvar{H1} \coqdockw{as} []. \coqdoctac{destruct} \coqdocvar{H1};\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} (\coqdoctac{rewrite} \coqdocvar{H1} \coqdoctac{in} \coqdocvar{n}; \coqdocvar{contradiction}). \coqdoctac{apply} \coqexternalref{in split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_split}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqdocvar{H1} \coqdockw{as} [\coqdocvar{l1} [\coqdocvar{l2}]]. \coqdoctac{rewrite} \coqdocvar{H1} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{pose} (\coqexternalref{Permutation middle}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_middle}} (\coqdocvar{a0}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{l1}) \coqdocvar{l2} \coqdocvar{a}). \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{p}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{p}. \coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{H0}) \coqdoctac{in} \coqdocvar{p}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation cons inv}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_inv}} \coqdoctac{in} \coqdocvar{p}. \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}. \coqdoctac{pose} (\coqexternalref{Permutation middle}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_middle}} ((\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvar{a0} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}) \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a1} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{a1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}})) \coqdocvar{l1})) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a1} \ensuremath{\Rightarrow} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{a1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}})) \coqdocvar{l2})\coqdoceol
\coqdocindent{4.00em}
(\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvar{a}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}))).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{p0}. \coqdoctac{simpl}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvar{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}})\coqdoceol
\coqdocindent{4.00em}
\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvar{a0} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}) \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a1} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}} \ensuremath{\Rightarrow} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{a1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}}\coqdoceol
\coqdocindent{4.00em}
\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}})) \coqdocvar{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a1} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}} \ensuremath{\Rightarrow} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{a1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}})) \coqdocvar{l2}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{clear} \coqdocvar{p0}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqexternalref{map cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_cons}} (\coqdockw{fun} \coqdocvar{a1} \ensuremath{\Rightarrow} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{a1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}})) \coqdocvar{a0} (@\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} (\coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}})\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{l1} \coqdocvar{l2})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{pose} (\coqref{B Unification.poly.mulPP Permutation}{\coqdoclemma{mulPP\_Permutation}} \coqdocvar{x} \coqdocvar{a} \coqdocvar{l} \coqdocvar{Hp} \coqdocvar{H}). \coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{p0}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}. \coqdoctac{apply} \coqdocvar{IHl}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{clear} \coqdocvar{p0}. \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{Hp}. \coqdoctac{apply} \coqdocvar{Hp}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Finally, we combine the lemmas in this section to prove that, if there is
    some polynomial \coqdocvariable{p} that has \coqdocvariable{x} in every monomial, removing and then
    re-appending \coqdocvariable{x} to every monomial results in a list that is a permutation
    of the original polynomial. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly.map app remove Permutation}{map\_app\_remove\_Permutation}{\coqdoclemma{map\_app\_remove\_Permutation}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{p} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a} \ensuremath{\Rightarrow} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}})))\coqdoceol
\coqdocindent{10.50em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvariable{x}) \coqdocvariable{p})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{x} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{rewrite} \coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{assert} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (@\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{x} \coqdocvar{a}) \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{a}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}. \coqdoctac{rewrite} \coqref{B Unification.list util.no nodup NoDup}{\coqdoclemma{no\_nodup\_NoDup}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.Permutation Sorted mono eq}{\coqdoclemma{Permutation\_Sorted\_mono\_eq}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{x} \coqdocvar{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqref{B Unification.poly.Permuted sort}{\coqdoclemma{VarSort.Permuted\_sort}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{pose} (\coqexternalref{in split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_split}} \coqdocvar{x} \coqdocvar{a}). \coqdoctac{destruct} \coqdocvar{e} \coqdockw{as} [\coqdocvar{l1} [\coqdocvar{l2} \coqdocvar{e}]]. \coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqdocvar{e}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
(\coqdocvar{l'}:=\coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{x} (\coqdocvar{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{l2})).\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqexternalref{Permutation cons append}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_append}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{l1}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}}\coqdocvar{l2})). \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.remove distr app}{\coqdoclemma{remove\_distr\_app}}. \coqdoctac{replace} (\coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{l2}) \coqdockw{with} (\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}}\coqdocvar{l2}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.remove distr app}{\coqdoclemma{remove\_distr\_app}}. \coqdoctac{simpl}. \coqdoctac{destruct} (\coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{x} \coqdocvar{x});\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{try} \coqdocvar{contradiction}. \coqdoctac{rewrite} \coqexternalref{app nil l}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_nil\_l}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.list util.not In remove}{\coqdoclemma{not\_In\_remove}};\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{try} \coqdoctac{apply} \coqexternalref{Permutation refl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_refl}}; \coqdoctac{try} (\coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [];\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdoctac{in} \coqdocvar{H1}; \coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}} \coqdoctac{in} \coqdocvar{H1}; \coqdoctac{rewrite} \coqdocvar{e} \coqdoctac{in} \coqdocvar{H1};\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqexternalref{NoDup remove 2}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_remove\_2}} \coqdoctac{in} \coqdocvar{H1}). \coqdoctac{intros} \coqdocvar{x2}. \coqdoctac{apply} \coqdocvar{H1}. \coqdoctac{intuition}. \coqdoctac{intros} \coqdocvar{x1}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqdocvar{H1}. \coqdoctac{intuition}. \coqdoctac{apply} \coqexternalref{Permutation middle}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_middle}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.poly.LocallySorted sort}{\coqdoclemma{VarSort.LocallySorted\_sort}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} []. \coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Sorted VarSorted}{\coqdoclemma{Sorted\_VarSorted}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqexternalref{Permutation NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_NoDup}} \coqdockw{with} (\coqdocvar{l}:=(\coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvar{x} \coqdocvar{a})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation cons append}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_cons\_append}}. \coqdoctac{apply} \coqexternalref{NoDup cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocconstructor{NoDup\_cons}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{remove In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{remove\_In}}. \coqdoctac{apply} \coqref{B Unification.list util.NoDup remove}{\coqdoclemma{NoDup\_remove}}. \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} [].\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{apply} \coqexternalref{perm skip}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocconstructor{perm\_skip}}. \coqdoctac{apply} \coqdocvar{IHp}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqdocvar{H0}. \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\end{coqdoccode}
\coqlibrary{B Unification.poly unif}{Library }{B\_Unification.poly\_unif}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclibrary{List}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Arith}{\coqdoclibrary{Arith}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclibrary{Permutation}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{B Unification.poly}{\coqdoclibrary{poly}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Introduction}



 This section deals with defining substitutions and their properties using
    a polynomial representation. As with the inductive term representation,
    substitutions are just lists of replacements, where variables are swapped
    with polynomials instead of terms. Crucial to the proof of correctness in
    the following chapter, substitution is proven to distribute over polynomial
    addition and multiplication. Definitions are provided for unifier,
    unifiable, and properties relating multiple substitutions such as more
    general and composition. 

\section{Substitution Definitions}



 A \textit{substitution} is defined as a list of replacements. A \textit{replacement} is
    just a tuple of a variable and a polynomial. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly unif.repl}{repl}{\coqdocdefinition{repl}} := \coqexternalref{prod}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{prod}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}} \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly unif.subst}{subst}{\coqdocdefinition{subst}} := \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly unif.repl}{\coqdocdefinition{repl}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Since the \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} data type doesn't enforce the properties of actual
    polynomials, the \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} predicate is used to check if a term is in
    polynomial form. Likewise, the \coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} predicate below verifies that
    every term in the range of the substitution is a polynomial. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly unif.is poly subst}{is\_poly\_subst}{\coqdocdefinition{is\_poly\_subst}} (\coqdocvar{s} : \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{p}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The next three functions implement how substitutions are applied to terms.
    At the top level, \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} applies a substitution to a polynomial by calling
    \coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} on each monomial. From there, \coqref{B Unification.poly unif.substV}{\coqdocdefinition{substV}} is called on each variable.
    Because variables and monomials are converted to polynomials, the process
    isn't simplying mapping application across the lists. \coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} and \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}
    must multiply and add each polynomial together respectively. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.poly unif.substV}{substV}{\coqdocdefinition{substV}} (\coqdocvar{s} : \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}}) (\coqdocvar{x} : \coqref{B Unification.poly.var}{\coqdocdefinition{var}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{s} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}\coqdoceol
  \ensuremath{|} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{y}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{p}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{s'} \ensuremath{\Rightarrow} \coqdockw{if} (\coqdocvariable{x} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{=?}} \coqdocvar{y}) \coqdockw{then} \coqdocvar{p} \coqdockw{else} (\coqref{B Unification.poly unif.substV}{\coqdocdefinition{substV}} \coqdocvar{s'} \coqdocvariable{x})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.poly unif.substM}{substM}{\coqdocdefinition{substM}} (\coqdocvar{s} : \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}}) (\coqdocvar{m} : \coqref{B Unification.poly.mono}{\coqdocdefinition{mono}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{m} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqdoceol
  \ensuremath{|} \coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{m} \ensuremath{\Rightarrow} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} (\coqref{B Unification.poly unif.substV}{\coqdocdefinition{substV}} \coqdocvariable{s} \coqdocvar{x}) (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} \coqdocvariable{m})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly unif.substP}{substP}{\coqdocdefinition{substP}} (\coqdocvar{s} : \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}}) (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s}) \coqdocvariable{p})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Useful in later proofs is the ability to rewrite the unfolded definition of
    \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} as just the function call. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substP refold}{substP\_refold}{\coqdoclemma{substP\_refold}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s}) \coqdocvariable{p})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The following lemmas state that substitution applications always produce
    polynomials. This fact is necessary for proving distribution and other
    properties of substitutions. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substV is poly}{substV\_is\_poly}{\coqdoclemma{substV\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqref{B Unification.poly unif.substV}{\coqdocdefinition{substV}} \coqdocvariable{s} \coqdocvariable{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{s} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{s}; \coqdoctac{simpl}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{a} \coqdocvar{eqn}:\coqdocvar{Ha}. \coqdoctac{destruct} (\coqdocvar{x} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{=?}} \coqdocvar{v}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} (\coqdocvar{H} \coqdocvar{v}). \coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{IHs}. \coqdoctac{intros} \coqdocvar{x0} \coqdocvar{p0} \coqdocvar{H0}. \coqdoctac{apply} (\coqdocvar{H} \coqdocvar{x0}). \coqdoctac{intuition}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substM is poly}{substM\_is\_poly}{\coqdoclemma{substM\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{s} \coqdocvar{m}. \coqdoctac{unfold} \coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}}; \coqdoctac{destruct} \coqdocvar{m}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substP is poly}{substP\_is\_poly}{\coqdoclemma{substP\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{substP\_is\_poly} \coqdocvar{substM\_is\_poly}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The lemma below states that a substitution applied to a variable in
    polynomial form is equivalent to the substitution applied to just the
    variable. This fact only holds when the substitution's range consists of
    polynomials. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.subst var eq}{subst\_var\_eq}{\coqdoclemma{subst\_var\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly unif.substV}{\coqdocdefinition{substV}} \coqdocvariable{s} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{B Unification.poly unif.substV is poly}{\coqdoclemma{substV\_is\_poly}} \coqdocvar{x} \coqdocvar{s}) \coqdoctac{in} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqexternalref{app nil r}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_nil\_r}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP 1r}{\coqdoclemma{mulPP\_1r}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqref{B Unification.poly.no make poly}{\coqdoclemma{no\_make\_poly}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The next two lemmas deal with simplifying substitutions where the first
    replacement tuple is useless for the given term. This is the case when the
    variable being replaced is not present in the term. It allows the
    replacement to be dropped from the substitution without changing the result.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substM cons}{substM\_cons}{\coqdoclemma{substM\_cons}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{s}, \coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} (\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{p}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{s}) \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{m}; \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} (\coqdocvar{a} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{=?}} \coqdocvar{x}) \coqdocvar{eqn}:\coqdocvar{H0}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{apply} \coqexternalref{beq nat eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocdefinition{beq\_nat\_eq}} \coqdoctac{in} \coqdocvar{H0}. \coqdocvar{exfalso}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{left}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{IHm}. \coqdoctac{intro}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{right}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substP cons}{substP\_cons}{\coqdoclemma{substP\_cons}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{q} \coqdocvar{s}, \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} (\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{q}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{s}) \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}. \coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}} \coqdocvar{\_} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} \coqdocvar{\_})). \coqdoctac{f\_equal}. \coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly unif.substM cons}{\coqdoclemma{substM\_cons}}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{left}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{IHp}. \coqdoctac{intros}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{right}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Substitutions applied to constants have no effect. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substP 1}{substP\_1}{\coqdoclemma{substP\_1}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substP 0}{substP\_0}{\coqdoclemma{substP\_0}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The identity substitution--the empty list--has no effect when applied to a
    term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.empty substM}{empty\_substM}{\coqdoclemma{empty\_substM}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{m}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{m}; \coqdoctac{auto}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.mono cons}{\coqdoclemma{mono\_cons}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{IHm}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.mulPP mono cons}{\coqdoclemma{mulPP\_mono\_cons}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.empty substP}{empty\_substP}{\coqdoclemma{empty\_substP}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}. \coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{H} \coqdockw{as} \coqdocvar{H0}. \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}}. \coqdoctac{rewrite} \coqref{B Unification.poly unif.substP refold}{\coqdoclemma{substP\_refold}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{IHp}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqref{B Unification.poly unif.empty substM}{\coqdoclemma{empty\_substM}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.addPP poly cons}{\coqdoclemma{addPP\_poly\_cons}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Distribution Over Arithmetic Operators}



 Below is the statement and proof that substitution distributes over
    polynomial addition. Given a substitution \coqdocvariable{s} and two terms in polynomial
    form \coqdocvariable{p} and \coqdocvariable{q}, it is shown that
    $s(p + q)\downarrow_{P} = (s(p) + s(q))\downarrow_{P}$. The proof relies
    heavily on facts about permutations proven in the \coqdoclibrary{list\_util} library. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substP distr addPP}{substP\_distr\_addPP}{\coqdoclemma{substP\_distr\_addPP}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqdocvariable{p} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqdocvariable{p}) (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q} \coqdocvar{s} \coqdocvar{Hp} \coqdocvar{Hq}. \coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}, \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s})\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvar{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{q})))))))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.Permutation concat}{\coqdoclemma{Permutation\_concat}}. \coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort l}{\coqdoclemma{Permutation\_MonoSort\_l}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}\coqdoceol
\coqdocindent{2.00em}
\coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}}\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) (\coqdocvar{p})))) \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}}\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{q})))\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}})))). \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}. \coqdoctac{apply} \coqexternalref{Permutation app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app}}; \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}};\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort l}{\coqdoclemma{Permutation\_MonoSort\_l}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}} (\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{\_} \coqdocvar{\_}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdocvar{\_} \coqdocvar{\_}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}}\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{q}))) \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{p}))))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{concat app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{concat\_app}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{rewrite} (\coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}} (\coqdocvar{p}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}}\coqdocvar{q})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) (\coqdocvar{p} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{q})))))). \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}. \coqdoctac{apply} \coqref{B Unification.list util.Permutation concat}{\coqdoclemma{Permutation\_concat}}. \coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation app comm}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{concat map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{List.concat\_map}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}}. \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel concat map}{\coqdoclemma{nodup\_cancel\_concat\_map}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x}. \coqdoctac{rewrite} \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}};\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} (\coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}} \coqdocvar{s} \coqdocvar{x}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{Hin} \coqdockw{as} []; \coqdoctac{destruct} \coqdocvar{Hp}; \coqdoctac{destruct} \coqdocvar{Hq}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqexternalref{in app iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_app\_iff}} \coqdoctac{in} \coqdocvar{Hin} \coqdockw{as} []; \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel in}{\coqdoclemma{nodup\_cancel\_in}} \coqdoctac{in} \coqdocvar{H};\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.mono in map make mono}{\coqdoclemma{mono\_in\_map\_make\_mono}} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The next six lemmas deal with proving that substitution distributes over
    polynomial multiplication. Given a substitution \coqdocvariable{s} and two terms in
    polynomial form \coqdocvariable{p} and \coqdocvariable{q}, it is shown that
    $s(p \ast q)\downarrow_{P} = (s(p) \ast s(q))\downarrow_{P}$. The proof
    turns out to be much more difficult than the one for addition because the
    underlying arithmetic operation is more complex. 

 If two monomials are permutations (obviously not in monomial form), then
    applying any substitution to either will produce the same result. A weaker
    form that follows from this is that the results are permutations as well. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substM Permutation eq}{substM\_Permutation\_eq}{\coqdoclemma{substM\_Permutation\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{m} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{m} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{s} \coqdocvar{m} \coqdocvar{n} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{H}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHPermutation}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP assoc}{\coqdoclemma{mulPP\_assoc}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s} \coqdocvar{l})). \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{IHPermutation1}. \coqdoctac{rewrite} \coqdocvar{IHPermutation2}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substM Permutation}{substM\_Permutation}{\coqdoclemma{substM\_Permutation}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{m} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{m} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} \coqdocvariable{m}) (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} \coqdocvariable{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{s} \coqdocvar{m} \coqdocvar{n} \coqdocvar{H}. \coqdoctac{rewrite} (\coqref{B Unification.poly unif.substM Permutation eq}{\coqdoclemma{substM\_Permutation\_eq}} \coqdocvar{s} \coqdocvar{m} \coqdocvar{n}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Adding duplicate variables to a monomial doesn't change the result of
    applying a substitution. This is only true if the substitution's range
    only has polynomials. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substM nodup pointless}{substM\_nodup\_pointless}{\coqdoclemma{substM\_nodup\_pointless}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} (\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvariable{m}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{s} \coqdocvar{m} \coqdocvar{Hps}. \coqdoctac{induction} \coqdocvar{m}; \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{destruct} \coqexternalref{in dec}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_dec}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{in split}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_split}} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{destruct} \coqdocvar{i} \coqdockw{as} [\coqdocvar{l1} [\coqdocvar{l2} \coqdocvar{H}]].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvar{m} (\coqdocvar{a} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{l1} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{l2})). \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqexternalref{Permutation middle}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_middle}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly unif.substM Permutation eq}{\coqdoclemma{substM\_Permutation\_eq}} \coqdockw{with} (\coqdocvar{s}:=\coqdocvar{s}) \coqdoctac{in} \coqdocvar{H0}. \coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}} \coqdocvar{\_} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{\_} \coqdocvar{\_})). \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP assoc}{\coqdoclemma{mulPP\_assoc}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP p p}{\coqdoclemma{mulPP\_p\_p}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}. \coqdoctac{rewrite} \coqdocvar{IHm}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{simpl}. \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.poly unif.substV is poly}{\coqdoclemma{substV\_is\_poly}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHm}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The idea behind the following two lemmas is that substitutions
    distribute over multiplication of a monomial and polynomial. The specifics
    of both are convoluted, yet easier to prove than distribution over two
    polynomials. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substM distr mulMP}{substM\_distr\_mulMP}{\coqdoclemma{substM\_distr\_mulMP}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is mono}{\coqdocdefinition{is\_mono}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{3.00em}
(\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvariable{n}))))))\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}}\coqdoceol
\coqdocindent{3.00em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} \coqdocvariable{m}))) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} \coqdocvariable{n})))))).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{n} \coqdocvar{s} \coqdocvar{Hps} \coqdocvar{H}. \coqdoctac{rewrite} (\coqref{B Unification.poly.no make mono}{\coqdoclemma{no\_make\_mono}} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvar{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{n}))); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} (\coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s} \coqdocvar{\_})); \coqdoctac{auto}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s} (\coqexternalref{nodup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{nodup}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}}\coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{n}))))). \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{apply} \coqref{B Unification.poly unif.substM Permutation}{\coqdoclemma{substM\_Permutation}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation VarSort l}{\coqdoclemma{Permutation\_VarSort\_l}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{pose} (\coqref{B Unification.poly.mulPP 1r}{\coqdoclemma{mulPP\_1r}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s} \coqdocvar{n})). \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}} \coqdoctac{in} \coqdocvar{e}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{pose} (\coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}} \coqdocvar{s} \coqdocvar{n}). \coqdoctac{apply} \coqdocvar{e} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP'''}{\coqdoclemma{mulPP\_mulPP'{}'{}'}} \coqdoctac{in} \coqdocvar{i}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.mulPP'''}{\coqdocdefinition{mulPP'{}'{}'}} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.no make poly}{\coqdoclemma{no\_make\_poly}} \coqdoctac{in} \coqdocvar{i}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}} \coqdoctac{in} \coqdocvar{i}. \coqdoctac{rewrite} \coqdocvar{i}. \coqdoctac{rewrite} \coqref{B Unification.list util.no nodup NoDup}{\coqdoclemma{no\_nodup\_NoDup}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}}. \coqdoctac{auto}. \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} (\coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}} \coqdocvar{s} \coqdocvar{n});\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup VarSorted}{\coqdoclemma{NoDup\_VarSorted}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdocvar{substM} \coqdoctac{at} 2. \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly refold}{\coqdoclemma{make\_poly\_refold}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP''' refold}{\coqdoclemma{mulPP'{}'{}'\_refold}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.mulPP mulPP'''}{\coqdoclemma{mulPP\_mulPP'{}'{}'}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP assoc}{\coqdoclemma{mulPP\_assoc}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP'''}{\coqdoclemma{mulPP\_mulPP'{}'{}'}}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substM nodup pointless}{\coqdoclemma{substM\_nodup\_pointless}}; \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP'''}{\coqdoclemma{mulPP\_mulPP'{}'{}'}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.mulPP'''}{\coqdocdefinition{mulPP'{}'{}'}} \coqdoctac{at} 1. \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}} \coqdoctac{in} \coqdocvar{IHm}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make poly refold}{\coqdoclemma{make\_poly\_refold}} \coqdoctac{in} \coqdocvar{IHm}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP''' refold}{\coqdoclemma{mulPP'{}'{}'\_refold}} \coqdoctac{in} \coqdocvar{IHm}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.no nodup cancel NoDup}{\coqdoclemma{no\_nodup\_cancel\_NoDup}} \coqdoctac{in} \coqdocvar{IHm}. \coqdoctac{rewrite} \coqref{B Unification.poly.no sort MonoSorted}{\coqdoclemma{no\_sort\_MonoSorted}} \coqdoctac{in} \coqdocvar{IHm}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly unif.substM nodup pointless}{\coqdoclemma{substM\_nodup\_pointless}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqdocvar{IHm}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}\coqdoceol
\coqdocindent{3.00em}
\coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} (\coqref{B Unification.poly unif.substV}{\coqdocdefinition{substV}} \coqdocvar{s} \coqdocvar{a}))\coqdoceol
\coqdocindent{3.00em}
(\coqref{B Unification.poly.mulPP'''}{\coqdocdefinition{mulPP'{}'{}'}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s} \coqdocvar{m}) (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s} \coqdocvar{n})))))))).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort l}{\coqdoclemma{Permutation\_MonoSort\_l}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.list util.no nodup cancel NoDup}{\coqdoclemma{no\_nodup\_cancel\_NoDup}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.NoDup nodup cancel}{\coqdoclemma{NoDup\_nodup\_cancel}}. \coqdoctac{apply} \coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{m0} \coqdocvar{Hin}. \coqdoctac{apply} (\coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}} \coqdocvar{s} \coqdocvar{n}). \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{m0} \coqdocvar{Hin}. \coqdoctac{apply} (\coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}} \coqdocvar{s} \coqdocvar{m}). \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{m0} \coqdocvar{Hin}. \coqdoctac{apply} (\coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}} \coqdocvar{s} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvar{m} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqdocvar{n}))). \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.map substM distr map mulMP}{map\_substM\_distr\_map\_mulMP}{\coqdoclemma{map\_substM\_distr\_map\_mulMP}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{p} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s}) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{3.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvariable{p} \coqdocvariable{m}))))))\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{3.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s}) \coqdocvariable{p})))) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvariable{s} \coqdocvariable{m})))))).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{p} \coqdocvar{s} \coqdocvar{Hps} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdoctac{at} 1. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{2.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvar{m}) \coqdocvar{p}))))))))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}, \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}, \coqref{B Unification.list util.Permutation concat}{\coqdoclemma{Permutation\_concat}},\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}, \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort l}{\coqdoclemma{Permutation\_MonoSort\_l}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{app}} \coqdocvar{m})\coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{p}))))))))). \coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{concat map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{List.concat\_map}}. \coqdoctac{rewrite} \coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}}. \coqdoctac{rewrite} (\coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}} \coqdocvar{\_} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} (\coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}). \coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel concat map}{\coqdoclemma{nodup\_cancel\_concat\_map}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{x}. \coqdoctac{rewrite} \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} (\coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}} \coqdocvar{s} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvar{x})). \coqdoctac{intros} \coqdocvar{m0} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{pose} (\coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}} \coqdocvar{s} (\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} \coqdocvar{x})). \coqdoctac{apply} \coqdocvar{i}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p}; \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s} \coqdocvar{m})); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqdoceol
\coqdocindent{3.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{3.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s} \coqdocvar{m}))) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s} \coqdocvar{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{3.00em}
(\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{p})))))))). \coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{repeat} (\coqdoctac{rewrite}\coqdoceol
\coqdocindent{3.00em}
\coqref{B Unification.poly.make poly refold}{\coqdoclemma{make\_poly\_refold}}, \coqref{B Unification.poly.mulPP''' refold}{\coqdoclemma{mulPP'{}'{}'\_refold}}, \ensuremath{\leftarrow} \coqref{B Unification.poly.mulPP mulPP'''}{\coqdoclemma{mulPP\_mulPP'{}'{}'}}). \coqdoctac{apply} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{rewrite} \coqexternalref{concat app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{concat\_app}}, \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel app Permutation}{\coqdoclemma{nodup\_cancel\_app\_Permutation}}. \coqdoctac{apply} \coqref{B Unification.poly unif.substM distr mulMP}{\coqdoclemma{substM\_distr\_mulMP}}; \coqdoctac{auto}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intuition}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=\coqdoceol
\coqdocindent{3.00em}
(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{3.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{p})))) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s} \coqdocvar{m}))))))).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{repeat} (\coqdoctac{rewrite} \coqref{B Unification.poly.make poly refold}{\coqdoclemma{make\_poly\_refold}}, \coqdoceol
\coqdocindent{3.00em}
\coqref{B Unification.poly.mulPP''' refold}{\coqdoclemma{mulPP'{}'{}'\_refold}}, \ensuremath{\leftarrow} \coqref{B Unification.poly.mulPP mulPP'''}{\coqdoclemma{mulPP\_mulPP'{}'{}'}}). \coqdoctac{apply} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqdocvar{IHp}. \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is the formulation of substitution distributing over polynomial
    multiplication. Similar to the proof for addition, it is very dense and
    makes common use of permutation facts. Where it differs from that proof is
    that it relies on the commutativity of multiplication. The proof of
    distribution over addition didn't need any properties of addition. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.substP distr mulPP}{substP\_distr\_mulPP}{\coqdoclemma{substP\_distr\_mulPP}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{q} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqdocvariable{p} \coqdocvariable{q}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqdocvariable{p}) (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqdocvariable{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q} \coqdocvar{s} \coqdocvar{Hps} \coqdocvar{H}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP'''}{\coqdoclemma{mulPP\_mulPP'{}'{}'}}. \coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}, \coqref{B Unification.poly.mulPP'''}{\coqdocdefinition{mulPP'{}'{}'}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}\coqdoceol
\coqdocindent{2.00em}
\coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}}\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvar{p}) \coqdocvar{q}))))))))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.Permutation concat}{\coqdoclemma{Permutation\_concat}}. \coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort l}{\coqdoclemma{Permutation\_MonoSort\_l}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}}\coqdoceol
\coqdocindent{2.00em}
\coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{p})))) (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{q}))))))))). \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}. \coqdoctac{apply} \coqref{B Unification.list util.Permutation concat}{\coqdoclemma{Permutation\_concat}}. \coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort l}{\coqdoclemma{Permutation\_MonoSort\_l}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} (\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{p})))) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{2.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}(\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{q})))))))). \coqdoctac{repeat} \coqdoctac{rewrite} (\coqexternalref{concat map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{List.concat\_map}}\coqdoceol
\coqdocindent{2.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvar{\_}) \coqdocvar{\_})). \coqdoctac{repeat} \coqdoctac{rewrite} (\coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}} \coqdocvar{\_} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel concat map}{\coqdoclemma{nodup\_cancel\_concat\_map}}. \coqdoctac{intros} \coqdocvar{x}. \coqdoctac{rewrite} \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}}. \coqdoctac{apply} \coqref{B Unification.poly.make poly is poly}{\coqdoclemma{make\_poly\_is\_poly}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqref{B Unification.poly.mono in make poly}{\coqdoclemma{mono\_in\_make\_poly}} \coqdoctac{in} \coqdocvar{Hin}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly refold}{\coqdoclemma{make\_poly\_refold}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP''' refold}{\coqdoclemma{mulPP'{}'{}'\_refold}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.mulPP mulPP'''}{\coqdoclemma{mulPP\_mulPP'{}'{}'}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP'''}{\coqdoclemma{mulPP\_mulPP'{}'{}'}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqdoceol
\coqdocindent{2.00em}
\coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{q})))) (\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdoceol
\coqdocindent{2.00em}
(\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{p}))))))))). \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}. \coqdoctac{apply} \coqref{B Unification.list util.Permutation concat}{\coqdoclemma{Permutation\_concat}}. \coqdoctac{apply} \coqexternalref{Permutation map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_map}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort l}{\coqdoclemma{Permutation\_MonoSort\_l}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{q})))) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}}\coqdoceol
\coqdocindent{2.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) \coqdocvar{p})))))))). \coqdoctac{repeat} \coqdoctac{rewrite} (\coqexternalref{concat map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{List.concat\_map}}\coqdoceol
\coqdocindent{2.00em}
\coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvar{\_}) \coqdocvar{\_})). \coqdoctac{repeat} \coqdoctac{rewrite} (\coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}} \coqdocvar{\_} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel concat map}{\coqdoclemma{nodup\_cancel\_concat\_map}}. \coqdoctac{intros} \coqdocvar{x}. \coqdoctac{rewrite} \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}}. \coqdoctac{apply} \coqref{B Unification.poly.make poly is poly}{\coqdoclemma{make\_poly\_is\_poly}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{apply} \coqref{B Unification.poly.mono in make poly}{\coqdoclemma{mono\_in\_make\_poly}} \coqdoctac{in} \coqdocvar{Hin}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{rewrite} \coqref{B Unification.poly.make poly refold}{\coqdoclemma{make\_poly\_refold}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP''' refold}{\coqdoclemma{mulPP'{}'{}'\_refold}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.mulPP mulPP'''}{\coqdoclemma{mulPP\_mulPP'{}'{}'}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}. \coqdoctac{rewrite} \coqref{B Unification.poly.mulPP mulPP'''}{\coqdoclemma{mulPP\_mulPP'{}'{}'}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Permutation sort eq}{\coqdoclemma{Permutation\_sort\_eq}}. \coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdockw{with} (\coqdocvar{l'}:=(\coqref{B Unification.list util.nodup cancel}{\coqdocdefinition{nodup\_cancel}} \coqref{B Unification.poly.mono eq dec}{\coqdocdefinition{mono\_eq\_dec}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}}\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly unif.substM}{\coqdocdefinition{substM}} \coqdocvar{s}) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{concat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{concat}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqref{B Unification.poly.mulMP''}{\coqdocdefinition{mulMP'{}'}} \coqdocvar{p}) \coqdocvar{q})))))))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} (\coqexternalref{concat map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{List.concat\_map}} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvar{\_} \coqdocvar{\_})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}}. \coqdoctac{rewrite} \coqref{B Unification.list util.nodup cancel concat map}{\coqdoclemma{nodup\_cancel\_concat\_map}}. \coqdoctac{auto}. \coqdoctac{intros} \coqdocvar{x}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.no map make mono}{\coqdoclemma{no\_map\_make\_mono}}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup MonoSorted}{\coqdoclemma{NoDup\_MonoSorted}}; \coqdoctac{apply} \coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}; \coqdoctac{apply} (\coqref{B Unification.poly unif.substM is poly}{\coqdoclemma{substM\_is\_poly}} \coqdocvar{s} \coqdocvar{x}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{q}; \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{concat app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{concat\_app}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \coqexternalref{map app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_app}}. \coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.list util.nodup cancel pointless}{\coqdoclemma{nodup\_cancel\_pointless}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvar{\_} \coqdocvar{\_})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.list util.nodup cancel pointless r}{\coqdoclemma{nodup\_cancel\_pointless\_r}} \coqdocvar{\_} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqdocvar{\_} \coqdocvar{\_})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel Permutation}{\coqdoclemma{nodup\_cancel\_Permutation}}. \coqdoctac{apply} \coqexternalref{Permutation app}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_app}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly unif.map substM distr map mulMP}{\coqdoclemma{map\_substM\_distr\_map\_mulMP}}; \coqdoctac{auto}. \coqdoctac{apply} \coqdocvar{IHq}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Unifiable Definitions}



 The following six definitions are all predicate functions that verify some
    property about substitutions or polynomials. 

 A \textit{unifier} for a given polynomial \coqdocvariable{p} is a substitution \coqdocvariable{s} such that
    $s(p)\downarrow_{P} = 0$. This definition also includes that the range of
    the substitution only contain terms in polynomial form. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly unif.unifier}{unifier}{\coqdocdefinition{unifier}} (\coqdocvar{s} : \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}}) (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{s} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A polynomial \coqdocvariable{p} is \textit{unifiable} if there exists a unifier for \coqdocvariable{p}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly unif.unifiable}{unifiable}{\coqdocdefinition{unifiable}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{s} \coqdocvariable{p}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A substitution \coqdocvariable{u} is a \textit{composition} of two substitutions \coqdocvariable{s} and \textit{t} if
    $u(x)\downarrow_{P} = t(s(x))\downarrow_{P}$ for every variable \coqdocvariable{x}. The
    lemma \coqref{B Unification.poly unif.subst comp eq poly}{\coqdoclemma{subst\_comp\_eq\_poly}} below extends this definition from variables to
    polynomials. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly unif.subst comp eq}{subst\_comp\_eq}{\coqdocdefinition{subst\_comp\_eq}} (\coqdocvar{s} \coqdocvar{t} \coqdocvar{u} : \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{t} (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{u} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A substitution \coqdocvariable{s} is \textit{more general} than a substitution \textit{t} if there exists
    a third substitution \coqdocvariable{u} such that \textit{t} is a composition of \coqdocvariable{u} and \coqdocvariable{s}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly unif.more general}{more\_general}{\coqdocdefinition{more\_general}} (\coqdocvar{s} \coqdocvar{t} : \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{u}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.poly unif.subst comp eq}{\coqdocdefinition{subst\_comp\_eq}} \coqdocvariable{s} \coqdocvariable{u} \coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Given a polynomial \coqdocvariable{p}, a substitution \coqdocvariable{s} is the \textit{most general unifier} of
    \coqdocvariable{p} if \coqdocvariable{s} is more general than every unifier of \coqdocvariable{p}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly unif.mgu}{mgu}{\coqdocdefinition{mgu}} (\coqdocvar{s} : \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}}) (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{s} \coqdocvariable{p} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{t},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.more general}{\coqdocdefinition{more\_general}} \coqdocvariable{s} \coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Given a polynomial \coqdocvariable{p}, a substitution \coqdocvariable{s} is a \textit{reproductive unifier} of
    \coqdocvariable{p} if \textit{t} is a composition of itself and \coqdocvariable{s} for every unifier \textit{t} of \coqdocvariable{p}.
    This property is similar but stronger than most general because the
    substitution that composes with \coqdocvariable{s} is restricted to \textit{t}, whereas in most
    general it can be any substitution. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.poly unif.reprod unif}{reprod\_unif}{\coqdocdefinition{reprod\_unif}} (\coqdocvar{s} : \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}}) (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{s} \coqdocvariable{p} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{t},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.subst comp eq}{\coqdocdefinition{subst\_comp\_eq}} \coqdocvariable{s} \coqdocvariable{t} \coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Because the notion of most general is weaker than reproductive, it can be
    proven to logically follow as shown below. Any unifier that is reproductive
    is also most general. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.reprod is mgu}{reprod\_is\_mgu}{\coqdoclemma{reprod\_is\_mgu}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.reprod unif}{\coqdocdefinition{reprod\_unif}} \coqdocvariable{s} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.mgu}{\coqdocdefinition{mgu}} \coqdocvariable{s} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly unif.mgu}{\coqdocdefinition{mgu}}, \coqref{B Unification.poly unif.reprod unif}{\coqdocdefinition{reprod\_unif}}, \coqref{B Unification.poly unif.more general}{\coqdocdefinition{more\_general}}, \coqref{B Unification.poly unif.subst comp eq}{\coqdocdefinition{subst\_comp\_eq}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{s} [].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{\ensuremath{\exists}} \coqdocvar{t}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H0}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
As stated earlier, substitution composition can be extended to polynomials.
    This comes from the implicit fact that if two substitutions agree on all
    variables then they agree on all terms. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.subst comp eq poly}{subst\_comp\_eq\_poly}{\coqdoclemma{subst\_comp\_eq\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{t} \coqdocvar{u},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{t} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{u} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{t} (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{u} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{t} (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqdocvariable{p}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{u} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{p}; \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdoctac{at} 2. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}}. \coqdoctac{rewrite} \coqref{B Unification.poly.addPP refold}{\coqdoclemma{addPP\_refold}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP distr addPP}{\coqdoclemma{substP\_distr\_addPP}}; \coqdoctac{auto}. \coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdoctac{at} 3. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.make poly pointless r}{\coqdoclemma{make\_poly\_pointless\_r}}. \coqdoctac{rewrite} \coqref{B Unification.poly.addPP refold}{\coqdoclemma{addPP\_refold}}. \coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{induction} \coqdocvar{a}; \coqdoctac{auto}. \coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{B Unification.poly unif.substP distr mulPP}{\coqdoclemma{substP\_distr\_mulPP}}; \coqdoctac{auto}. \coqdoctac{f\_equal}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly unif.subst var eq}{\coqdoclemma{subst\_var\_eq}}; \coqdoctac{auto}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly unif.subst var eq}{\coqdoclemma{subst\_var\_eq}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly unif.substV is poly}{\coqdoclemma{substV\_is\_poly}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqref{B Unification.poly unif.substP refold}{\coqdoclemma{substP\_refold}}. \coqdoctac{apply} \coqdocvar{IHp}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The last lemmas of this section state that the identity substitution is a
    reproductive unifier of the constant zero. Therefore it is also most
    general. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.empty unifier}{empty\_unifier}{\coqdoclemma{empty\_unifier}} : \coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{unfold} \coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}}, \coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}}. \coqdoctac{split}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{intros}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.empty reprod unif}{empty\_reprod\_unif}{\coqdoclemma{empty\_reprod\_unif}} : \coqref{B Unification.poly unif.reprod unif}{\coqdocdefinition{reprod\_unif}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly unif.reprod unif}{\coqdocdefinition{reprod\_unif}}, \coqref{B Unification.poly unif.more general}{\coqdocdefinition{more\_general}}, \coqref{B Unification.poly unif.subst comp eq}{\coqdocdefinition{subst\_comp\_eq}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}; \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.poly unif.empty unifier}{\coqdoclemma{empty\_unifier}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.poly unif.empty mgu}{empty\_mgu}{\coqdoclemma{empty\_mgu}} : \coqref{B Unification.poly unif.mgu}{\coqdocdefinition{mgu}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly unif.reprod is mgu}{\coqdoclemma{reprod\_is\_mgu}}. \coqdoctac{apply} \coqref{B Unification.poly unif.empty reprod unif}{\coqdoclemma{empty\_reprod\_unif}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\end{coqdoccode}
\coqlibrary{B Unification.sve}{Library }{B\_Unification.sve}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclibrary{List}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.Arith}{\coqdoclibrary{Arith}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclibrary{Permutation}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{B Unification.poly unif}{\coqdoclibrary{poly\_unif}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Introduction}



 Here we implement the algorithm for successive variable elimination. The
    basic idea is to remove a variable from the problem, solve that simpler
    problem, and build a solution from the simpler solution. The algorithm is
    recursive, so variables are removed and problems are generated until we are
    left with either of two problems; $1 \stackrel{?}{\approx}_{B} 0$ or
    $0 \stackrel{?}{\approx}_{B} 0$. In the former case, the whole original
    problem is not unifiable. In the latter case, the problem is solved without
    any need to substitute since there are no variables. From here, we begin the
    process of building up substitutions until we reach the original problem. 

\section{Eliminating Variables}



 This section deals with the problem of removing a variable \coqdocvariable{x} from a term
    \textit{t}. The first thing to notice is that \textit{t} can be written in polynomial form
    $t\downarrow_{P}$. This polynomial is just a set of monomials, and each
    monomial a set of variables. We can now seperate the polynomials into two
    sets \coqdocvariable{qx} and \coqdocvariable{r}. The term \coqdocvariable{qx} will be the set of monomials in
    $t\downarrow_{P}$ that contain the variable \coqdocvariable{x}. The term \coqdocvariable{q}, or the
    quotient, is \coqdocvariable{qx} with the \coqdocvariable{x} removed from each monomial. The term \coqdocvariable{r}, or
    the remainder, will be the monomials in $t\downarrow_{P}$ that do not
    contain \coqdocvariable{x}. The original term can then be written as $x \ast q + r$. 

 Implementing this procedure is pretty straightforward. We define a function
    \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} that produces two polynomials given a polynomial \coqdocvariable{p} and a
    variable \coqdocvariable{x} to eliminate from it. The first step is dividing \coqdocvariable{p} into \coqdocvariable{qx}
    and \coqdocvariable{r} which is performed using a partition over \coqdocvariable{p} with the predicate
    \coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}}. The second step is to remove \coqdocvariable{x} from \coqdocvariable{qx} using the helper
    \coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}}. 

 The function \coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}} determines whether a variable appears in a monomial.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.sve.has var}{has\_var}{\coqdocdefinition{has\_var}} (\coqdocvar{x} : \coqref{B Unification.poly.var}{\coqdocdefinition{var}}) := \coqexternalref{existsb}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{existsb}} (\coqexternalref{beq nat}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdocabbreviation{beq\_nat}} \coqdocvariable{x}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The function \coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} removes a variable from each monomial in a
    polynomial. It is possible that this leaves the term not in polynomial form
    so it is then repaired with \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.sve.elim var}{elim\_var}{\coqdocdefinition{elim\_var}} (\coqdocvar{x} : \coqref{B Unification.poly.var}{\coqdocdefinition{var}}) (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvariable{x}) \coqdocvariable{p}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The function \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} produces a quotient \coqdocvariable{q} and remainder \coqdocvariable{r} from a
    polynomial \coqdocvariable{p} and variable \coqdocvariable{x} such that $p \approx_{B} x \ast q + r$ and
    \coqdocvariable{x} does not occur in \coqdocvariable{r}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.sve.div by var}{div\_by\_var}{\coqdocdefinition{div\_by\_var}} (\coqdocvar{x} : \coqref{B Unification.poly.var}{\coqdocdefinition{var}}) (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqexternalref{prod}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{prod}} \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} (\coqdocvar{qx}, \coqdocvar{r}) := \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} (\coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}} \coqdocvariable{x}) \coqdocvariable{p} \coqdoctac{in}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} \coqdocvariable{x} \coqdocvariable{qx}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We would also like to prove some lemmas about varaible elimination that
    will be helpful in proving the full algorithm correct later. The main lemma
    below is \coqref{B Unification.sve.div eq}{\coqdoclemma{div\_eq}}, which just asserts that after eliminating \coqdocvariable{x} from \coqdocvariable{p}
    into \coqdocvariable{q} and \coqdocvariable{r} the term can be put back together as in
    $p \approx_{B} x \ast q + r$. This fact turns out to be rather hard to prove
    and needs the help of 10 or so other sudsidiary lemmas. 

 After eliminating a variable \coqdocvariable{x} from a polynomial to produdce \coqdocvariable{r}, \coqdocvariable{x} does
    not occur in \coqdocvariable{r}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.elim var not in rem}{elim\_var\_not\_in\_rem}{\coqdoclemma{elim\_var\_not\_in\_rem}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} \coqdocvariable{x} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{r} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{r} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.In sorted}{\coqdoclemma{In\_sorted}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.nodup cancel in}{\coqdoclemma{nodup\_cancel\_in}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H0} \coqdockw{as} [\coqdocvar{n} []].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make mono In}{\coqdoclemma{make\_mono\_In}} \coqdoctac{in} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{remove In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{remove\_In}} \coqdoctac{in} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Eliminating a variable from a polynomial produces a term in polynomial form.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.elim var is poly}{elim\_var\_is\_poly}{\coqdoclemma{elim\_var\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} \coqdocvariable{x} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.make poly is poly}{\coqdoclemma{make\_poly\_is\_poly}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{elim\_var\_is\_poly}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The next four lemmas deal with the following scenario: Let \coqdocvariable{p} be a term in
    polynomial form, \coqdocvariable{x} be a variable that occurs in each monomial of \coqdocvariable{p}, and
    \coqdocvariable{r} = \coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} \coqdocvariable{x} \coqdocvariable{p}. 

 The term \coqdocvariable{r} is a permutation of removing \coqdocvariable{x} from \coqdocvariable{p}. Another way of
    looking at this statement is when \coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} repairs the term produced from
    removing a variable it only sorts that term. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.elim var map remove Permutation}{elim\_var\_map\_remove\_Permutation}{\coqdoclemma{elim\_var\_map\_remove\_Permutation}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} \coqdocvariable{x} \coqdocvariable{p}) (\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvariable{x}) \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{x} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{destruct} \coqdocvar{p} \coqdockw{as} [|\coqdocvar{a} \coqdocvar{p}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{unfold} \coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}}, \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}, \coqref{B Unification.poly.MonoSort.sort}{\coqdocdefinition{MonoSort.sort}}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{unfold} \coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}}. \coqdoctac{simpl}. \coqdoctac{unfold} \coqref{B Unification.poly.make poly}{\coqdocdefinition{make\_poly}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.Permutation MonoSort l}{\coqdoclemma{Permutation\_MonoSort\_l}}. \coqdoctac{rewrite} \coqref{B Unification.poly.unsorted poly}{\coqdoclemma{unsorted\_poly}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{map cons}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_cons}}. \coqdoctac{apply} \coqref{B Unification.poly.NoDup map remove}{\coqdoclemma{NoDup\_map\_remove}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.poly.poly cons}{\coqdoclemma{poly\_cons}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hin}. \coqdoctac{destruct} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H1}. \coqdoctac{apply} \coqref{B Unification.poly.remove is mono}{\coqdoclemma{remove\_is\_mono}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H1} \coqdockw{as} [\coqdocvar{y} []]. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H1}. \coqdoctac{apply} \coqref{B Unification.poly.remove is mono}{\coqdoclemma{remove\_is\_mono}}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H4}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The term $(x \ast r)\downarrow_{P}$ is a permutation of the result of
    removing \coqdocvariable{x} from \coqdocvariable{p}, appending \coqdocvariable{x} to the end of each monomial, and
    repairing each monomial. The proof relies on the \coqref{B Unification.poly.mulPP map app permutation}{\coqdoclemma{mulPP\_map\_app\_permutation}}
    lemma from the \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} library, which has a simpler goal but does much of the
    heavy lifting. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.rebuild map permutation}{rebuild\_map\_permutation}{\coqdoclemma{rebuild\_map\_permutation}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} (\coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} \coqdocvariable{x} \coqdocvariable{p}))\coqdoceol
\coqdocindent{7.00em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{a} \ensuremath{\Rightarrow} \coqref{B Unification.poly.make mono}{\coqdocdefinition{make\_mono}} (\coqdocvariable{a} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}))\coqdoceol
\coqdocindent{9.50em}
(\coqexternalref{map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} (\coqexternalref{remove}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{remove}} \coqref{B Unification.poly.var eq dec}{\coqdocdefinition{var\_eq\_dec}} \coqdocvariable{x}) \coqdocvariable{p})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{x} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{apply} \coqref{B Unification.poly.mulPP map app permutation}{\coqdoclemma{mulPP\_map\_app\_permutation}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} (\coqref{B Unification.sve.elim var not in rem}{\coqdoclemma{elim\_var\_not\_in\_rem}} \coqdocvar{x} \coqdocvar{p}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.sve.elim var map remove Permutation}{\coqdoclemma{elim\_var\_map\_remove\_Permutation}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The term \coqdocvariable{p} is a permutation of ($x \ast r)\downarrow_{P}$. Proof of this
    fact relies on the lengthy \coqref{B Unification.poly.map app remove Permutation}{\coqdoclemma{map\_app\_remove\_Permutation}} lemma from \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.elim var permutation}{elim\_var\_permutation}{\coqdoclemma{elim\_var\_permutation}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} \coqdocvar{x}, \coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{Permutation}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdocinductive{Permutation}} \coqdocvariable{p} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} (\coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} \coqdocvariable{x} \coqdocvariable{p})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{x} \coqdocvar{H} \coqdocvar{H0}. \coqdoctac{pose} (\coqref{B Unification.sve.rebuild map permutation}{\coqdoclemma{rebuild\_map\_permutation}} \coqdocvar{p} \coqdocvar{x} \coqdocvar{H} \coqdocvar{H0}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{Permutation sym}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_sym}} \coqdoctac{in} \coqdocvar{p0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{pose} (\coqref{B Unification.poly.map app remove Permutation}{\coqdoclemma{map\_app\_remove\_Permutation}} \coqdocvar{p} \coqdocvar{x} \coqdocvar{H} \coqdocvar{H0}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqexternalref{Permutation trans}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Sorting.Permutation}{\coqdoclemma{Permutation\_trans}} \coqdocvar{p1} \coqdocvar{p0}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Finally, $p = (x \ast r)\downarrow_{P}$. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.elim var mul}{elim\_var\_mul}{\coqdoclemma{elim\_var\_mul}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} (\coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} \coqdocvariable{x} \coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{apply} \coqref{B Unification.poly.Permutation Sorted eq}{\coqdoclemma{Permutation\_Sorted\_eq}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.sve.elim var permutation}{\coqdoclemma{elim\_var\_permutation}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.poly.Sorted MonoSorted}{\coqdoclemma{Sorted\_MonoSorted}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{pose} (\coqref{B Unification.poly.mulPP is poly}{\coqdoclemma{mulPP\_is\_poly}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} (\coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} \coqdocvar{x} \coqdocvar{p})). \coqdoctac{unfold} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdoctac{in} \coqdocvar{i}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.Sorted MonoSorted}{\coqdoclemma{Sorted\_MonoSorted}}. \coqdoctac{apply} \coqdocvar{i}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The function \coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}} is an equivalent boolean version of the \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}}
    predicate. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.has var eq in}{has\_var\_eq\_in}{\coqdoclemma{has\_var\_eq\_in}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}} \coqdocvariable{x} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqexternalref{existsb exists}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{existsb\_exists}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{x0} []].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Nat.eqb eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{Nat.eqb\_eq}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{\ensuremath{\exists}} \coqdocvar{x}. \coqdoctac{rewrite} \coqexternalref{Nat.eqb eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{Nat.eqb\_eq}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Let a polynomial \coqdocvariable{p} be partitioned by \coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}} \coqdocvariable{x} into two sets \coqdocvariable{qx} and
    \coqdocvariable{r}. Obviously, every monomial in \coqdocvariable{qx} contains \coqdocvariable{x} and no monomial in \coqdocvariable{r}
    contains \coqdocvariable{x}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.part var eq in}{part\_var\_eq\_in}{\coqdoclemma{part\_var\_eq\_in}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p} \coqdocvar{qx} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} (\coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}} \coqdocvariable{x}) \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{qx}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{qx} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.50em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{r} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.list util.part fst true}{\coqdoclemma{part\_fst\_true}} \coqdockw{with} (\coqdocvar{a}:=\coqdocvar{m}) \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{B Unification.sve.has var eq in}{\coqdoclemma{has\_var\_eq\_in}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.list util.part snd false}{\coqdoclemma{part\_snd\_false}} \coqdockw{with} (\coqdocvar{a}:=\coqdocvar{m}) \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.sve.has var eq in}{\coqdoclemma{has\_var\_eq\_in}}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The function \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} produces two terms both in polynomial form. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.div is poly}{div\_is\_poly}{\coqdoclemma{div\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvariable{x} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{q}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{r}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} (\coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}} \coqdocvar{x}) \coqdocvar{p}) \coqdocvar{eqn}:\coqdocvar{Hpart}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{B Unification.poly.part is poly}{\coqdoclemma{part\_is\_poly}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H}) \coqdoctac{in} \coqdocvar{Hpart} \coqdockw{as} \coqdocvar{Hp}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{Hp} \coqdockw{as} [\coqdocvar{Hpl} \coqdocvar{Hpr}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{injection} \coqdocvar{H0}. \coqdoctac{intros} \coqdocvar{Hr} \coqdocvar{Hq}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{Hr} \coqdoctac{in} \coqdocvar{Hpr}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.sve.part var eq in}{\coqdoclemma{part\_var\_eq\_in}} \coqdoctac{in} \coqdocvar{Hpart} \coqdockw{as} [\coqdocvar{Hin} \coqdocvar{Hout}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hq}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{Hpr}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
As explained earlier, given a polynomial \coqdocvariable{p} decomposed into a variable \coqdocvariable{x},
    a quotient \coqdocvariable{q}, and a remainder \coqdocvariable{r}, \coqref{B Unification.sve.div eq}{\coqdoclemma{div\_eq}} asserts that
    $p = (x \ast q + r)\downarrow_{P}$. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.div eq}{div\_eq}{\coqdoclemma{div\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvariable{x} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{q}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} \coqdocvariable{q}) \coqdocvariable{r}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{HP} \coqdocvar{HD}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{HE} := \coqdocvar{HD}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdoctac{in} \coqdocvar{HE}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} ((\coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} (\coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}} \coqdocvar{x}) \coqdocvar{p})) \coqdockw{as} [\coqdocvar{qx} \coqdocvar{r0}] \coqdocvar{eqn}:\coqdocvar{Hqr}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{injection} \coqdocvar{HE}. \coqdoctac{intros} \coqdocvar{Hr} \coqdocvar{Hq}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{HIH}: \coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvar{qx} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvar{x} \coqdocvariable{m}). \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.sve.has var eq in}{\coqdoclemma{has\_var\_eq\_in}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{B Unification.list util.part fst true}{\coqdoclemma{part\_fst\_true}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{Hqr} \coqdocvar{\_} \coqdocvar{H}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvar{q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvar{r}) \coqdockw{as} [\coqdocvar{HPq} \coqdocvar{HPr}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{B Unification.sve.div is poly}{\coqdoclemma{div\_is\_poly}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{HP} \coqdocvar{HD}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvar{qx} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvar{r0}) \coqdockw{as} [\coqdocvar{HPqx} \coqdocvar{HPr0}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{B Unification.poly.part is poly}{\coqdoclemma{part\_is\_poly}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{HP} \coqdocvar{Hqr}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hq}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.sve.elim var mul}{\coqdoclemma{elim\_var\_mul}} \coqdocvar{x} \coqdocvar{qx} \coqdocvar{HPqx} \coqdocvar{HIH}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{B Unification.poly.part add eq}{\coqdoclemma{part\_add\_eq}} (\coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}} \coqdocvar{x}) \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{HP}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hr}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{Hqr}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Given a variable \coqdocvariable{x}, \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} produces two polynomials neither of which
    contain \coqdocvariable{x}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.div var not in qr}{div\_var\_not\_in\_qr}{\coqdoclemma{div\_var\_not\_in\_qr}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvariable{x} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{q}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.50em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{m} \coqdocvariable{r} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{m}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{qxr}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{qxr} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} (\coqref{B Unification.sve.has var}{\coqdocdefinition{has\_var}} \coqdocvar{x}) \coqdocvar{p}) \coqdockw{as} [[\coqdocvar{qx} \coqdocvar{r0}] \coqdocvar{Hqxr}]. \coqdoctac{eauto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hqxr} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{injection} \coqdocvar{H}. \coqdoctac{intros} \coqdocvar{Hr} \coqdocvar{Hq}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} (\coqref{B Unification.sve.elim var not in rem}{\coqdoclemma{elim\_var\_not\_in\_rem}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{Hq}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{Hr} \coqdoctac{in} \coqdocvar{Hqxr}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{Hqxr}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros}. \coqdoctac{intro}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.sve.has var eq in}{\coqdoclemma{has\_var\_eq\_in}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{negb false iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_false\_iff}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{revert} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{eq true false abs}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.eq\_true\_false\_abs}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{negb true iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Bool.Bool}{\coqdoclemma{Bool.negb\_true\_iff}}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{revert} \coqdocvar{m} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} (\coqref{B Unification.list util.part snd false}{\coqdoclemma{part\_snd\_false}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{Hqxr}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This helper function \coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} is used to construct
    $p' = ((q + 1) * r)\downarrow_{P}$ given the two polynomials \coqdocvariable{q} and \coqdocvariable{r} as
    input. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.sve.build poly}{build\_poly}{\coqdocdefinition{build\_poly}} (\coqdocvar{q} \coqdocvar{r} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}} := \coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvariable{q}) \coqdocvariable{r}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The function \coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} produces a term in polynomial form. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.build poly is poly}{build\_poly\_is\_poly}{\coqdoclemma{build\_poly\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{q} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} (\coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} \coqdocvariable{q} \coqdocvariable{r}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{build\_poly\_is\_poly}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The second main lemma about varaible elimination is below. Given that a term
    \coqdocvariable{p} has been decomposed into the form $(x \ast q + r)\downarrow_{P}$, we can
    define $p' = ((q + 1) * r)\downarrow_{P}$. The lemma \coqref{B Unification.sve.div build unif}{\coqdoclemma{div\_build\_unif}} states
    that any unifier of $p \stackrel{?}{\approx}_{B} 0$ is also a unifier of
    $p' \stackrel{?}{\approx}_{B} 0$. Much of this proof relies on the axioms of
    polynomial arithmetic. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.div build unif}{div\_build\_unif}{\coqdoclemma{div\_build\_unif}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvariable{x} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{q}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{s} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{s} (\coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} \coqdocvariable{q} \coqdocvariable{r}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}}, \coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{s} \coqdocvar{HPp} \coqdocvar{HD} [\coqdocvar{Hps} \coqdocvar{Hsp0}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{B Unification.sve.div eq}{\coqdoclemma{div\_eq}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{HPp}) \coqdoctac{in} \coqdocvar{HD} \coqdockw{as} \coqdocvar{Hp}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{q1}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{q1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvar{q}) \coqdockw{as} [\coqdocvar{q1} \coqdocvar{Hq1}]. \coqdoctac{eauto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sp}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{sp} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{s} \coqdocvar{p}) \coqdockw{as} [\coqdocvar{sp} \coqdocvar{Hsp}]. \coqdoctac{eauto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{sq1}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{sq1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{s} \coqdocvar{q1}) \coqdockw{as} [\coqdocvar{sq1} \coqdocvar{Hsq1}]. \coqdoctac{eauto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.poly.mulPP 0}{\coqdoclemma{mulPP\_0}} (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{s} \coqdocvar{q1})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hsp0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{Hp}, \coqdocvar{Hq1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly unif.substP distr mulPP}{\coqdoclemma{substP\_distr\_mulPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{B Unification.sve.div is poly}{\coqdoclemma{div\_is\_poly}} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{HPp}) \coqdoctac{in} \coqdocvar{HD}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{HD} \coqdockw{as} [\coqdocvar{HPq} \coqdocvar{HPr}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP addPP 1}{\coqdoclemma{mulPP\_addPP\_1}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Given a polynomial \coqdocvariable{p} and a variable \coqdocvariable{x}, \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} produces two
    polynomials \coqdocvariable{q} and \coqdocvariable{r} that have no more variables than \coqdocvariable{p} has. Obviously,
    \coqdocvariable{q} and \coqdocvariable{r} don't contain \coqdocvariable{x} either. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.incl div}{incl\_div}{\coqdoclemma{incl\_div}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{xs},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvariable{x} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{q}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}) (\coqdocvariable{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{xs}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{q}) \coqdocvariable{xs} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{r}) \coqdocvariable{xs}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{assert} (\coqdocvar{Hdiv}:=\coqdocvar{H0}). \coqdoctac{unfold} \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdoctac{in} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqexternalref{partition}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{partition}} \coqdockw{as} [\coqdocvar{qx} \coqdocvar{r0}] \coqdocvar{eqn}:\coqdocvar{Hpart}. \coqdoctac{apply} \coqref{B Unification.list util.partition Permutation}{\coqdoclemma{partition\_Permutation}} \coqdoctac{in} \coqdocvar{Hpart}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.list util.Permutation incl}{\coqdoclemma{Permutation\_incl}} \coqdoctac{in} \coqdocvar{Hpart} \coqdockw{as} []. \coqdoctac{inversion} \coqdocvar{H0}. \coqdoctac{clear} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvar{q}) (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvar{p})). \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}, \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdoctac{in} *. \coqdoctac{intros} \coqdocvar{a} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}} \coqdoctac{in} \coqdocvar{Hin}. \coqdoctac{apply} \coqref{B Unification.list util.In concat exists}{\coqdoclemma{In\_concat\_exists}} \coqdoctac{in} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{Hin} \coqdockw{as} [\coqdocvar{m} []]. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H5} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{unfold} \coqref{B Unification.sve.elim var}{\coqdocdefinition{elim\_var}} \coqdoctac{in} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.In sorted}{\coqdoclemma{In\_sorted}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{apply} \coqref{B Unification.list util.nodup cancel in}{\coqdoclemma{nodup\_cancel\_in}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{rewrite} \coqexternalref{map map}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{map\_map}} \coqdoctac{in} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{in map iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{in\_map\_iff}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{destruct} \coqdocvar{H2} \coqdockw{as} [\coqdocvar{mx} []]. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H2} \coqdoctac{in} \coqdocvar{H4}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.make mono In}{\coqdoclemma{make\_mono\_In}} \coqdoctac{in} \coqdocvar{H4}. \coqdoctac{apply} \coqref{B Unification.list util.In remove}{\coqdoclemma{In\_remove}} \coqdoctac{in} \coqdocvar{H4}. \coqdoctac{apply} \coqref{B Unification.list util.In concat exists}{\coqdoclemma{In\_concat\_exists}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{\ensuremath{\exists}} \coqdocvar{mx}. \coqdoctac{split}; \coqdoctac{auto}. \coqdoctac{apply} \coqdocvar{H3}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvar{r}) (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvar{p})). \coqdoctac{rewrite} \coqdocvar{H6} \coqdoctac{in} \coqdocvar{H3}. \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}, \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdoctac{in} *.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{Hin}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}}. \coqdoctac{apply} \coqexternalref{nodup In}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{nodup\_In}} \coqdoctac{in} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.In concat exists}{\coqdoclemma{In\_concat\_exists}} \coqdoctac{in} \coqdocvar{Hin}. \coqdoctac{destruct} \coqdocvar{Hin} \coqdockw{as} [\coqdocvar{l} []].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.In concat exists}{\coqdoclemma{In\_concat\_exists}}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{l}. \coqdoctac{split}; \coqdoctac{auto}. \coqdoctac{apply} \coqdocvar{H3}. \coqdoctac{intuition}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{H5}. \coqdoctac{apply} \coqexternalref{incl tran}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{incl\_tran}} \coqdockw{with} (\coqdocvar{n}:=(\coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{xs})) \coqdoctac{in} \coqdocvar{H2}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.incl not in}{\coqdoclemma{incl\_not\_in}} \coqdoctac{in} \coqdocvar{H2}; \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.sve.div var not in qr}{\coqdoclemma{div\_var\_not\_in\_qr}} \coqdoctac{in} \coqdocvar{Hdiv} \coqdockw{as} [\coqdocvar{Hq} \coqdocvar{\_}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.in mono in vars}{\coqdoclemma{in\_mono\_in\_vars}} \coqdoctac{in} \coqdocvar{Hq}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{incl tran}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{incl\_tran}} \coqdockw{with} (\coqdocvar{n}:=(\coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{xs})) \coqdoctac{in} \coqdocvar{H4}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.incl not in}{\coqdoclemma{incl\_not\_in}} \coqdoctac{in} \coqdocvar{H4}; \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.sve.div var not in qr}{\coqdoclemma{div\_var\_not\_in\_qr}} \coqdoctac{in} \coqdocvar{Hdiv} \coqdockw{as} [\coqdocvar{\_} \coqdocvar{Hr}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly.in mono in vars}{\coqdoclemma{in\_mono\_in\_vars}} \coqdoctac{in} \coqdocvar{Hr}. \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Given a term \coqdocvariable{p} decomposed into the form $(x \ast q + r)\downarrow_{P}$,
    then the polynomial $p' = ((q + 1) * r)\downarrow_{P}$ has no more variables
    than \coqdocvariable{p} and does not contain \coqdocvariable{x}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.div vars}{div\_vars}{\coqdoclemma{div\_vars}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{xs} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}) (\coqdocvariable{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{xs}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvariable{x} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{q}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} (\coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} \coqdocvariable{q} \coqdocvariable{r})) \coqdocvariable{xs}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{xs} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{H} \coqdocvar{Hincl} \coqdocvar{Hdiv}. \coqdoctac{unfold} \coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.sve.div var not in qr}{\coqdoclemma{div\_var\_not\_in\_qr}} \coqdoctac{in} \coqdocvar{Hdiv} \coqdockw{as} \coqdocvar{Hin}. \coqdoctac{destruct} \coqdocvar{Hin} \coqdockw{as} [\coqdocvar{Hinq} \coqdocvar{Hinr}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.in mono in vars}{\coqdoclemma{in\_mono\_in\_vars}} \coqdoctac{in} \coqdocvar{Hinq}. \coqdoctac{apply} \coqref{B Unification.poly.in mono in vars}{\coqdoclemma{in\_mono\_in\_vars}} \coqdoctac{in} \coqdocvar{Hinr}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly.incl vars mulPP}{\coqdoclemma{incl\_vars\_mulPP}}. \coqdoctac{apply} (\coqref{B Unification.sve.incl div}{\coqdoclemma{incl\_div}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H} \coqdocvar{Hdiv}) \coqdoctac{in} \coqdocvar{Hincl}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.poly.incl vars addPP}{\coqdoclemma{incl\_vars\_addPP}}; \coqdoctac{auto}. \coqdoctac{apply} \coqref{B Unification.sve.div is poly}{\coqdoclemma{div\_is\_poly}} \coqdoctac{in} \coqdocvar{Hdiv} \coqdockw{as} []; \coqdoctac{auto}. \coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{unfold} \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}}. \coqdoctac{simpl}. \coqdoctac{unfold} \coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}}. \coqdoctac{intros} \coqdocvar{a} [].\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{Hincl}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{Hincl}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{div\_vars}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Building Substitutions}



 This section handles how a solution is built from subproblem solutions.
    Given that term \coqdocvariable{p} decomposed into $(x \ast q + r)\downarrow_{P}$ and
    $p' = ((q + 1) * r)\downarrow_{P}$, the lemma \coqref{B Unification.sve.reprod build subst}{\coqdoclemma{reprod\_build\_subst}} states
    that if some substitution $\sigma$ is a reproductive unifier of
    $p' \stackrel{?}{\approx}_{B} 0$, then we can build a substitution $\sigma'$
    which is a reproductive unifier of $p \stackrel{?}{\approx}_{B} 0$. The way
    $\sigma'$ is built from $\sigma$ is defined in \coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}}. Another
    replacement is added to $\sigma$ of the form
    $\{x \mapsto (x \ast (\sigma(q) + 1) + \sigma(r))\downarrow_{P}\}$ to
    construct $\sigma'$. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.sve.build subst}{build\_subst}{\coqdocdefinition{build\_subst}} (\coqdocvar{s} : \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}}) (\coqdocvar{x} : \coqref{B Unification.poly.var}{\coqdocdefinition{var}}) (\coqdocvar{q} \coqdocvar{r} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{q1} := \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvariable{q} \coqdoctac{in}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{q1s} := \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqdocvariable{q1} \coqdoctac{in}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{rs}  := \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvariable{s} \coqdocvariable{r} \coqdoctac{in}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{xs}  := \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvariable{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} \coqdocvariable{q1s}) \coqdocvariable{rs}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqdoctac{in}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{xs} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{s}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The function \coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}} produces a substitution whose range only
    contains polynomials. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.build subst is poly}{build\_subst\_is\_poly}{\coqdoclemma{build\_subst\_is\_poly}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} \coqdocvar{x} \coqdocvar{q} \coqdocvar{r},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} (\coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}} \coqdocvariable{s} \coqdocvariable{x} \coqdocvariable{q} \coqdocvariable{r}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H0}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} (\coqdocvar{H} \coqdocvar{x0}). \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Given that term \coqdocvariable{p} decomposed into $(x \ast q + r)\downarrow_{P}$,
    $p' = ((q + 1) * r)\downarrow_{P}$, and $\sigma$ is a reproductive unifier
    of $p' \stackrel{?}{\approx}_{B} 0$, then the substitution $\sigma'$ built
    from $\sigma$ unifies $p \stackrel{?}{\approx}_{B} 0$. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.build subst is unif}{build\_subst\_is\_unif}{\coqdoclemma{build\_subst\_is\_unif}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvariable{x} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{q}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.reprod unif}{\coqdocdefinition{reprod\_unif}} \coqdocvariable{s} (\coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} \coqdocvariable{q} \coqdocvariable{r}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} (\coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}} \coqdocvariable{s} \coqdocvariable{x} \coqdocvariable{q} \coqdocvariable{r}) \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly unif.reprod unif}{\coqdocdefinition{reprod\_unif}}, \coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{s} \coqdocvar{Hpoly} \coqdocvar{Hdiv} [[\coqdocvar{Hps} \coqdocvar{Hunif}] \coqdocvar{Hreprod}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} (\coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}} \coqdocvar{s} \coqdocvar{x} \coqdocvar{q} \coqdocvar{r})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.sve.build subst is poly}{\coqdoclemma{build\_subst\_is\_poly}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} \coqdoctac{in} \coqdocvar{Hunif}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{Hnqr} := \coqdocvar{Hdiv}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.sve.div var not in qr}{\coqdoclemma{div\_var\_not\_in\_qr}} \coqdoctac{in} \coqdocvar{Hnqr}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{Hnqr} \coqdockw{as} [\coqdocvar{Hnq} \coqdocvar{Hnr}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{HpolyQR} := \coqdocvar{Hdiv}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.sve.div is poly}{\coqdoclemma{div\_is\_poly}} \coqdoctac{in} \coqdocvar{HpolyQR} \coqdockw{as} [\coqdocvar{HpolyQ} \coqdocvar{HpolyR}]; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.sve.div eq}{\coqdoclemma{div\_eq}} \coqdoctac{in} \coqdocvar{Hdiv}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{Hdiv}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP distr addPP}{\coqdoclemma{substP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP distr mulPP}{\coqdoclemma{substP\_distr\_mulPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly unif.substP cons}{\coqdoclemma{substP\_cons}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{Hnq}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly unif.substP cons}{\coqdoclemma{substP\_cons}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{Hnr}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{Hsx}: \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}\coqdoceol
\coqdocindent{4.00em}
(\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{4.50em}
\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}\coqdoceol
\coqdocindent{5.50em}
(\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}\coqdoceol
              (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{s} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvar{q})))\coqdoceol
\coqdocindent{5.50em}
(\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{s} \coqdocvar{r})\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{s}) \coqdoceol
\coqdocindent{4.00em}
\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}}\coqdoceol
\coqdocindent{4.50em}
(\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}\coqdoceol
            (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{s} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvar{q})))\coqdoceol
\coqdocindent{4.50em}
(\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{s} \coqdocvar{r})\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{beq nat refl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_refl}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP 1r}{\coqdoclemma{mulPP\_1r}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqexternalref{app nil r}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_nil\_r}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.no make poly}{\coqdoclemma{no\_make\_poly}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{Hsx}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP distr addPP}{\coqdoclemma{substP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP 1}{\coqdoclemma{substP\_1}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP distr addPPr}{\coqdoclemma{mulPP\_distr\_addPPr}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP 1r}{\coqdoclemma{mulPP\_1r}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP distr addPP}{\coqdoclemma{mulPP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP distr addPP}{\coqdoclemma{mulPP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP assoc}{\coqdoclemma{mulPP\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP p p}{\coqdoclemma{mulPP\_p\_p}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.addPP p p}{\coqdoclemma{addPP\_p\_p}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.addPP 0}{\coqdoclemma{addPP\_0}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly unif.substP distr mulPP}{\coqdoclemma{substP\_distr\_mulPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly unif.substP distr addPP}{\coqdoclemma{substP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{B Unification.poly.mulPP 1r}{\coqdoclemma{mulPP\_1r}} \coqdocvar{r}) \coqdoctac{at} 2; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}} \coqdocvar{r} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.mulPP distr addPP}{\coqdoclemma{mulPP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.addPP comm}{\coqdoclemma{addPP\_comm}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Given that term \coqdocvariable{p} decomposed into $(x \ast q + r)\downarrow_{P}$,
    $p' = ((q + 1) * r)\downarrow_{P}$, and $\sigma$ is a reproductive unifier
    of $p' \stackrel{?}{\approx}_{B} 0$, then the substitution $\sigma'$ built
    from $\sigma$ is reproductive with regards to unifiers of
    $p \stackrel{?}{\approx}_{B} 0$. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.build subst is reprod}{build\_subst\_is\_reprod}{\coqdoclemma{build\_subst\_is\_reprod}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvariable{x} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{q}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.reprod unif}{\coqdocdefinition{reprod\_unif}} \coqdocvariable{s} (\coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} \coqdocvariable{q} \coqdocvariable{r}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} \coqdocvariable{t} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{6.00em}
\coqref{B Unification.poly unif.subst comp eq}{\coqdocdefinition{subst\_comp\_eq}} (\coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}} \coqdocvariable{s} \coqdocvariable{x} \coqdocvariable{q} \coqdocvariable{r}) \coqdocvariable{t} \coqdocvariable{t}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly unif.reprod unif}{\coqdocdefinition{reprod\_unif}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{s} \coqdocvar{HpolyP} \coqdocvar{Hdiv} [[\coqdocvar{HpsS} \coqdocvar{HunifS}] \coqdocvar{Hsub\_comp}] \coqdocvar{t} \coqdocvar{HunifT}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{HunifT'} := \coqdocvar{HunifT}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{HunifT} \coqdockw{as} [\coqdocvar{HpsT} \coqdocvar{HunifT}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{B Unification.sve.div build unif}{\coqdoclemma{div\_build\_unif}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{HpolyP} \coqdocvar{Hdiv}) \coqdoctac{in} \coqdocvar{HunifT'}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{B Unification.poly unif.subst comp eq}{\coqdocdefinition{subst\_comp\_eq}} \coqdoctac{in} *.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{y} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{=?}} \coqdocvar{x}) \coqdocvar{eqn}:\coqdocvar{Hyx}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{H}: \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} (\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{s} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvar{q})))\coqdoceol
\coqdocindent{17.00em}
(\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{s} \coqdocvar{r})\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{s}) \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvar{y}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{7.50em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} (\coqref{B Unification.poly.mulPP}{\coqdocdefinition{mulPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}} (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{s} (\coqref{B Unification.poly.addPP}{\coqdocdefinition{addPP}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvar{q}))) (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{s} \coqdocvar{r})\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{unfold} \coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{Hyx}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP 1r}{\coqdoclemma{mulPP\_1r}}; \coqdoctac{auto}. \coqdoctac{rewrite} \coqexternalref{app nil r}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{app\_nil\_r}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.no make poly}{\coqdoclemma{no\_make\_poly}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP distr addPP}{\coqdoclemma{substP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP distr mulPP}{\coqdoclemma{substP\_distr\_mulPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{pose} (\coqref{B Unification.sve.div is poly}{\coqdoclemma{div\_is\_poly}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{HpolyP} \coqdocvar{Hdiv}); \coqdoctac{destruct} \coqdocvar{a}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP distr addPP}{\coqdoclemma{substP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP distr addPP}{\coqdoclemma{substP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP 1}{\coqdoclemma{substP\_1}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{Hdiv2} := \coqdocvar{Hdiv}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.sve.div eq}{\coqdoclemma{div\_eq}} \coqdoctac{in} \coqdocvar{Hdiv}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.sve.div is poly}{\coqdoclemma{div\_is\_poly}} \coqdoctac{in} \coqdocvar{Hdiv2} \coqdockw{as} [\coqdocvar{HpolyQ} \coqdocvar{HpolyR}]; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly unif.subst comp eq poly}{\coqdoclemma{subst\_comp\_eq\_poly}} \coqdocvar{s} \coqdocvar{t} \coqdocvar{t}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly unif.subst comp eq poly}{\coqdoclemma{subst\_comp\_eq\_poly}} \coqdocvar{s} \coqdocvar{t} \coqdocvar{t}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP distr addPP}{\coqdoclemma{mulPP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP 1r}{\coqdoclemma{mulPP\_1r}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.addPP comm}{\coqdoclemma{addPP\_comm}} (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{t} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}) \coqdocvar{\_}); \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.addPP assoc}{\coqdoclemma{addPP\_assoc}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} (\coqref{B Unification.poly.addPP comm}{\coqdoclemma{addPP\_comm}} (\coqref{B Unification.poly unif.substP}{\coqdocdefinition{substP}} \coqdocvar{t} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{]]}}) \coqdocvar{\_} ); \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly.addPP assoc}{\coqdoclemma{addPP\_assoc}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly unif.substP distr mulPP}{\coqdoclemma{substP\_distr\_mulPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{B Unification.poly unif.substP distr addPP}{\coqdoclemma{substP\_distr\_addPP}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.mulPP comm}{\coqdoclemma{mulPP\_comm}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hdiv}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{HunifT}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{HunifT}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly.addPP 0}{\coqdoclemma{addPP\_0}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{beq nat true}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.EqNat}{\coqdoclemma{beq\_nat\_true}} \coqdoctac{in} \coqdocvar{Hyx}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Hyx}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{unfold} \coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP cons}{\coqdoclemma{substP\_cons}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{inversion} \coqdocvar{H}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{intro}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{H1}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{Nat.eqb eq}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Arith.PeanoNat}{\coqdoclemma{Nat.eqb\_eq}} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Hyx} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{inversion} \coqdocvar{H1}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Given that term \coqdocvariable{p} decomposed into $(x \ast q + r)\downarrow_{P}$,
    $p' = ((q + 1) * r)\downarrow_{P}$, and a reproductive unifier $\sigma$ of
    $p' \stackrel{?}{\approx}_{B} 0$, then the substitution $\sigma'$ built from
    $\sigma$ is a reproductive unifier $p \stackrel{?}{\approx}_{B} 0$ based on
    the previous two lemmas. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.reprod build subst}{reprod\_build\_subst}{\coqdoclemma{reprod\_build\_subst}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvariable{x} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{q}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{r}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.reprod unif}{\coqdocdefinition{reprod\_unif}} \coqdocvariable{s} (\coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} \coqdocvariable{q} \coqdocvariable{r}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly unif.reprod unif}{\coqdocdefinition{reprod\_unif}} (\coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}} \coqdocvariable{s} \coqdocvariable{x} \coqdocvariable{q} \coqdocvariable{r}) \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{B Unification.poly unif.reprod unif}{\coqdocdefinition{reprod\_unif}}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.sve.build subst is unif}{\coqdoclemma{build\_subst\_is\_unif}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{B Unification.sve.build subst is reprod}{\coqdoclemma{build\_subst\_is\_reprod}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Recursive Algorithm}



 Now we define the actual algorithm of successive variable elimination.
    Built using five helper functions, the definition is not too difficult to
    construct or understand. The general idea, as mentioned before, is to remove
    one variable at a time, creating simpler problems. Once the simplest problem
    has been reached, to which the solution is already known, every solution to
    each subproblem can be built from the solution to the successive subproblem.
    Formally, given the polynomials $p = (x \ast q + r)\downarrow_{P}$ and
    $p' = ((q + 1) * r)\downarrow_{P}$, the solution to
    $p \stackrel{?}{\approx}_{B} 0$ is built from the solution to
    $p' \stackrel{?}{\approx}_{B} 0$. If $\sigma$ solves
    $p' \stackrel{?}{\approx}_{B} 0$, then $\sigma \cup \{x \mapsto (x \ast
    (\sigma(q) + 1) + \sigma(r))\downarrow_{P}\}$ solves
    $p \stackrel{?}{\approx}_{B} 0$. 

 The function \coqref{B Unification.sve.sve}{\coqdocdefinition{sve}} is the final result, but it is \coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} which actually
    has all of the meat. Due to Coq's rigid type system, every recursive
    function must be obviously terminating. This means that one of the arguments
    must decrease with each nested call. It turns out that Coq's type checker
    is unable to deduce that continually building polynomials from the quotient
    and remainder of previous ones will eventually result in 0 or 1. So
    instead we add a fuel argument that explicitly decreases per recursive call.
    We use the set of variables in the polynomial for this purpose, since each
    subsequent call has at least one less variable. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{B Unification.sve.sveVars}{sveVars}{\coqdocdefinition{sveVars}} (\coqdocvar{varlist} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}}) (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{varlist} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqdoceol
\coqdocindent{3.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{\_}  \ensuremath{\Rightarrow} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}    \coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{x} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvar{xs} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} (\coqdocvar{q}, \coqdocvar{r}) := \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvar{x} \coqdocvariable{p} \coqdoctac{in}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{p'} := (\coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} \coqdocvariable{q} \coqdocvariable{r}) \coqdoctac{in}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{match} \coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} \coqdocvar{xs} \coqdocvariable{p'} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{s} \ensuremath{\Rightarrow} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqref{B Unification.sve.build subst}{\coqdocdefinition{build\_subst}} \coqdocvar{s} \coqdocvar{x} \coqdocvariable{q} \coqdocvariable{r})\coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The function \coqref{B Unification.sve.sve}{\coqdocdefinition{sve}} simply calls \coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} with an initial fuel of \coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}.
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{B Unification.sve.sve}{sve}{\coqdocdefinition{sve}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}) : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqref{B Unification.poly unif.subst}{\coqdocdefinition{subst}} := \coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}) \coqdocvariable{p}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Correctness}



 Finally, we must show that this algorithm is correct. As discussed in the
    beginning, the correctness of a unification algorithm is proven for two
    cases. If the algorithm produces a solution for a problem, then the solution
    must be most general. If the algorithm produces no solution, then the
    problem must be not unifiable. These statements have been formalized in the
    theorem \coqref{B Unification.sve.sve correct}{\coqdoclemma{sve\_correct}} with the help of the predicates \coqref{B Unification.poly unif.mgu}{\coqdocdefinition{mgu}} and \coqref{B Unification.poly unif.unifiable}{\coqdocdefinition{unifiable}}
    as defined in the library \coqdoclibrary{poly\_unif}. The two cases of the proof are
    handled seperately by the lemmas \coqref{B Unification.sve.sveVars some}{\coqdoclemma{sveVars\_some}} and \coqref{B Unification.sve.sveVars none}{\coqdoclemma{sveVars\_none}}. 

 If \coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} produces a substitution $\sigma$, then the range of $\sigma$
    only contains polynomials. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.sveVars poly subst}{sveVars\_poly\_subst}{\coqdoclemma{sveVars\_poly\_subst}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{xs} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}) \coqdocvariable{xs} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} \coqdocvariable{xs} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{6.00em}
\coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}} \coqdocvariable{s}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{xs} \coqdockw{as} [|\coqdocvar{x} \coqdocvar{xs}]; \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{p}; \coqdoctac{inversion} \coqdocvar{H1}. \coqdoctac{unfold} \coqref{B Unification.poly unif.is poly subst}{\coqdocdefinition{is\_poly\_subst}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{p} [].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{qr}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvar{x} \coqdocvar{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{qr}) \coqdockw{as} [[\coqdocvar{q} \coqdocvar{r}] \coqdocvar{Hqr}]. \coqdoctac{eauto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Hqr} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} \coqdocvar{xs} (\coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} \coqdocvar{q} \coqdocvar{r})) \coqdocvar{eqn}:\coqdocvar{Hs0}; \coqdoctac{inversion} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{IHxs} \coqdoctac{in} \coqdocvar{Hs0}; \coqdoctac{eauto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.sve.build subst is poly}{\coqdoclemma{build\_subst\_is\_poly}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If \coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} produces a substitution $\sigma$ for the polynomial \coqdocvariable{p}, then
    $\sigma$ is a most general unifier of $p \stackrel{?}{\approx}_{B} 0$. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.sveVars some}{sveVars\_some}{\coqdoclemma{sveVars\_some}} :  \coqdockw{\ensuremath{\forall}} (\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}}) (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{xs} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}) \coqdocvariable{xs} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} \coqdocvariable{xs} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{6.00em}
\coqref{B Unification.poly unif.mgu}{\coqdocdefinition{mgu}} \coqdocvariable{s} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{xs} \coqdocvar{p} \coqdocvar{Hdup} \coqdocvar{H} \coqdocvar{H0} \coqdocvar{s} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.poly unif.reprod is mgu}{\coqdoclemma{reprod\_is\_mgu}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{revert} \coqdocvar{xs} \coqdocvar{p} \coqdocvar{Hdup} \coqdocvar{H} \coqdocvar{H0} \coqdocvar{s} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{xs} \coqdockw{as} [|\coqdocvar{x} \coqdocvar{xs}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{p}; \coqdoctac{inversion} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.poly unif.empty reprod unif}{\coqdoclemma{empty\_reprod\_unif}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{qr}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvar{x} \coqdocvar{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{qr}) \coqdockw{as} [[\coqdocvar{q} \coqdocvar{r}] \coqdocvar{Hqr}]. \coqdoctac{eauto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Hqr} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} \coqdocvar{xs} (\coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} \coqdocvar{q} \coqdocvar{r})) \coqdocvar{eqn}:\coqdocvar{Hs0}; \coqdoctac{inversion} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{Hdup} \coqdockw{as} \coqdocvar{Hnin}. \coqdoctac{destruct} \coqdocvar{Hnin} \coqdockw{as} [\coqdocvar{Hnin} \coqdocvar{Hdup0}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.sve.sveVars poly subst}{\coqdoclemma{sveVars\_poly\_subst}} \coqdoctac{in} \coqdocvar{Hs0} \coqdockw{as} \coqdocvar{HpsS0}; \coqdoctac{eauto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{IHxs} \coqdoctac{in} \coqdocvar{Hs0}; \coqdoctac{eauto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.sve.reprod build subst}{\coqdoclemma{reprod\_build\_subst}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If \coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} does not produce a substitution for the polynomial \coqdocvariable{p}, then
    the problem $p \stackrel{?}{\approx}_{B} 0$ is not unifiable. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.sveVars none}{sveVars\_none}{\coqdoclemma{sveVars\_none}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{B Unification.poly.var}{\coqdocdefinition{var}}) (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{NoDup}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocinductive{NoDup}} \coqdocvariable{xs} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{incl}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdocdefinition{incl}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}) \coqdocvariable{xs} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} \coqdocvariable{xs} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{B Unification.poly unif.unifiable}{\coqdocdefinition{unifiable}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{xs} \coqdockw{as} [|\coqdocvar{x} \coqdocvar{xs}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{p} \coqdocvar{Hdup} \coqdocvar{H} \coqdocvar{H0} \coqdocvar{H1}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{destruct} \coqdocvar{p}; \coqdoctac{inversion} \coqdocvar{H1}. \coqdoctac{intro}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{B Unification.poly unif.unifiable}{\coqdocdefinition{unifiable}} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{destruct} \coqdocvar{H2}. \coqdoctac{unfold} \coqref{B Unification.poly unif.unifier}{\coqdocdefinition{unifier}} \coqdoctac{in} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{B Unification.list util.incl nil}{\coqdoclemma{incl\_nil}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqref{B Unification.poly.no vars is ground}{\coqdoclemma{no\_vars\_is\_ground}} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{H}; \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H4} \coqdoctac{in} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H5} \coqdoctac{in} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{B Unification.poly unif.substP 1}{\coqdoclemma{substP\_1}} \coqdoctac{in} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{inversion} \coqdocvar{H2}. \coqdoctac{inversion} \coqdocvar{H6}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{p} \coqdocvar{Hdup} \coqdocvar{H} \coqdocvar{H0} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{qr}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{B Unification.sve.div by var}{\coqdocdefinition{div\_by\_var}} \coqdocvar{x} \coqdocvar{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{qr}) \coqdockw{as} [[\coqdocvar{q} \coqdocvar{r}] \coqdocvar{Hqr}]. \coqdoctac{eauto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Hqr} \coqdoctac{in} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} (\coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} \coqdocvar{xs} (\coqref{B Unification.sve.build poly}{\coqdocdefinition{build\_poly}} \coqdocvar{q} \coqdocvar{r})) \coqdocvar{eqn}:\coqdocvar{Hs0}; \coqdoctac{inversion} \coqdocvar{H1}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{NoDup cons iff}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Lists.List}{\coqdoclemma{NoDup\_cons\_iff}} \coqdoctac{in} \coqdocvar{Hdup} \coqdockw{as} \coqdocvar{Hnin}. \coqdoctac{destruct} \coqdocvar{Hnin} \coqdockw{as} [\coqdocvar{Hnin} \coqdocvar{Hdup0}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{IHxs} \coqdoctac{in} \coqdocvar{Hs0}; \coqdoctac{eauto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}}, \coqref{B Unification.poly unif.unifiable}{\coqdocdefinition{unifiable}} \coqdoctac{in} *.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{Hs0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{H2} \coqdockw{as} [\coqdocvar{s} \coqdocvar{Hu}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{\ensuremath{\exists}} \coqdocvar{s}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} (\coqref{B Unification.sve.div build unif}{\coqdoclemma{div\_build\_unif}} \coqdocvar{x} \coqdocvar{p}); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{NoDup\_vars} \coqdocvar{incl\_refl}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If \coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} produces a substitution $\sigma$ for the polynomial \coqdocvariable{p}, then
    $\sigma$ is a most general unifier of $p \stackrel{?}{\approx}_{B} 0$.
    Otherwise, $p \stackrel{?}{\approx}_{B} 0$ is not unifiable. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{B Unification.sve.sveVars correct}{sveVars\_correct}{\coqdoclemma{sveVars\_correct}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvariable{p}) \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{s} \ensuremath{\Rightarrow} \coqref{B Unification.poly unif.mgu}{\coqdocdefinition{mgu}} \coqdocvar{s} \coqdocvariable{p}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{B Unification.poly unif.unifiable}{\coqdocdefinition{unifiable}} \coqdocvariable{p}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqref{B Unification.sve.sveVars}{\coqdocdefinition{sveVars}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvar{p}) \coqdocvar{p}) \coqdocvar{eqn}: \coqdocvar{Hsve}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} (\coqref{B Unification.sve.sveVars some}{\coqdoclemma{sveVars\_some}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvar{p})); \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} (\coqref{B Unification.sve.sveVars none}{\coqdoclemma{sveVars\_none}} (\coqref{B Unification.poly.vars}{\coqdocdefinition{vars}} \coqdocvar{p})); \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If \coqref{B Unification.sve.sve}{\coqdocdefinition{sve}} produces a substitution $\sigma$ for the polynomial \coqdocvariable{p}, then
    $\sigma$ is a most general unifier of $p \stackrel{?}{\approx}_{B} 0$.
    Otherwise, $p \stackrel{?}{\approx}_{B} 0$ is not unifiable. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{B Unification.sve.sve correct}{sve\_correct}{\coqdoclemma{sve\_correct}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqref{B Unification.poly.poly}{\coqdocdefinition{poly}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{B Unification.poly.is poly}{\coqdocdefinition{is\_poly}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqref{B Unification.sve.sve}{\coqdocdefinition{sve}} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{s} \ensuremath{\Rightarrow} \coqref{B Unification.poly unif.mgu}{\coqdocdefinition{mgu}} \coqdocvar{s} \coqdocvariable{p}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.9.0/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{B Unification.poly unif.unifiable}{\coqdocdefinition{unifiable}} \coqdocvariable{p}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{B Unification.sve.sveVars correct}{\coqdoclemma{sveVars\_correct}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plainnat}
\bibliography{intro}
 \begin{coqdoccode}
\end{coqdoccode}
\end{document}
